
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model StaffProfile
 * 
 */
export type StaffProfile = $Result.DefaultSelection<Prisma.$StaffProfilePayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Ward
 * 
 */
export type Ward = $Result.DefaultSelection<Prisma.$WardPayload>
/**
 * Model Bed
 * 
 */
export type Bed = $Result.DefaultSelection<Prisma.$BedPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model MedicalHistory
 * 
 */
export type MedicalHistory = $Result.DefaultSelection<Prisma.$MedicalHistoryPayload>
/**
 * Model PatientDocument
 * 
 */
export type PatientDocument = $Result.DefaultSelection<Prisma.$PatientDocumentPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model OpdVisit
 * 
 */
export type OpdVisit = $Result.DefaultSelection<Prisma.$OpdVisitPayload>
/**
 * Model Admission
 * 
 */
export type Admission = $Result.DefaultSelection<Prisma.$AdmissionPayload>
/**
 * Model BedTransfer
 * 
 */
export type BedTransfer = $Result.DefaultSelection<Prisma.$BedTransferPayload>
/**
 * Model Surgery
 * 
 */
export type Surgery = $Result.DefaultSelection<Prisma.$SurgeryPayload>
/**
 * Model SurgerySStaff
 * 
 */
export type SurgerySStaff = $Result.DefaultSelection<Prisma.$SurgerySStaffPayload>
/**
 * Model SurgicalChecklist
 * 
 */
export type SurgicalChecklist = $Result.DefaultSelection<Prisma.$SurgicalChecklistPayload>
/**
 * Model ClinicalNote
 * 
 */
export type ClinicalNote = $Result.DefaultSelection<Prisma.$ClinicalNotePayload>
/**
 * Model ServiceOrder
 * 
 */
export type ServiceOrder = $Result.DefaultSelection<Prisma.$ServiceOrderPayload>
/**
 * Model LabResult
 * 
 */
export type LabResult = $Result.DefaultSelection<Prisma.$LabResultPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model PrescriptionItem
 * 
 */
export type PrescriptionItem = $Result.DefaultSelection<Prisma.$PrescriptionItemPayload>
/**
 * Model Medicine
 * 
 */
export type Medicine = $Result.DefaultSelection<Prisma.$MedicinePayload>
/**
 * Model PharmacySale
 * 
 */
export type PharmacySale = $Result.DefaultSelection<Prisma.$PharmacySalePayload>
/**
 * Model SaleItem
 * 
 */
export type SaleItem = $Result.DefaultSelection<Prisma.$SaleItemPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceItem
 * 
 */
export type InvoiceItem = $Result.DefaultSelection<Prisma.$InvoiceItemPayload>
/**
 * Model InsuranceClaim
 * 
 */
export type InsuranceClaim = $Result.DefaultSelection<Prisma.$InsuranceClaimPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  Admin: 'Admin',
  Doctor: 'Doctor',
  Nurse: 'Nurse',
  Receptionist: 'Receptionist',
  Pharmacist: 'Pharmacist',
  LabTech: 'LabTech'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const DepartmentType: {
  Clinical: 'Clinical',
  Non_Clinical: 'Non_Clinical',
  Diagnostic: 'Diagnostic'
};

export type DepartmentType = (typeof DepartmentType)[keyof typeof DepartmentType]


export const ServiceCategory: {
  Radiology: 'Radiology',
  Lab: 'Lab',
  Procedure: 'Procedure',
  Nursing: 'Nursing'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const BedStatus: {
  Available: 'Available',
  Occupied: 'Occupied',
  Cleaning: 'Cleaning',
  Maintenance: 'Maintenance'
};

export type BedStatus = (typeof BedStatus)[keyof typeof BedStatus]


export const Gender: {
  Male: 'Male',
  Female: 'Female',
  Other: 'Other'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const AppointmentStatus: {
  Scheduled: 'Scheduled',
  CheckedIn: 'CheckedIn',
  Completed: 'Completed',
  Cancelled: 'Cancelled'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const AppointmentType: {
  New: 'New',
  FollowUp: 'FollowUp'
};

export type AppointmentType = (typeof AppointmentType)[keyof typeof AppointmentType]


export const VisitType: {
  OPD: 'OPD',
  Emergency: 'Emergency',
  IPD_Checkin: 'IPD_Checkin'
};

export type VisitType = (typeof VisitType)[keyof typeof VisitType]


export const TriageColor: {
  Red: 'Red',
  Yellow: 'Yellow',
  Green: 'Green',
  Black: 'Black'
};

export type TriageColor = (typeof TriageColor)[keyof typeof TriageColor]


export const VisitStatus: {
  Waiting: 'Waiting',
  Triaged: 'Triaged',
  InConsultation: 'InConsultation',
  Completed: 'Completed',
  Admitted: 'Admitted'
};

export type VisitStatus = (typeof VisitStatus)[keyof typeof VisitStatus]


export const AdmissionType: {
  Planned: 'Planned',
  Emergency: 'Emergency',
  Transfer: 'Transfer'
};

export type AdmissionType = (typeof AdmissionType)[keyof typeof AdmissionType]


export const AdmissionStatus: {
  Admitted: 'Admitted',
  Discharged: 'Discharged',
  TransferOut: 'TransferOut'
};

export type AdmissionStatus = (typeof AdmissionStatus)[keyof typeof AdmissionStatus]


export const DischargeType: {
  Normal: 'Normal',
  LAMA: 'LAMA',
  Death: 'Death',
  Referred: 'Referred'
};

export type DischargeType = (typeof DischargeType)[keyof typeof DischargeType]


export const SurgeryStatus: {
  Scheduled: 'Scheduled',
  InProgress: 'InProgress',
  Completed: 'Completed'
};

export type SurgeryStatus = (typeof SurgeryStatus)[keyof typeof SurgeryStatus]


export const ChecklistStage: {
  Sign_In: 'Sign_In',
  Time_Out: 'Time_Out',
  Sign_Out: 'Sign_Out'
};

export type ChecklistStage = (typeof ChecklistStage)[keyof typeof ChecklistStage]


export const NoteType: {
  SOAP: 'SOAP',
  ProgressNote: 'ProgressNote',
  DischargeSummary: 'DischargeSummary',
  PreOp: 'PreOp'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]


export const OrderType: {
  Lab: 'Lab',
  Radiology: 'Radiology',
  Procedure: 'Procedure'
};

export type OrderType = (typeof OrderType)[keyof typeof OrderType]


export const OrderPriority: {
  Routine: 'Routine',
  Stat: 'Stat'
};

export type OrderPriority = (typeof OrderPriority)[keyof typeof OrderPriority]


export const OrderStatus: {
  Ordered: 'Ordered',
  SampleCollected: 'SampleCollected',
  ResultAvailable: 'ResultAvailable',
  Completed: 'Completed'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const InvoiceStatus: {
  Draft: 'Draft',
  Finalized: 'Finalized',
  Paid: 'Paid'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const ClaimStatus: {
  Submitted: 'Submitted',
  QueryRaised: 'QueryRaised',
  Approved: 'Approved',
  Rejected: 'Rejected'
};

export type ClaimStatus = (typeof ClaimStatus)[keyof typeof ClaimStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type DepartmentType = $Enums.DepartmentType

export const DepartmentType: typeof $Enums.DepartmentType

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type BedStatus = $Enums.BedStatus

export const BedStatus: typeof $Enums.BedStatus

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type AppointmentType = $Enums.AppointmentType

export const AppointmentType: typeof $Enums.AppointmentType

export type VisitType = $Enums.VisitType

export const VisitType: typeof $Enums.VisitType

export type TriageColor = $Enums.TriageColor

export const TriageColor: typeof $Enums.TriageColor

export type VisitStatus = $Enums.VisitStatus

export const VisitStatus: typeof $Enums.VisitStatus

export type AdmissionType = $Enums.AdmissionType

export const AdmissionType: typeof $Enums.AdmissionType

export type AdmissionStatus = $Enums.AdmissionStatus

export const AdmissionStatus: typeof $Enums.AdmissionStatus

export type DischargeType = $Enums.DischargeType

export const DischargeType: typeof $Enums.DischargeType

export type SurgeryStatus = $Enums.SurgeryStatus

export const SurgeryStatus: typeof $Enums.SurgeryStatus

export type ChecklistStage = $Enums.ChecklistStage

export const ChecklistStage: typeof $Enums.ChecklistStage

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

export type OrderType = $Enums.OrderType

export const OrderType: typeof $Enums.OrderType

export type OrderPriority = $Enums.OrderPriority

export const OrderPriority: typeof $Enums.OrderPriority

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type ClaimStatus = $Enums.ClaimStatus

export const ClaimStatus: typeof $Enums.ClaimStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffProfile`: Exposes CRUD operations for the **StaffProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffProfiles
    * const staffProfiles = await prisma.staffProfile.findMany()
    * ```
    */
  get staffProfile(): Prisma.StaffProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ward`: Exposes CRUD operations for the **Ward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wards
    * const wards = await prisma.ward.findMany()
    * ```
    */
  get ward(): Prisma.WardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bed`: Exposes CRUD operations for the **Bed** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Beds
    * const beds = await prisma.bed.findMany()
    * ```
    */
  get bed(): Prisma.BedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalHistory`: Exposes CRUD operations for the **MedicalHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalHistories
    * const medicalHistories = await prisma.medicalHistory.findMany()
    * ```
    */
  get medicalHistory(): Prisma.MedicalHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patientDocument`: Exposes CRUD operations for the **PatientDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientDocuments
    * const patientDocuments = await prisma.patientDocument.findMany()
    * ```
    */
  get patientDocument(): Prisma.PatientDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.opdVisit`: Exposes CRUD operations for the **OpdVisit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OpdVisits
    * const opdVisits = await prisma.opdVisit.findMany()
    * ```
    */
  get opdVisit(): Prisma.OpdVisitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admission`: Exposes CRUD operations for the **Admission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admissions
    * const admissions = await prisma.admission.findMany()
    * ```
    */
  get admission(): Prisma.AdmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bedTransfer`: Exposes CRUD operations for the **BedTransfer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BedTransfers
    * const bedTransfers = await prisma.bedTransfer.findMany()
    * ```
    */
  get bedTransfer(): Prisma.BedTransferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surgery`: Exposes CRUD operations for the **Surgery** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Surgeries
    * const surgeries = await prisma.surgery.findMany()
    * ```
    */
  get surgery(): Prisma.SurgeryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surgerySStaff`: Exposes CRUD operations for the **SurgerySStaff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurgerySStaffs
    * const surgerySStaffs = await prisma.surgerySStaff.findMany()
    * ```
    */
  get surgerySStaff(): Prisma.SurgerySStaffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.surgicalChecklist`: Exposes CRUD operations for the **SurgicalChecklist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SurgicalChecklists
    * const surgicalChecklists = await prisma.surgicalChecklist.findMany()
    * ```
    */
  get surgicalChecklist(): Prisma.SurgicalChecklistDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clinicalNote`: Exposes CRUD operations for the **ClinicalNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicalNotes
    * const clinicalNotes = await prisma.clinicalNote.findMany()
    * ```
    */
  get clinicalNote(): Prisma.ClinicalNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceOrder`: Exposes CRUD operations for the **ServiceOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceOrders
    * const serviceOrders = await prisma.serviceOrder.findMany()
    * ```
    */
  get serviceOrder(): Prisma.ServiceOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labResult`: Exposes CRUD operations for the **LabResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabResults
    * const labResults = await prisma.labResult.findMany()
    * ```
    */
  get labResult(): Prisma.LabResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.prescriptionItem`: Exposes CRUD operations for the **PrescriptionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrescriptionItems
    * const prescriptionItems = await prisma.prescriptionItem.findMany()
    * ```
    */
  get prescriptionItem(): Prisma.PrescriptionItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicine`: Exposes CRUD operations for the **Medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicines
    * const medicines = await prisma.medicine.findMany()
    * ```
    */
  get medicine(): Prisma.MedicineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pharmacySale`: Exposes CRUD operations for the **PharmacySale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PharmacySales
    * const pharmacySales = await prisma.pharmacySale.findMany()
    * ```
    */
  get pharmacySale(): Prisma.PharmacySaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.saleItem`: Exposes CRUD operations for the **SaleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaleItems
    * const saleItems = await prisma.saleItem.findMany()
    * ```
    */
  get saleItem(): Prisma.SaleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceItem`: Exposes CRUD operations for the **InvoiceItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceItems
    * const invoiceItems = await prisma.invoiceItem.findMany()
    * ```
    */
  get invoiceItem(): Prisma.InvoiceItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.insuranceClaim`: Exposes CRUD operations for the **InsuranceClaim** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsuranceClaims
    * const insuranceClaims = await prisma.insuranceClaim.findMany()
    * ```
    */
  get insuranceClaim(): Prisma.InsuranceClaimDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    StaffProfile: 'StaffProfile',
    Department: 'Department',
    Service: 'Service',
    Ward: 'Ward',
    Bed: 'Bed',
    Patient: 'Patient',
    MedicalHistory: 'MedicalHistory',
    PatientDocument: 'PatientDocument',
    Appointment: 'Appointment',
    OpdVisit: 'OpdVisit',
    Admission: 'Admission',
    BedTransfer: 'BedTransfer',
    Surgery: 'Surgery',
    SurgerySStaff: 'SurgerySStaff',
    SurgicalChecklist: 'SurgicalChecklist',
    ClinicalNote: 'ClinicalNote',
    ServiceOrder: 'ServiceOrder',
    LabResult: 'LabResult',
    Prescription: 'Prescription',
    PrescriptionItem: 'PrescriptionItem',
    Medicine: 'Medicine',
    PharmacySale: 'PharmacySale',
    SaleItem: 'SaleItem',
    Invoice: 'Invoice',
    InvoiceItem: 'InvoiceItem',
    InsuranceClaim: 'InsuranceClaim'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "staffProfile" | "department" | "service" | "ward" | "bed" | "patient" | "medicalHistory" | "patientDocument" | "appointment" | "opdVisit" | "admission" | "bedTransfer" | "surgery" | "surgerySStaff" | "surgicalChecklist" | "clinicalNote" | "serviceOrder" | "labResult" | "prescription" | "prescriptionItem" | "medicine" | "pharmacySale" | "saleItem" | "invoice" | "invoiceItem" | "insuranceClaim"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      StaffProfile: {
        payload: Prisma.$StaffProfilePayload<ExtArgs>
        fields: Prisma.StaffProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findFirst: {
            args: Prisma.StaffProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findMany: {
            args: Prisma.StaffProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          create: {
            args: Prisma.StaffProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          createMany: {
            args: Prisma.StaffProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          delete: {
            args: Prisma.StaffProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          update: {
            args: Prisma.StaffProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          deleteMany: {
            args: Prisma.StaffProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          upsert: {
            args: Prisma.StaffProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          aggregate: {
            args: Prisma.StaffProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffProfile>
          }
          groupBy: {
            args: Prisma.StaffProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Ward: {
        payload: Prisma.$WardPayload<ExtArgs>
        fields: Prisma.WardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findFirst: {
            args: Prisma.WardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          findMany: {
            args: Prisma.WardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          create: {
            args: Prisma.WardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          createMany: {
            args: Prisma.WardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          delete: {
            args: Prisma.WardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          update: {
            args: Prisma.WardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          deleteMany: {
            args: Prisma.WardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>[]
          }
          upsert: {
            args: Prisma.WardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WardPayload>
          }
          aggregate: {
            args: Prisma.WardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWard>
          }
          groupBy: {
            args: Prisma.WardGroupByArgs<ExtArgs>
            result: $Utils.Optional<WardGroupByOutputType>[]
          }
          count: {
            args: Prisma.WardCountArgs<ExtArgs>
            result: $Utils.Optional<WardCountAggregateOutputType> | number
          }
        }
      }
      Bed: {
        payload: Prisma.$BedPayload<ExtArgs>
        fields: Prisma.BedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findFirst: {
            args: Prisma.BedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          findMany: {
            args: Prisma.BedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          create: {
            args: Prisma.BedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          createMany: {
            args: Prisma.BedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          delete: {
            args: Prisma.BedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          update: {
            args: Prisma.BedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          deleteMany: {
            args: Prisma.BedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>[]
          }
          upsert: {
            args: Prisma.BedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedPayload>
          }
          aggregate: {
            args: Prisma.BedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBed>
          }
          groupBy: {
            args: Prisma.BedGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedCountArgs<ExtArgs>
            result: $Utils.Optional<BedCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      MedicalHistory: {
        payload: Prisma.$MedicalHistoryPayload<ExtArgs>
        fields: Prisma.MedicalHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          findFirst: {
            args: Prisma.MedicalHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          findMany: {
            args: Prisma.MedicalHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
          }
          create: {
            args: Prisma.MedicalHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          createMany: {
            args: Prisma.MedicalHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicalHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
          }
          delete: {
            args: Prisma.MedicalHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          update: {
            args: Prisma.MedicalHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          deleteMany: {
            args: Prisma.MedicalHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicalHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>[]
          }
          upsert: {
            args: Prisma.MedicalHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalHistoryPayload>
          }
          aggregate: {
            args: Prisma.MedicalHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalHistory>
          }
          groupBy: {
            args: Prisma.MedicalHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicalHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalHistoryCountAggregateOutputType> | number
          }
        }
      }
      PatientDocument: {
        payload: Prisma.$PatientDocumentPayload<ExtArgs>
        fields: Prisma.PatientDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          findFirst: {
            args: Prisma.PatientDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          findMany: {
            args: Prisma.PatientDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>[]
          }
          create: {
            args: Prisma.PatientDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          createMany: {
            args: Prisma.PatientDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>[]
          }
          delete: {
            args: Prisma.PatientDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          update: {
            args: Prisma.PatientDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PatientDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatientDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>[]
          }
          upsert: {
            args: Prisma.PatientDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientDocumentPayload>
          }
          aggregate: {
            args: Prisma.PatientDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientDocument>
          }
          groupBy: {
            args: Prisma.PatientDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PatientDocumentCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppointmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      OpdVisit: {
        payload: Prisma.$OpdVisitPayload<ExtArgs>
        fields: Prisma.OpdVisitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpdVisitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpdVisitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          findFirst: {
            args: Prisma.OpdVisitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpdVisitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          findMany: {
            args: Prisma.OpdVisitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>[]
          }
          create: {
            args: Prisma.OpdVisitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          createMany: {
            args: Prisma.OpdVisitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OpdVisitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>[]
          }
          delete: {
            args: Prisma.OpdVisitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          update: {
            args: Prisma.OpdVisitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          deleteMany: {
            args: Prisma.OpdVisitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpdVisitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OpdVisitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>[]
          }
          upsert: {
            args: Prisma.OpdVisitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpdVisitPayload>
          }
          aggregate: {
            args: Prisma.OpdVisitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOpdVisit>
          }
          groupBy: {
            args: Prisma.OpdVisitGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpdVisitGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpdVisitCountArgs<ExtArgs>
            result: $Utils.Optional<OpdVisitCountAggregateOutputType> | number
          }
        }
      }
      Admission: {
        payload: Prisma.$AdmissionPayload<ExtArgs>
        fields: Prisma.AdmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findFirst: {
            args: Prisma.AdmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          findMany: {
            args: Prisma.AdmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          create: {
            args: Prisma.AdmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          createMany: {
            args: Prisma.AdmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          delete: {
            args: Prisma.AdmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          update: {
            args: Prisma.AdmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          deleteMany: {
            args: Prisma.AdmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>[]
          }
          upsert: {
            args: Prisma.AdmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdmissionPayload>
          }
          aggregate: {
            args: Prisma.AdmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmission>
          }
          groupBy: {
            args: Prisma.AdmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdmissionCountArgs<ExtArgs>
            result: $Utils.Optional<AdmissionCountAggregateOutputType> | number
          }
        }
      }
      BedTransfer: {
        payload: Prisma.$BedTransferPayload<ExtArgs>
        fields: Prisma.BedTransferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BedTransferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BedTransferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          findFirst: {
            args: Prisma.BedTransferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BedTransferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          findMany: {
            args: Prisma.BedTransferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>[]
          }
          create: {
            args: Prisma.BedTransferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          createMany: {
            args: Prisma.BedTransferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BedTransferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>[]
          }
          delete: {
            args: Prisma.BedTransferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          update: {
            args: Prisma.BedTransferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          deleteMany: {
            args: Prisma.BedTransferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BedTransferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BedTransferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>[]
          }
          upsert: {
            args: Prisma.BedTransferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BedTransferPayload>
          }
          aggregate: {
            args: Prisma.BedTransferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBedTransfer>
          }
          groupBy: {
            args: Prisma.BedTransferGroupByArgs<ExtArgs>
            result: $Utils.Optional<BedTransferGroupByOutputType>[]
          }
          count: {
            args: Prisma.BedTransferCountArgs<ExtArgs>
            result: $Utils.Optional<BedTransferCountAggregateOutputType> | number
          }
        }
      }
      Surgery: {
        payload: Prisma.$SurgeryPayload<ExtArgs>
        fields: Prisma.SurgeryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurgeryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurgeryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          findFirst: {
            args: Prisma.SurgeryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurgeryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          findMany: {
            args: Prisma.SurgeryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          create: {
            args: Prisma.SurgeryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          createMany: {
            args: Prisma.SurgeryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurgeryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          delete: {
            args: Prisma.SurgeryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          update: {
            args: Prisma.SurgeryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          deleteMany: {
            args: Prisma.SurgeryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurgeryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurgeryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>[]
          }
          upsert: {
            args: Prisma.SurgeryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgeryPayload>
          }
          aggregate: {
            args: Prisma.SurgeryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurgery>
          }
          groupBy: {
            args: Prisma.SurgeryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurgeryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurgeryCountArgs<ExtArgs>
            result: $Utils.Optional<SurgeryCountAggregateOutputType> | number
          }
        }
      }
      SurgerySStaff: {
        payload: Prisma.$SurgerySStaffPayload<ExtArgs>
        fields: Prisma.SurgerySStaffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurgerySStaffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurgerySStaffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          findFirst: {
            args: Prisma.SurgerySStaffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurgerySStaffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          findMany: {
            args: Prisma.SurgerySStaffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>[]
          }
          create: {
            args: Prisma.SurgerySStaffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          createMany: {
            args: Prisma.SurgerySStaffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurgerySStaffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>[]
          }
          delete: {
            args: Prisma.SurgerySStaffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          update: {
            args: Prisma.SurgerySStaffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          deleteMany: {
            args: Prisma.SurgerySStaffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurgerySStaffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurgerySStaffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>[]
          }
          upsert: {
            args: Prisma.SurgerySStaffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgerySStaffPayload>
          }
          aggregate: {
            args: Prisma.SurgerySStaffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurgerySStaff>
          }
          groupBy: {
            args: Prisma.SurgerySStaffGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurgerySStaffGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurgerySStaffCountArgs<ExtArgs>
            result: $Utils.Optional<SurgerySStaffCountAggregateOutputType> | number
          }
        }
      }
      SurgicalChecklist: {
        payload: Prisma.$SurgicalChecklistPayload<ExtArgs>
        fields: Prisma.SurgicalChecklistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SurgicalChecklistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SurgicalChecklistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          findFirst: {
            args: Prisma.SurgicalChecklistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SurgicalChecklistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          findMany: {
            args: Prisma.SurgicalChecklistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>[]
          }
          create: {
            args: Prisma.SurgicalChecklistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          createMany: {
            args: Prisma.SurgicalChecklistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SurgicalChecklistCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>[]
          }
          delete: {
            args: Prisma.SurgicalChecklistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          update: {
            args: Prisma.SurgicalChecklistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          deleteMany: {
            args: Prisma.SurgicalChecklistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SurgicalChecklistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SurgicalChecklistUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>[]
          }
          upsert: {
            args: Prisma.SurgicalChecklistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SurgicalChecklistPayload>
          }
          aggregate: {
            args: Prisma.SurgicalChecklistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSurgicalChecklist>
          }
          groupBy: {
            args: Prisma.SurgicalChecklistGroupByArgs<ExtArgs>
            result: $Utils.Optional<SurgicalChecklistGroupByOutputType>[]
          }
          count: {
            args: Prisma.SurgicalChecklistCountArgs<ExtArgs>
            result: $Utils.Optional<SurgicalChecklistCountAggregateOutputType> | number
          }
        }
      }
      ClinicalNote: {
        payload: Prisma.$ClinicalNotePayload<ExtArgs>
        fields: Prisma.ClinicalNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicalNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findFirst: {
            args: Prisma.ClinicalNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicalNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          findMany: {
            args: Prisma.ClinicalNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          create: {
            args: Prisma.ClinicalNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          createMany: {
            args: Prisma.ClinicalNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicalNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          delete: {
            args: Prisma.ClinicalNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          update: {
            args: Prisma.ClinicalNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          deleteMany: {
            args: Prisma.ClinicalNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicalNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>[]
          }
          upsert: {
            args: Prisma.ClinicalNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicalNotePayload>
          }
          aggregate: {
            args: Prisma.ClinicalNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicalNote>
          }
          groupBy: {
            args: Prisma.ClinicalNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicalNoteCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicalNoteCountAggregateOutputType> | number
          }
        }
      }
      ServiceOrder: {
        payload: Prisma.$ServiceOrderPayload<ExtArgs>
        fields: Prisma.ServiceOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          findFirst: {
            args: Prisma.ServiceOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          findMany: {
            args: Prisma.ServiceOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          create: {
            args: Prisma.ServiceOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          createMany: {
            args: Prisma.ServiceOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          delete: {
            args: Prisma.ServiceOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          update: {
            args: Prisma.ServiceOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          deleteMany: {
            args: Prisma.ServiceOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>[]
          }
          upsert: {
            args: Prisma.ServiceOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOrderPayload>
          }
          aggregate: {
            args: Prisma.ServiceOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceOrder>
          }
          groupBy: {
            args: Prisma.ServiceOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceOrderCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceOrderCountAggregateOutputType> | number
          }
        }
      }
      LabResult: {
        payload: Prisma.$LabResultPayload<ExtArgs>
        fields: Prisma.LabResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findFirst: {
            args: Prisma.LabResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          findMany: {
            args: Prisma.LabResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          create: {
            args: Prisma.LabResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          createMany: {
            args: Prisma.LabResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          delete: {
            args: Prisma.LabResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          update: {
            args: Prisma.LabResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          deleteMany: {
            args: Prisma.LabResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>[]
          }
          upsert: {
            args: Prisma.LabResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabResultPayload>
          }
          aggregate: {
            args: Prisma.LabResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabResult>
          }
          groupBy: {
            args: Prisma.LabResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabResultCountArgs<ExtArgs>
            result: $Utils.Optional<LabResultCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      PrescriptionItem: {
        payload: Prisma.$PrescriptionItemPayload<ExtArgs>
        fields: Prisma.PrescriptionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          findMany: {
            args: Prisma.PrescriptionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          create: {
            args: Prisma.PrescriptionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          createMany: {
            args: Prisma.PrescriptionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          update: {
            args: Prisma.PrescriptionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>[]
          }
          upsert: {
            args: Prisma.PrescriptionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionItemPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescriptionItem>
          }
          groupBy: {
            args: Prisma.PrescriptionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionItemCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionItemCountAggregateOutputType> | number
          }
        }
      }
      Medicine: {
        payload: Prisma.$MedicinePayload<ExtArgs>
        fields: Prisma.MedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findFirst: {
            args: Prisma.MedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findMany: {
            args: Prisma.MedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          create: {
            args: Prisma.MedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          createMany: {
            args: Prisma.MedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          delete: {
            args: Prisma.MedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          update: {
            args: Prisma.MedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          deleteMany: {
            args: Prisma.MedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MedicineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          upsert: {
            args: Prisma.MedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          aggregate: {
            args: Prisma.MedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicine>
          }
          groupBy: {
            args: Prisma.MedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineCountAggregateOutputType> | number
          }
        }
      }
      PharmacySale: {
        payload: Prisma.$PharmacySalePayload<ExtArgs>
        fields: Prisma.PharmacySaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PharmacySaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PharmacySaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          findFirst: {
            args: Prisma.PharmacySaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PharmacySaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          findMany: {
            args: Prisma.PharmacySaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>[]
          }
          create: {
            args: Prisma.PharmacySaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          createMany: {
            args: Prisma.PharmacySaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PharmacySaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>[]
          }
          delete: {
            args: Prisma.PharmacySaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          update: {
            args: Prisma.PharmacySaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          deleteMany: {
            args: Prisma.PharmacySaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PharmacySaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PharmacySaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>[]
          }
          upsert: {
            args: Prisma.PharmacySaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PharmacySalePayload>
          }
          aggregate: {
            args: Prisma.PharmacySaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePharmacySale>
          }
          groupBy: {
            args: Prisma.PharmacySaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<PharmacySaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.PharmacySaleCountArgs<ExtArgs>
            result: $Utils.Optional<PharmacySaleCountAggregateOutputType> | number
          }
        }
      }
      SaleItem: {
        payload: Prisma.$SaleItemPayload<ExtArgs>
        fields: Prisma.SaleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findFirst: {
            args: Prisma.SaleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          findMany: {
            args: Prisma.SaleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          create: {
            args: Prisma.SaleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          createMany: {
            args: Prisma.SaleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          delete: {
            args: Prisma.SaleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          update: {
            args: Prisma.SaleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          deleteMany: {
            args: Prisma.SaleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>[]
          }
          upsert: {
            args: Prisma.SaleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SaleItemPayload>
          }
          aggregate: {
            args: Prisma.SaleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSaleItem>
          }
          groupBy: {
            args: Prisma.SaleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleItemCountArgs<ExtArgs>
            result: $Utils.Optional<SaleItemCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceItem: {
        payload: Prisma.$InvoiceItemPayload<ExtArgs>
        fields: Prisma.InvoiceItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findFirst: {
            args: Prisma.InvoiceItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          findMany: {
            args: Prisma.InvoiceItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          create: {
            args: Prisma.InvoiceItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          createMany: {
            args: Prisma.InvoiceItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          delete: {
            args: Prisma.InvoiceItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          update: {
            args: Prisma.InvoiceItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceItemPayload>
          }
          aggregate: {
            args: Prisma.InvoiceItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceItem>
          }
          groupBy: {
            args: Prisma.InvoiceItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceItemCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceItemCountAggregateOutputType> | number
          }
        }
      }
      InsuranceClaim: {
        payload: Prisma.$InsuranceClaimPayload<ExtArgs>
        fields: Prisma.InsuranceClaimFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsuranceClaimFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsuranceClaimFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          findFirst: {
            args: Prisma.InsuranceClaimFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsuranceClaimFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          findMany: {
            args: Prisma.InsuranceClaimFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          create: {
            args: Prisma.InsuranceClaimCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          createMany: {
            args: Prisma.InsuranceClaimCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsuranceClaimCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          delete: {
            args: Prisma.InsuranceClaimDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          update: {
            args: Prisma.InsuranceClaimUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          deleteMany: {
            args: Prisma.InsuranceClaimDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsuranceClaimUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InsuranceClaimUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>[]
          }
          upsert: {
            args: Prisma.InsuranceClaimUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsuranceClaimPayload>
          }
          aggregate: {
            args: Prisma.InsuranceClaimAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsuranceClaim>
          }
          groupBy: {
            args: Prisma.InsuranceClaimGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsuranceClaimGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsuranceClaimCountArgs<ExtArgs>
            result: $Utils.Optional<InsuranceClaimCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    staffProfile?: StaffProfileOmit
    department?: DepartmentOmit
    service?: ServiceOmit
    ward?: WardOmit
    bed?: BedOmit
    patient?: PatientOmit
    medicalHistory?: MedicalHistoryOmit
    patientDocument?: PatientDocumentOmit
    appointment?: AppointmentOmit
    opdVisit?: OpdVisitOmit
    admission?: AdmissionOmit
    bedTransfer?: BedTransferOmit
    surgery?: SurgeryOmit
    surgerySStaff?: SurgerySStaffOmit
    surgicalChecklist?: SurgicalChecklistOmit
    clinicalNote?: ClinicalNoteOmit
    serviceOrder?: ServiceOrderOmit
    labResult?: LabResultOmit
    prescription?: PrescriptionOmit
    prescriptionItem?: PrescriptionItemOmit
    medicine?: MedicineOmit
    pharmacySale?: PharmacySaleOmit
    saleItem?: SaleItemOmit
    invoice?: InvoiceOmit
    invoiceItem?: InvoiceItemOmit
    insuranceClaim?: InsuranceClaimOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    labResults: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labResults?: boolean | UserCountOutputTypeCountLabResultsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }


  /**
   * Count Type StaffProfileCountOutputType
   */

  export type StaffProfileCountOutputType = {
    headOfDepartments: number
    appointments: number
    opdVisits: number
    admissions: number
    surgeries: number
    clinicalNotes: number
    serviceOrders: number
    verifiedResults: number
    prescriptions: number
    surgerySStaffs: number
  }

  export type StaffProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    headOfDepartments?: boolean | StaffProfileCountOutputTypeCountHeadOfDepartmentsArgs
    appointments?: boolean | StaffProfileCountOutputTypeCountAppointmentsArgs
    opdVisits?: boolean | StaffProfileCountOutputTypeCountOpdVisitsArgs
    admissions?: boolean | StaffProfileCountOutputTypeCountAdmissionsArgs
    surgeries?: boolean | StaffProfileCountOutputTypeCountSurgeriesArgs
    clinicalNotes?: boolean | StaffProfileCountOutputTypeCountClinicalNotesArgs
    serviceOrders?: boolean | StaffProfileCountOutputTypeCountServiceOrdersArgs
    verifiedResults?: boolean | StaffProfileCountOutputTypeCountVerifiedResultsArgs
    prescriptions?: boolean | StaffProfileCountOutputTypeCountPrescriptionsArgs
    surgerySStaffs?: boolean | StaffProfileCountOutputTypeCountSurgerySStaffsArgs
  }

  // Custom InputTypes
  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfileCountOutputType
     */
    select?: StaffProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountHeadOfDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountOpdVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpdVisitWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountSurgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgeryWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountClinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountServiceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountVerifiedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountSurgerySStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgerySStaffWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    staff: number
    services: number
    wards: number
    appointments: number
    admissions: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | DepartmentCountOutputTypeCountStaffArgs
    services?: boolean | DepartmentCountOutputTypeCountServicesArgs
    wards?: boolean | DepartmentCountOutputTypeCountWardsArgs
    appointments?: boolean | DepartmentCountOutputTypeCountAppointmentsArgs
    admissions?: boolean | DepartmentCountOutputTypeCountAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffProfileWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountWardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    serviceOrders: number
    invoiceItems: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceOrders?: boolean | ServiceCountOutputTypeCountServiceOrdersArgs
    invoiceItems?: boolean | ServiceCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type WardCountOutputType
   */

  export type WardCountOutputType = {
    beds: number
  }

  export type WardCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beds?: boolean | WardCountOutputTypeCountBedsArgs
  }

  // Custom InputTypes
  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WardCountOutputType
     */
    select?: WardCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WardCountOutputType without action
   */
  export type WardCountOutputTypeCountBedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
  }


  /**
   * Count Type BedCountOutputType
   */

  export type BedCountOutputType = {
    transfers: number
    activeAdmissions: number
  }

  export type BedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transfers?: boolean | BedCountOutputTypeCountTransfersArgs
    activeAdmissions?: boolean | BedCountOutputTypeCountActiveAdmissionsArgs
  }

  // Custom InputTypes
  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedCountOutputType
     */
    select?: BedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeCountTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedTransferWhereInput
  }

  /**
   * BedCountOutputType without action
   */
  export type BedCountOutputTypeCountActiveAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    medicalHistory: number
    documents: number
    appointments: number
    opdVisits: number
    admissions: number
    clinicalNotes: number
    serviceOrders: number
    prescriptions: number
    pharmacySales: number
    invoices: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalHistory?: boolean | PatientCountOutputTypeCountMedicalHistoryArgs
    documents?: boolean | PatientCountOutputTypeCountDocumentsArgs
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    opdVisits?: boolean | PatientCountOutputTypeCountOpdVisitsArgs
    admissions?: boolean | PatientCountOutputTypeCountAdmissionsArgs
    clinicalNotes?: boolean | PatientCountOutputTypeCountClinicalNotesArgs
    serviceOrders?: boolean | PatientCountOutputTypeCountServiceOrdersArgs
    prescriptions?: boolean | PatientCountOutputTypeCountPrescriptionsArgs
    pharmacySales?: boolean | PatientCountOutputTypeCountPharmacySalesArgs
    invoices?: boolean | PatientCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalHistoryWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDocumentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountOpdVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpdVisitWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountClinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountServiceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountPharmacySalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacySaleWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type OpdVisitCountOutputType
   */

  export type OpdVisitCountOutputType = {
    clinicalNotes: number
    serviceOrders: number
    prescriptions: number
    documents: number
    invoices: number
  }

  export type OpdVisitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinicalNotes?: boolean | OpdVisitCountOutputTypeCountClinicalNotesArgs
    serviceOrders?: boolean | OpdVisitCountOutputTypeCountServiceOrdersArgs
    prescriptions?: boolean | OpdVisitCountOutputTypeCountPrescriptionsArgs
    documents?: boolean | OpdVisitCountOutputTypeCountDocumentsArgs
    invoices?: boolean | OpdVisitCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisitCountOutputType
     */
    select?: OpdVisitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeCountClinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeCountServiceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDocumentWhereInput
  }

  /**
   * OpdVisitCountOutputType without action
   */
  export type OpdVisitCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type AdmissionCountOutputType
   */

  export type AdmissionCountOutputType = {
    bedTransfers: number
    surgeries: number
    clinicalNotes: number
    serviceOrders: number
    prescriptions: number
    documents: number
    invoices: number
    insuranceClaims: number
  }

  export type AdmissionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bedTransfers?: boolean | AdmissionCountOutputTypeCountBedTransfersArgs
    surgeries?: boolean | AdmissionCountOutputTypeCountSurgeriesArgs
    clinicalNotes?: boolean | AdmissionCountOutputTypeCountClinicalNotesArgs
    serviceOrders?: boolean | AdmissionCountOutputTypeCountServiceOrdersArgs
    prescriptions?: boolean | AdmissionCountOutputTypeCountPrescriptionsArgs
    documents?: boolean | AdmissionCountOutputTypeCountDocumentsArgs
    invoices?: boolean | AdmissionCountOutputTypeCountInvoicesArgs
    insuranceClaims?: boolean | AdmissionCountOutputTypeCountInsuranceClaimsArgs
  }

  // Custom InputTypes
  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdmissionCountOutputType
     */
    select?: AdmissionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountBedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedTransferWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountSurgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgeryWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountClinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountServiceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountPrescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDocumentWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * AdmissionCountOutputType without action
   */
  export type AdmissionCountOutputTypeCountInsuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceClaimWhereInput
  }


  /**
   * Count Type SurgeryCountOutputType
   */

  export type SurgeryCountOutputType = {
    checklists: number
    surgerySStaffs: number
  }

  export type SurgeryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklists?: boolean | SurgeryCountOutputTypeCountChecklistsArgs
    surgerySStaffs?: boolean | SurgeryCountOutputTypeCountSurgerySStaffsArgs
  }

  // Custom InputTypes
  /**
   * SurgeryCountOutputType without action
   */
  export type SurgeryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgeryCountOutputType
     */
    select?: SurgeryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SurgeryCountOutputType without action
   */
  export type SurgeryCountOutputTypeCountChecklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgicalChecklistWhereInput
  }

  /**
   * SurgeryCountOutputType without action
   */
  export type SurgeryCountOutputTypeCountSurgerySStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgerySStaffWhereInput
  }


  /**
   * Count Type ServiceOrderCountOutputType
   */

  export type ServiceOrderCountOutputType = {
    labResults: number
    invoiceItems: number
  }

  export type ServiceOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    labResults?: boolean | ServiceOrderCountOutputTypeCountLabResultsArgs
    invoiceItems?: boolean | ServiceOrderCountOutputTypeCountInvoiceItemsArgs
  }

  // Custom InputTypes
  /**
   * ServiceOrderCountOutputType without action
   */
  export type ServiceOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrderCountOutputType
     */
    select?: ServiceOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceOrderCountOutputType without action
   */
  export type ServiceOrderCountOutputTypeCountLabResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
  }

  /**
   * ServiceOrderCountOutputType without action
   */
  export type ServiceOrderCountOutputTypeCountInvoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    items: number
    sales: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PrescriptionCountOutputTypeCountItemsArgs
    sales?: boolean | PrescriptionCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacySaleWhereInput
  }


  /**
   * Count Type MedicineCountOutputType
   */

  export type MedicineCountOutputType = {
    prescriptionItems: number
    saleItems: number
  }

  export type MedicineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | MedicineCountOutputTypeCountPrescriptionItemsArgs
    saleItems?: boolean | MedicineCountOutputTypeCountSaleItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineCountOutputType
     */
    select?: MedicineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountPrescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountSaleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }


  /**
   * Count Type PharmacySaleCountOutputType
   */

  export type PharmacySaleCountOutputType = {
    items: number
  }

  export type PharmacySaleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PharmacySaleCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PharmacySaleCountOutputType without action
   */
  export type PharmacySaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySaleCountOutputType
     */
    select?: PharmacySaleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PharmacySaleCountOutputType without action
   */
  export type PharmacySaleCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    items: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | InvoiceCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    role: number
    isActive: number
    lastLogin: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    role?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
    labResults?: boolean | User$labResultsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "role" | "isActive" | "lastLogin" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
    labResults?: boolean | User$labResultsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      staffProfile: Prisma.$StaffProfilePayload<ExtArgs> | null
      labResults: Prisma.$LabResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      role: $Enums.UserRole
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staffProfile<T extends User$staffProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$staffProfileArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    labResults<T extends User$labResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$labResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.staffProfile
   */
  export type User$staffProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * User.labResults
   */
  export type User$labResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model StaffProfile
   */

  export type AggregateStaffProfile = {
    _count: StaffProfileCountAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  export type StaffProfileMinAggregateOutputType = {
    id: string | null
    departmentId: string | null
    fullName: string | null
    qualification: string | null
    registrationNumber: string | null
    contactNumber: string | null
    shiftTiming: string | null
  }

  export type StaffProfileMaxAggregateOutputType = {
    id: string | null
    departmentId: string | null
    fullName: string | null
    qualification: string | null
    registrationNumber: string | null
    contactNumber: string | null
    shiftTiming: string | null
  }

  export type StaffProfileCountAggregateOutputType = {
    id: number
    departmentId: number
    fullName: number
    qualification: number
    registrationNumber: number
    contactNumber: number
    shiftTiming: number
    _all: number
  }


  export type StaffProfileMinAggregateInputType = {
    id?: true
    departmentId?: true
    fullName?: true
    qualification?: true
    registrationNumber?: true
    contactNumber?: true
    shiftTiming?: true
  }

  export type StaffProfileMaxAggregateInputType = {
    id?: true
    departmentId?: true
    fullName?: true
    qualification?: true
    registrationNumber?: true
    contactNumber?: true
    shiftTiming?: true
  }

  export type StaffProfileCountAggregateInputType = {
    id?: true
    departmentId?: true
    fullName?: true
    qualification?: true
    registrationNumber?: true
    contactNumber?: true
    shiftTiming?: true
    _all?: true
  }

  export type StaffProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfile to aggregate.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffProfiles
    **/
    _count?: true | StaffProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffProfileMaxAggregateInputType
  }

  export type GetStaffProfileAggregateType<T extends StaffProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffProfile[P]>
      : GetScalarType<T[P], AggregateStaffProfile[P]>
  }




  export type StaffProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffProfileWhereInput
    orderBy?: StaffProfileOrderByWithAggregationInput | StaffProfileOrderByWithAggregationInput[]
    by: StaffProfileScalarFieldEnum[] | StaffProfileScalarFieldEnum
    having?: StaffProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffProfileCountAggregateInputType | true
    _min?: StaffProfileMinAggregateInputType
    _max?: StaffProfileMaxAggregateInputType
  }

  export type StaffProfileGroupByOutputType = {
    id: string
    departmentId: string | null
    fullName: string
    qualification: string | null
    registrationNumber: string | null
    contactNumber: string | null
    shiftTiming: string | null
    _count: StaffProfileCountAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  type GetStaffProfileGroupByPayload<T extends StaffProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
        }
      >
    >


  export type StaffProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    fullName?: boolean
    qualification?: boolean
    registrationNumber?: boolean
    contactNumber?: boolean
    shiftTiming?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
    headOfDepartments?: boolean | StaffProfile$headOfDepartmentsArgs<ExtArgs>
    appointments?: boolean | StaffProfile$appointmentsArgs<ExtArgs>
    opdVisits?: boolean | StaffProfile$opdVisitsArgs<ExtArgs>
    admissions?: boolean | StaffProfile$admissionsArgs<ExtArgs>
    surgeries?: boolean | StaffProfile$surgeriesArgs<ExtArgs>
    clinicalNotes?: boolean | StaffProfile$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | StaffProfile$serviceOrdersArgs<ExtArgs>
    verifiedResults?: boolean | StaffProfile$verifiedResultsArgs<ExtArgs>
    prescriptions?: boolean | StaffProfile$prescriptionsArgs<ExtArgs>
    surgerySStaffs?: boolean | StaffProfile$surgerySStaffsArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    fullName?: boolean
    qualification?: boolean
    registrationNumber?: boolean
    contactNumber?: boolean
    shiftTiming?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departmentId?: boolean
    fullName?: boolean
    qualification?: boolean
    registrationNumber?: boolean
    contactNumber?: boolean
    shiftTiming?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectScalar = {
    id?: boolean
    departmentId?: boolean
    fullName?: boolean
    qualification?: boolean
    registrationNumber?: boolean
    contactNumber?: boolean
    shiftTiming?: boolean
  }

  export type StaffProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "departmentId" | "fullName" | "qualification" | "registrationNumber" | "contactNumber" | "shiftTiming", ExtArgs["result"]["staffProfile"]>
  export type StaffProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
    headOfDepartments?: boolean | StaffProfile$headOfDepartmentsArgs<ExtArgs>
    appointments?: boolean | StaffProfile$appointmentsArgs<ExtArgs>
    opdVisits?: boolean | StaffProfile$opdVisitsArgs<ExtArgs>
    admissions?: boolean | StaffProfile$admissionsArgs<ExtArgs>
    surgeries?: boolean | StaffProfile$surgeriesArgs<ExtArgs>
    clinicalNotes?: boolean | StaffProfile$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | StaffProfile$serviceOrdersArgs<ExtArgs>
    verifiedResults?: boolean | StaffProfile$verifiedResultsArgs<ExtArgs>
    prescriptions?: boolean | StaffProfile$prescriptionsArgs<ExtArgs>
    surgerySStaffs?: boolean | StaffProfile$surgerySStaffsArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
  }
  export type StaffProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    department?: boolean | StaffProfile$departmentArgs<ExtArgs>
  }

  export type $StaffProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      headOfDepartments: Prisma.$DepartmentPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      opdVisits: Prisma.$OpdVisitPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
      surgeries: Prisma.$SurgeryPayload<ExtArgs>[]
      clinicalNotes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      serviceOrders: Prisma.$ServiceOrderPayload<ExtArgs>[]
      verifiedResults: Prisma.$LabResultPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      surgerySStaffs: Prisma.$SurgerySStaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      departmentId: string | null
      fullName: string
      qualification: string | null
      registrationNumber: string | null
      contactNumber: string | null
      shiftTiming: string | null
    }, ExtArgs["result"]["staffProfile"]>
    composites: {}
  }

  type StaffProfileGetPayload<S extends boolean | null | undefined | StaffProfileDefaultArgs> = $Result.GetResult<Prisma.$StaffProfilePayload, S>

  type StaffProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffProfileCountAggregateInputType | true
    }

  export interface StaffProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffProfile'], meta: { name: 'StaffProfile' } }
    /**
     * Find zero or one StaffProfile that matches the filter.
     * @param {StaffProfileFindUniqueArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffProfileFindUniqueArgs>(args: SelectSubset<T, StaffProfileFindUniqueArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffProfileFindUniqueOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffProfileFindFirstArgs>(args?: SelectSubset<T, StaffProfileFindFirstArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany()
     * 
     * // Get first 10 StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffProfileFindManyArgs>(args?: SelectSubset<T, StaffProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffProfile.
     * @param {StaffProfileCreateArgs} args - Arguments to create a StaffProfile.
     * @example
     * // Create one StaffProfile
     * const StaffProfile = await prisma.staffProfile.create({
     *   data: {
     *     // ... data to create a StaffProfile
     *   }
     * })
     * 
     */
    create<T extends StaffProfileCreateArgs>(args: SelectSubset<T, StaffProfileCreateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffProfiles.
     * @param {StaffProfileCreateManyArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffProfileCreateManyArgs>(args?: SelectSubset<T, StaffProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffProfiles and returns the data saved in the database.
     * @param {StaffProfileCreateManyAndReturnArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffProfile.
     * @param {StaffProfileDeleteArgs} args - Arguments to delete one StaffProfile.
     * @example
     * // Delete one StaffProfile
     * const StaffProfile = await prisma.staffProfile.delete({
     *   where: {
     *     // ... filter to delete one StaffProfile
     *   }
     * })
     * 
     */
    delete<T extends StaffProfileDeleteArgs>(args: SelectSubset<T, StaffProfileDeleteArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffProfile.
     * @param {StaffProfileUpdateArgs} args - Arguments to update one StaffProfile.
     * @example
     * // Update one StaffProfile
     * const staffProfile = await prisma.staffProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffProfileUpdateArgs>(args: SelectSubset<T, StaffProfileUpdateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffProfiles.
     * @param {StaffProfileDeleteManyArgs} args - Arguments to filter StaffProfiles to delete.
     * @example
     * // Delete a few StaffProfiles
     * const { count } = await prisma.staffProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffProfileDeleteManyArgs>(args?: SelectSubset<T, StaffProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffProfileUpdateManyArgs>(args: SelectSubset<T, StaffProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles and returns the data updated in the database.
     * @param {StaffProfileUpdateManyAndReturnArgs} args - Arguments to update many StaffProfiles.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffProfile.
     * @param {StaffProfileUpsertArgs} args - Arguments to update or create a StaffProfile.
     * @example
     * // Update or create a StaffProfile
     * const staffProfile = await prisma.staffProfile.upsert({
     *   create: {
     *     // ... data to create a StaffProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffProfile we want to update
     *   }
     * })
     */
    upsert<T extends StaffProfileUpsertArgs>(args: SelectSubset<T, StaffProfileUpsertArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileCountArgs} args - Arguments to filter StaffProfiles to count.
     * @example
     * // Count the number of StaffProfiles
     * const count = await prisma.staffProfile.count({
     *   where: {
     *     // ... the filter for the StaffProfiles we want to count
     *   }
     * })
    **/
    count<T extends StaffProfileCountArgs>(
      args?: Subset<T, StaffProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffProfileAggregateArgs>(args: Subset<T, StaffProfileAggregateArgs>): Prisma.PrismaPromise<GetStaffProfileAggregateType<T>>

    /**
     * Group by StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffProfileGroupByArgs['orderBy'] }
        : { orderBy?: StaffProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffProfile model
   */
  readonly fields: StaffProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends StaffProfile$departmentArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    headOfDepartments<T extends StaffProfile$headOfDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$headOfDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends StaffProfile$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opdVisits<T extends StaffProfile$opdVisitsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$opdVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admissions<T extends StaffProfile$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surgeries<T extends StaffProfile$surgeriesArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$surgeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicalNotes<T extends StaffProfile$clinicalNotesArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$clinicalNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrders<T extends StaffProfile$serviceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$serviceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    verifiedResults<T extends StaffProfile$verifiedResultsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$verifiedResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends StaffProfile$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surgerySStaffs<T extends StaffProfile$surgerySStaffsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$surgerySStaffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffProfile model
   */
  interface StaffProfileFieldRefs {
    readonly id: FieldRef<"StaffProfile", 'String'>
    readonly departmentId: FieldRef<"StaffProfile", 'String'>
    readonly fullName: FieldRef<"StaffProfile", 'String'>
    readonly qualification: FieldRef<"StaffProfile", 'String'>
    readonly registrationNumber: FieldRef<"StaffProfile", 'String'>
    readonly contactNumber: FieldRef<"StaffProfile", 'String'>
    readonly shiftTiming: FieldRef<"StaffProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StaffProfile findUnique
   */
  export type StaffProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findUniqueOrThrow
   */
  export type StaffProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findFirst
   */
  export type StaffProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findFirstOrThrow
   */
  export type StaffProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findMany
   */
  export type StaffProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfiles to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile create
   */
  export type StaffProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffProfile.
     */
    data: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
  }

  /**
   * StaffProfile createMany
   */
  export type StaffProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffProfile createManyAndReturn
   */
  export type StaffProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile update
   */
  export type StaffProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffProfile.
     */
    data: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
    /**
     * Choose, which StaffProfile to update.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile updateMany
   */
  export type StaffProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
  }

  /**
   * StaffProfile updateManyAndReturn
   */
  export type StaffProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile upsert
   */
  export type StaffProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffProfile to update in case it exists.
     */
    where: StaffProfileWhereUniqueInput
    /**
     * In case the StaffProfile found by the `where` argument doesn't exist, create a new StaffProfile with this data.
     */
    create: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
    /**
     * In case the StaffProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
  }

  /**
   * StaffProfile delete
   */
  export type StaffProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter which StaffProfile to delete.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile deleteMany
   */
  export type StaffProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfiles to delete
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to delete.
     */
    limit?: number
  }

  /**
   * StaffProfile.department
   */
  export type StaffProfile$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * StaffProfile.headOfDepartments
   */
  export type StaffProfile$headOfDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * StaffProfile.appointments
   */
  export type StaffProfile$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * StaffProfile.opdVisits
   */
  export type StaffProfile$opdVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    cursor?: OpdVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpdVisitScalarFieldEnum | OpdVisitScalarFieldEnum[]
  }

  /**
   * StaffProfile.admissions
   */
  export type StaffProfile$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * StaffProfile.surgeries
   */
  export type StaffProfile$surgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    where?: SurgeryWhereInput
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    cursor?: SurgeryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * StaffProfile.clinicalNotes
   */
  export type StaffProfile$clinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * StaffProfile.serviceOrders
   */
  export type StaffProfile$serviceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * StaffProfile.verifiedResults
   */
  export type StaffProfile$verifiedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * StaffProfile.prescriptions
   */
  export type StaffProfile$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * StaffProfile.surgerySStaffs
   */
  export type StaffProfile$surgerySStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    where?: SurgerySStaffWhereInput
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    cursor?: SurgerySStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgerySStaffScalarFieldEnum | SurgerySStaffScalarFieldEnum[]
  }

  /**
   * StaffProfile without action
   */
  export type StaffProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    headDoctorId: string | null
    type: $Enums.DepartmentType | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    headDoctorId: string | null
    type: $Enums.DepartmentType | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    code: number
    headDoctorId: number
    type: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    headDoctorId?: true
    type?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    headDoctorId?: true
    type?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    headDoctorId?: true
    type?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    code: string
    headDoctorId: string | null
    type: $Enums.DepartmentType
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    headDoctorId?: boolean
    type?: boolean
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    wards?: boolean | Department$wardsArgs<ExtArgs>
    appointments?: boolean | Department$appointmentsArgs<ExtArgs>
    admissions?: boolean | Department$admissionsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    headDoctorId?: boolean
    type?: boolean
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    headDoctorId?: boolean
    type?: boolean
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    headDoctorId?: boolean
    type?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "code" | "headDoctorId" | "type", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
    staff?: boolean | Department$staffArgs<ExtArgs>
    services?: boolean | Department$servicesArgs<ExtArgs>
    wards?: boolean | Department$wardsArgs<ExtArgs>
    appointments?: boolean | Department$appointmentsArgs<ExtArgs>
    admissions?: boolean | Department$admissionsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    headDoctor?: boolean | Department$headDoctorArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      headDoctor: Prisma.$StaffProfilePayload<ExtArgs> | null
      staff: Prisma.$StaffProfilePayload<ExtArgs>[]
      services: Prisma.$ServicePayload<ExtArgs>[]
      wards: Prisma.$WardPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string
      headDoctorId: string | null
      type: $Enums.DepartmentType
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    headDoctor<T extends Department$headDoctorArgs<ExtArgs> = {}>(args?: Subset<T, Department$headDoctorArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staff<T extends Department$staffArgs<ExtArgs> = {}>(args?: Subset<T, Department$staffArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    services<T extends Department$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Department$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wards<T extends Department$wardsArgs<ExtArgs> = {}>(args?: Subset<T, Department$wardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Department$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Department$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admissions<T extends Department$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Department$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly headDoctorId: FieldRef<"Department", 'String'>
    readonly type: FieldRef<"Department", 'DepartmentType'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.headDoctor
   */
  export type Department$headDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * Department.staff
   */
  export type Department$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    cursor?: StaffProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * Department.services
   */
  export type Department$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Department.wards
   */
  export type Department$wardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    where?: WardWhereInput
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    cursor?: WardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Department.appointments
   */
  export type Department$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Department.admissions
   */
  export type Department$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type ServiceSumAggregateOutputType = {
    basePrice: Decimal | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    departmentId: string | null
    basePrice: Decimal | null
    code: string | null
    isActive: boolean | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: $Enums.ServiceCategory | null
    departmentId: string | null
    basePrice: Decimal | null
    code: string | null
    isActive: boolean | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    category: number
    departmentId: number
    basePrice: number
    code: number
    isActive: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    basePrice?: true
  }

  export type ServiceSumAggregateInputType = {
    basePrice?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    basePrice?: true
    code?: true
    isActive?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    basePrice?: true
    code?: true
    isActive?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    departmentId?: true
    basePrice?: true
    code?: true
    isActive?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    name: string
    category: $Enums.ServiceCategory
    departmentId: string
    basePrice: Decimal
    code: string | null
    isActive: boolean
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    basePrice?: boolean
    code?: boolean
    isActive?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    serviceOrders?: boolean | Service$serviceOrdersArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    basePrice?: boolean
    code?: boolean
    isActive?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    basePrice?: boolean
    code?: boolean
    isActive?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    departmentId?: boolean
    basePrice?: boolean
    code?: boolean
    isActive?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category" | "departmentId" | "basePrice" | "code" | "isActive", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    serviceOrders?: boolean | Service$serviceOrdersArgs<ExtArgs>
    invoiceItems?: boolean | Service$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      serviceOrders: Prisma.$ServiceOrderPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: $Enums.ServiceCategory
      departmentId: string
      basePrice: Prisma.Decimal
      code: string | null
      isActive: boolean
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceOrders<T extends Service$serviceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceItems<T extends Service$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, Service$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly name: FieldRef<"Service", 'String'>
    readonly category: FieldRef<"Service", 'ServiceCategory'>
    readonly departmentId: FieldRef<"Service", 'String'>
    readonly basePrice: FieldRef<"Service", 'Decimal'>
    readonly code: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.serviceOrders
   */
  export type Service$serviceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * Service.invoiceItems
   */
  export type Service$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Ward
   */

  export type AggregateWard = {
    _count: WardCountAggregateOutputType | null
    _avg: WardAvgAggregateOutputType | null
    _sum: WardSumAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  export type WardAvgAggregateOutputType = {
    floorNumber: number | null
    basePricePerDay: Decimal | null
  }

  export type WardSumAggregateOutputType = {
    floorNumber: number | null
    basePricePerDay: Decimal | null
  }

  export type WardMinAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    floorNumber: number | null
    type: string | null
    basePricePerDay: Decimal | null
  }

  export type WardMaxAggregateOutputType = {
    id: string | null
    name: string | null
    departmentId: string | null
    floorNumber: number | null
    type: string | null
    basePricePerDay: Decimal | null
  }

  export type WardCountAggregateOutputType = {
    id: number
    name: number
    departmentId: number
    floorNumber: number
    type: number
    basePricePerDay: number
    _all: number
  }


  export type WardAvgAggregateInputType = {
    floorNumber?: true
    basePricePerDay?: true
  }

  export type WardSumAggregateInputType = {
    floorNumber?: true
    basePricePerDay?: true
  }

  export type WardMinAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    floorNumber?: true
    type?: true
    basePricePerDay?: true
  }

  export type WardMaxAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    floorNumber?: true
    type?: true
    basePricePerDay?: true
  }

  export type WardCountAggregateInputType = {
    id?: true
    name?: true
    departmentId?: true
    floorNumber?: true
    type?: true
    basePricePerDay?: true
    _all?: true
  }

  export type WardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ward to aggregate.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wards
    **/
    _count?: true | WardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WardMaxAggregateInputType
  }

  export type GetWardAggregateType<T extends WardAggregateArgs> = {
        [P in keyof T & keyof AggregateWard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWard[P]>
      : GetScalarType<T[P], AggregateWard[P]>
  }




  export type WardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WardWhereInput
    orderBy?: WardOrderByWithAggregationInput | WardOrderByWithAggregationInput[]
    by: WardScalarFieldEnum[] | WardScalarFieldEnum
    having?: WardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WardCountAggregateInputType | true
    _avg?: WardAvgAggregateInputType
    _sum?: WardSumAggregateInputType
    _min?: WardMinAggregateInputType
    _max?: WardMaxAggregateInputType
  }

  export type WardGroupByOutputType = {
    id: string
    name: string
    departmentId: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal
    _count: WardCountAggregateOutputType | null
    _avg: WardAvgAggregateOutputType | null
    _sum: WardSumAggregateOutputType | null
    _min: WardMinAggregateOutputType | null
    _max: WardMaxAggregateOutputType | null
  }

  type GetWardGroupByPayload<T extends WardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WardGroupByOutputType[P]>
            : GetScalarType<T[P], WardGroupByOutputType[P]>
        }
      >
    >


  export type WardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    floorNumber?: boolean
    type?: boolean
    basePricePerDay?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    floorNumber?: boolean
    type?: boolean
    basePricePerDay?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    departmentId?: boolean
    floorNumber?: boolean
    type?: boolean
    basePricePerDay?: boolean
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ward"]>

  export type WardSelectScalar = {
    id?: boolean
    name?: boolean
    departmentId?: boolean
    floorNumber?: boolean
    type?: boolean
    basePricePerDay?: boolean
  }

  export type WardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "departmentId" | "floorNumber" | "type" | "basePricePerDay", ExtArgs["result"]["ward"]>
  export type WardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    beds?: boolean | Ward$bedsArgs<ExtArgs>
    _count?: boolean | WardCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type WardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $WardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ward"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs>
      beds: Prisma.$BedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      departmentId: string
      floorNumber: number
      type: string
      basePricePerDay: Prisma.Decimal
    }, ExtArgs["result"]["ward"]>
    composites: {}
  }

  type WardGetPayload<S extends boolean | null | undefined | WardDefaultArgs> = $Result.GetResult<Prisma.$WardPayload, S>

  type WardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WardCountAggregateInputType | true
    }

  export interface WardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ward'], meta: { name: 'Ward' } }
    /**
     * Find zero or one Ward that matches the filter.
     * @param {WardFindUniqueArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WardFindUniqueArgs>(args: SelectSubset<T, WardFindUniqueArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WardFindUniqueOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WardFindUniqueOrThrowArgs>(args: SelectSubset<T, WardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WardFindFirstArgs>(args?: SelectSubset<T, WardFindFirstArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindFirstOrThrowArgs} args - Arguments to find a Ward
     * @example
     * // Get one Ward
     * const ward = await prisma.ward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WardFindFirstOrThrowArgs>(args?: SelectSubset<T, WardFindFirstOrThrowArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wards
     * const wards = await prisma.ward.findMany()
     * 
     * // Get first 10 Wards
     * const wards = await prisma.ward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const wardWithIdOnly = await prisma.ward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WardFindManyArgs>(args?: SelectSubset<T, WardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ward.
     * @param {WardCreateArgs} args - Arguments to create a Ward.
     * @example
     * // Create one Ward
     * const Ward = await prisma.ward.create({
     *   data: {
     *     // ... data to create a Ward
     *   }
     * })
     * 
     */
    create<T extends WardCreateArgs>(args: SelectSubset<T, WardCreateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wards.
     * @param {WardCreateManyArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WardCreateManyArgs>(args?: SelectSubset<T, WardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wards and returns the data saved in the database.
     * @param {WardCreateManyAndReturnArgs} args - Arguments to create many Wards.
     * @example
     * // Create many Wards
     * const ward = await prisma.ward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WardCreateManyAndReturnArgs>(args?: SelectSubset<T, WardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ward.
     * @param {WardDeleteArgs} args - Arguments to delete one Ward.
     * @example
     * // Delete one Ward
     * const Ward = await prisma.ward.delete({
     *   where: {
     *     // ... filter to delete one Ward
     *   }
     * })
     * 
     */
    delete<T extends WardDeleteArgs>(args: SelectSubset<T, WardDeleteArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ward.
     * @param {WardUpdateArgs} args - Arguments to update one Ward.
     * @example
     * // Update one Ward
     * const ward = await prisma.ward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WardUpdateArgs>(args: SelectSubset<T, WardUpdateArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wards.
     * @param {WardDeleteManyArgs} args - Arguments to filter Wards to delete.
     * @example
     * // Delete a few Wards
     * const { count } = await prisma.ward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WardDeleteManyArgs>(args?: SelectSubset<T, WardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WardUpdateManyArgs>(args: SelectSubset<T, WardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wards and returns the data updated in the database.
     * @param {WardUpdateManyAndReturnArgs} args - Arguments to update many Wards.
     * @example
     * // Update many Wards
     * const ward = await prisma.ward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Wards and only return the `id`
     * const wardWithIdOnly = await prisma.ward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WardUpdateManyAndReturnArgs>(args: SelectSubset<T, WardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ward.
     * @param {WardUpsertArgs} args - Arguments to update or create a Ward.
     * @example
     * // Update or create a Ward
     * const ward = await prisma.ward.upsert({
     *   create: {
     *     // ... data to create a Ward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ward we want to update
     *   }
     * })
     */
    upsert<T extends WardUpsertArgs>(args: SelectSubset<T, WardUpsertArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardCountArgs} args - Arguments to filter Wards to count.
     * @example
     * // Count the number of Wards
     * const count = await prisma.ward.count({
     *   where: {
     *     // ... the filter for the Wards we want to count
     *   }
     * })
    **/
    count<T extends WardCountArgs>(
      args?: Subset<T, WardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WardAggregateArgs>(args: Subset<T, WardAggregateArgs>): Prisma.PrismaPromise<GetWardAggregateType<T>>

    /**
     * Group by Ward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WardGroupByArgs['orderBy'] }
        : { orderBy?: WardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ward model
   */
  readonly fields: WardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    beds<T extends Ward$bedsArgs<ExtArgs> = {}>(args?: Subset<T, Ward$bedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ward model
   */
  interface WardFieldRefs {
    readonly id: FieldRef<"Ward", 'String'>
    readonly name: FieldRef<"Ward", 'String'>
    readonly departmentId: FieldRef<"Ward", 'String'>
    readonly floorNumber: FieldRef<"Ward", 'Int'>
    readonly type: FieldRef<"Ward", 'String'>
    readonly basePricePerDay: FieldRef<"Ward", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Ward findUnique
   */
  export type WardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findUniqueOrThrow
   */
  export type WardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward findFirst
   */
  export type WardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findFirstOrThrow
   */
  export type WardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Ward to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wards.
     */
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward findMany
   */
  export type WardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter, which Wards to fetch.
     */
    where?: WardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wards to fetch.
     */
    orderBy?: WardOrderByWithRelationInput | WardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wards.
     */
    cursor?: WardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wards.
     */
    skip?: number
    distinct?: WardScalarFieldEnum | WardScalarFieldEnum[]
  }

  /**
   * Ward create
   */
  export type WardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to create a Ward.
     */
    data: XOR<WardCreateInput, WardUncheckedCreateInput>
  }

  /**
   * Ward createMany
   */
  export type WardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ward createManyAndReturn
   */
  export type WardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * The data used to create many Wards.
     */
    data: WardCreateManyInput | WardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ward update
   */
  export type WardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The data needed to update a Ward.
     */
    data: XOR<WardUpdateInput, WardUncheckedUpdateInput>
    /**
     * Choose, which Ward to update.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward updateMany
   */
  export type WardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to update.
     */
    limit?: number
  }

  /**
   * Ward updateManyAndReturn
   */
  export type WardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * The data used to update Wards.
     */
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyInput>
    /**
     * Filter which Wards to update
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ward upsert
   */
  export type WardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * The filter to search for the Ward to update in case it exists.
     */
    where: WardWhereUniqueInput
    /**
     * In case the Ward found by the `where` argument doesn't exist, create a new Ward with this data.
     */
    create: XOR<WardCreateInput, WardUncheckedCreateInput>
    /**
     * In case the Ward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WardUpdateInput, WardUncheckedUpdateInput>
  }

  /**
   * Ward delete
   */
  export type WardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
    /**
     * Filter which Ward to delete.
     */
    where: WardWhereUniqueInput
  }

  /**
   * Ward deleteMany
   */
  export type WardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wards to delete
     */
    where?: WardWhereInput
    /**
     * Limit how many Wards to delete.
     */
    limit?: number
  }

  /**
   * Ward.beds
   */
  export type Ward$bedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    cursor?: BedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Ward without action
   */
  export type WardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ward
     */
    select?: WardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ward
     */
    omit?: WardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WardInclude<ExtArgs> | null
  }


  /**
   * Model Bed
   */

  export type AggregateBed = {
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  export type BedMinAggregateOutputType = {
    id: string | null
    wardId: string | null
    bedNumber: string | null
    status: $Enums.BedStatus | null
  }

  export type BedMaxAggregateOutputType = {
    id: string | null
    wardId: string | null
    bedNumber: string | null
    status: $Enums.BedStatus | null
  }

  export type BedCountAggregateOutputType = {
    id: number
    wardId: number
    bedNumber: number
    status: number
    _all: number
  }


  export type BedMinAggregateInputType = {
    id?: true
    wardId?: true
    bedNumber?: true
    status?: true
  }

  export type BedMaxAggregateInputType = {
    id?: true
    wardId?: true
    bedNumber?: true
    status?: true
  }

  export type BedCountAggregateInputType = {
    id?: true
    wardId?: true
    bedNumber?: true
    status?: true
    _all?: true
  }

  export type BedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bed to aggregate.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Beds
    **/
    _count?: true | BedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedMaxAggregateInputType
  }

  export type GetBedAggregateType<T extends BedAggregateArgs> = {
        [P in keyof T & keyof AggregateBed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBed[P]>
      : GetScalarType<T[P], AggregateBed[P]>
  }




  export type BedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedWhereInput
    orderBy?: BedOrderByWithAggregationInput | BedOrderByWithAggregationInput[]
    by: BedScalarFieldEnum[] | BedScalarFieldEnum
    having?: BedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedCountAggregateInputType | true
    _min?: BedMinAggregateInputType
    _max?: BedMaxAggregateInputType
  }

  export type BedGroupByOutputType = {
    id: string
    wardId: string
    bedNumber: string
    status: $Enums.BedStatus
    _count: BedCountAggregateOutputType | null
    _min: BedMinAggregateOutputType | null
    _max: BedMaxAggregateOutputType | null
  }

  type GetBedGroupByPayload<T extends BedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedGroupByOutputType[P]>
            : GetScalarType<T[P], BedGroupByOutputType[P]>
        }
      >
    >


  export type BedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wardId?: boolean
    bedNumber?: boolean
    status?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
    transfers?: boolean | Bed$transfersArgs<ExtArgs>
    activeAdmissions?: boolean | Bed$activeAdmissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wardId?: boolean
    bedNumber?: boolean
    status?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    wardId?: boolean
    bedNumber?: boolean
    status?: boolean
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bed"]>

  export type BedSelectScalar = {
    id?: boolean
    wardId?: boolean
    bedNumber?: boolean
    status?: boolean
  }

  export type BedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "wardId" | "bedNumber" | "status", ExtArgs["result"]["bed"]>
  export type BedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
    transfers?: boolean | Bed$transfersArgs<ExtArgs>
    activeAdmissions?: boolean | Bed$activeAdmissionsArgs<ExtArgs>
    _count?: boolean | BedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }
  export type BedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ward?: boolean | WardDefaultArgs<ExtArgs>
  }

  export type $BedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bed"
    objects: {
      ward: Prisma.$WardPayload<ExtArgs>
      transfers: Prisma.$BedTransferPayload<ExtArgs>[]
      activeAdmissions: Prisma.$AdmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      wardId: string
      bedNumber: string
      status: $Enums.BedStatus
    }, ExtArgs["result"]["bed"]>
    composites: {}
  }

  type BedGetPayload<S extends boolean | null | undefined | BedDefaultArgs> = $Result.GetResult<Prisma.$BedPayload, S>

  type BedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedCountAggregateInputType | true
    }

  export interface BedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bed'], meta: { name: 'Bed' } }
    /**
     * Find zero or one Bed that matches the filter.
     * @param {BedFindUniqueArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedFindUniqueArgs>(args: SelectSubset<T, BedFindUniqueArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bed that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedFindUniqueOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedFindUniqueOrThrowArgs>(args: SelectSubset<T, BedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedFindFirstArgs>(args?: SelectSubset<T, BedFindFirstArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bed that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindFirstOrThrowArgs} args - Arguments to find a Bed
     * @example
     * // Get one Bed
     * const bed = await prisma.bed.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedFindFirstOrThrowArgs>(args?: SelectSubset<T, BedFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Beds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Beds
     * const beds = await prisma.bed.findMany()
     * 
     * // Get first 10 Beds
     * const beds = await prisma.bed.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedWithIdOnly = await prisma.bed.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedFindManyArgs>(args?: SelectSubset<T, BedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bed.
     * @param {BedCreateArgs} args - Arguments to create a Bed.
     * @example
     * // Create one Bed
     * const Bed = await prisma.bed.create({
     *   data: {
     *     // ... data to create a Bed
     *   }
     * })
     * 
     */
    create<T extends BedCreateArgs>(args: SelectSubset<T, BedCreateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Beds.
     * @param {BedCreateManyArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedCreateManyArgs>(args?: SelectSubset<T, BedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Beds and returns the data saved in the database.
     * @param {BedCreateManyAndReturnArgs} args - Arguments to create many Beds.
     * @example
     * // Create many Beds
     * const bed = await prisma.bed.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedCreateManyAndReturnArgs>(args?: SelectSubset<T, BedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bed.
     * @param {BedDeleteArgs} args - Arguments to delete one Bed.
     * @example
     * // Delete one Bed
     * const Bed = await prisma.bed.delete({
     *   where: {
     *     // ... filter to delete one Bed
     *   }
     * })
     * 
     */
    delete<T extends BedDeleteArgs>(args: SelectSubset<T, BedDeleteArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bed.
     * @param {BedUpdateArgs} args - Arguments to update one Bed.
     * @example
     * // Update one Bed
     * const bed = await prisma.bed.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedUpdateArgs>(args: SelectSubset<T, BedUpdateArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Beds.
     * @param {BedDeleteManyArgs} args - Arguments to filter Beds to delete.
     * @example
     * // Delete a few Beds
     * const { count } = await prisma.bed.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedDeleteManyArgs>(args?: SelectSubset<T, BedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedUpdateManyArgs>(args: SelectSubset<T, BedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Beds and returns the data updated in the database.
     * @param {BedUpdateManyAndReturnArgs} args - Arguments to update many Beds.
     * @example
     * // Update many Beds
     * const bed = await prisma.bed.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Beds and only return the `id`
     * const bedWithIdOnly = await prisma.bed.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedUpdateManyAndReturnArgs>(args: SelectSubset<T, BedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bed.
     * @param {BedUpsertArgs} args - Arguments to update or create a Bed.
     * @example
     * // Update or create a Bed
     * const bed = await prisma.bed.upsert({
     *   create: {
     *     // ... data to create a Bed
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bed we want to update
     *   }
     * })
     */
    upsert<T extends BedUpsertArgs>(args: SelectSubset<T, BedUpsertArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Beds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedCountArgs} args - Arguments to filter Beds to count.
     * @example
     * // Count the number of Beds
     * const count = await prisma.bed.count({
     *   where: {
     *     // ... the filter for the Beds we want to count
     *   }
     * })
    **/
    count<T extends BedCountArgs>(
      args?: Subset<T, BedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedAggregateArgs>(args: Subset<T, BedAggregateArgs>): Prisma.PrismaPromise<GetBedAggregateType<T>>

    /**
     * Group by Bed.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedGroupByArgs['orderBy'] }
        : { orderBy?: BedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bed model
   */
  readonly fields: BedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bed.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ward<T extends WardDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WardDefaultArgs<ExtArgs>>): Prisma__WardClient<$Result.GetResult<Prisma.$WardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    transfers<T extends Bed$transfersArgs<ExtArgs> = {}>(args?: Subset<T, Bed$transfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activeAdmissions<T extends Bed$activeAdmissionsArgs<ExtArgs> = {}>(args?: Subset<T, Bed$activeAdmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bed model
   */
  interface BedFieldRefs {
    readonly id: FieldRef<"Bed", 'String'>
    readonly wardId: FieldRef<"Bed", 'String'>
    readonly bedNumber: FieldRef<"Bed", 'String'>
    readonly status: FieldRef<"Bed", 'BedStatus'>
  }
    

  // Custom InputTypes
  /**
   * Bed findUnique
   */
  export type BedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findUniqueOrThrow
   */
  export type BedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed findFirst
   */
  export type BedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findFirstOrThrow
   */
  export type BedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Bed to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Beds.
     */
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed findMany
   */
  export type BedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter, which Beds to fetch.
     */
    where?: BedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Beds to fetch.
     */
    orderBy?: BedOrderByWithRelationInput | BedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Beds.
     */
    cursor?: BedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Beds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Beds.
     */
    skip?: number
    distinct?: BedScalarFieldEnum | BedScalarFieldEnum[]
  }

  /**
   * Bed create
   */
  export type BedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to create a Bed.
     */
    data: XOR<BedCreateInput, BedUncheckedCreateInput>
  }

  /**
   * Bed createMany
   */
  export type BedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bed createManyAndReturn
   */
  export type BedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to create many Beds.
     */
    data: BedCreateManyInput | BedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed update
   */
  export type BedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The data needed to update a Bed.
     */
    data: XOR<BedUpdateInput, BedUncheckedUpdateInput>
    /**
     * Choose, which Bed to update.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed updateMany
   */
  export type BedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
  }

  /**
   * Bed updateManyAndReturn
   */
  export type BedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * The data used to update Beds.
     */
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyInput>
    /**
     * Filter which Beds to update
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bed upsert
   */
  export type BedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * The filter to search for the Bed to update in case it exists.
     */
    where: BedWhereUniqueInput
    /**
     * In case the Bed found by the `where` argument doesn't exist, create a new Bed with this data.
     */
    create: XOR<BedCreateInput, BedUncheckedCreateInput>
    /**
     * In case the Bed was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedUpdateInput, BedUncheckedUpdateInput>
  }

  /**
   * Bed delete
   */
  export type BedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    /**
     * Filter which Bed to delete.
     */
    where: BedWhereUniqueInput
  }

  /**
   * Bed deleteMany
   */
  export type BedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Beds to delete
     */
    where?: BedWhereInput
    /**
     * Limit how many Beds to delete.
     */
    limit?: number
  }

  /**
   * Bed.transfers
   */
  export type Bed$transfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    where?: BedTransferWhereInput
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    cursor?: BedTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedTransferScalarFieldEnum | BedTransferScalarFieldEnum[]
  }

  /**
   * Bed.activeAdmissions
   */
  export type Bed$activeAdmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Bed without action
   */
  export type BedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    uhid: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dob: Date | null
    gender: string | null
    maritalStatus: string | null
    nationality: string | null
    phone: string | null
    email: string | null
    preferredLanguage: string | null
    permanentAddress: string | null
    currentAddress: string | null
    city: string | null
    state: string | null
    pincode: string | null
    idProofType: string | null
    idProofNumber: string | null
    abhaId: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    defaultPayerType: string | null
    insuranceProvider: string | null
    policyNumber: string | null
    isDeceased: boolean | null
    registrationDate: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    uhid: string | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    dob: Date | null
    gender: string | null
    maritalStatus: string | null
    nationality: string | null
    phone: string | null
    email: string | null
    preferredLanguage: string | null
    permanentAddress: string | null
    currentAddress: string | null
    city: string | null
    state: string | null
    pincode: string | null
    idProofType: string | null
    idProofNumber: string | null
    abhaId: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    defaultPayerType: string | null
    insuranceProvider: string | null
    policyNumber: string | null
    isDeceased: boolean | null
    registrationDate: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    uhid: number
    firstName: number
    middleName: number
    lastName: number
    dob: number
    gender: number
    maritalStatus: number
    nationality: number
    phone: number
    email: number
    preferredLanguage: number
    permanentAddress: number
    currentAddress: number
    city: number
    state: number
    pincode: number
    idProofType: number
    idProofNumber: number
    abhaId: number
    emergencyContactName: number
    emergencyContactPhone: number
    emergencyContactRelation: number
    defaultPayerType: number
    insuranceProvider: number
    policyNumber: number
    isDeceased: number
    registrationDate: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    uhid?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    nationality?: true
    phone?: true
    email?: true
    preferredLanguage?: true
    permanentAddress?: true
    currentAddress?: true
    city?: true
    state?: true
    pincode?: true
    idProofType?: true
    idProofNumber?: true
    abhaId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    defaultPayerType?: true
    insuranceProvider?: true
    policyNumber?: true
    isDeceased?: true
    registrationDate?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    uhid?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    nationality?: true
    phone?: true
    email?: true
    preferredLanguage?: true
    permanentAddress?: true
    currentAddress?: true
    city?: true
    state?: true
    pincode?: true
    idProofType?: true
    idProofNumber?: true
    abhaId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    defaultPayerType?: true
    insuranceProvider?: true
    policyNumber?: true
    isDeceased?: true
    registrationDate?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    uhid?: true
    firstName?: true
    middleName?: true
    lastName?: true
    dob?: true
    gender?: true
    maritalStatus?: true
    nationality?: true
    phone?: true
    email?: true
    preferredLanguage?: true
    permanentAddress?: true
    currentAddress?: true
    city?: true
    state?: true
    pincode?: true
    idProofType?: true
    idProofNumber?: true
    abhaId?: true
    emergencyContactName?: true
    emergencyContactPhone?: true
    emergencyContactRelation?: true
    defaultPayerType?: true
    insuranceProvider?: true
    policyNumber?: true
    isDeceased?: true
    registrationDate?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    uhid: string
    firstName: string
    middleName: string | null
    lastName: string
    dob: Date
    gender: string | null
    maritalStatus: string | null
    nationality: string | null
    phone: string
    email: string | null
    preferredLanguage: string | null
    permanentAddress: string | null
    currentAddress: string | null
    city: string | null
    state: string | null
    pincode: string | null
    idProofType: string | null
    idProofNumber: string | null
    abhaId: string | null
    emergencyContactName: string | null
    emergencyContactPhone: string | null
    emergencyContactRelation: string | null
    defaultPayerType: string | null
    insuranceProvider: string | null
    policyNumber: string | null
    isDeceased: boolean
    registrationDate: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uhid?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    preferredLanguage?: boolean
    permanentAddress?: boolean
    currentAddress?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    abhaId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    defaultPayerType?: boolean
    insuranceProvider?: boolean
    policyNumber?: boolean
    isDeceased?: boolean
    registrationDate?: boolean
    medicalHistory?: boolean | Patient$medicalHistoryArgs<ExtArgs>
    documents?: boolean | Patient$documentsArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    opdVisits?: boolean | Patient$opdVisitsArgs<ExtArgs>
    admissions?: boolean | Patient$admissionsArgs<ExtArgs>
    clinicalNotes?: boolean | Patient$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | Patient$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    pharmacySales?: boolean | Patient$pharmacySalesArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uhid?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    preferredLanguage?: boolean
    permanentAddress?: boolean
    currentAddress?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    abhaId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    defaultPayerType?: boolean
    insuranceProvider?: boolean
    policyNumber?: boolean
    isDeceased?: boolean
    registrationDate?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uhid?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    preferredLanguage?: boolean
    permanentAddress?: boolean
    currentAddress?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    abhaId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    defaultPayerType?: boolean
    insuranceProvider?: boolean
    policyNumber?: boolean
    isDeceased?: boolean
    registrationDate?: boolean
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    uhid?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    dob?: boolean
    gender?: boolean
    maritalStatus?: boolean
    nationality?: boolean
    phone?: boolean
    email?: boolean
    preferredLanguage?: boolean
    permanentAddress?: boolean
    currentAddress?: boolean
    city?: boolean
    state?: boolean
    pincode?: boolean
    idProofType?: boolean
    idProofNumber?: boolean
    abhaId?: boolean
    emergencyContactName?: boolean
    emergencyContactPhone?: boolean
    emergencyContactRelation?: boolean
    defaultPayerType?: boolean
    insuranceProvider?: boolean
    policyNumber?: boolean
    isDeceased?: boolean
    registrationDate?: boolean
  }

  export type PatientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uhid" | "firstName" | "middleName" | "lastName" | "dob" | "gender" | "maritalStatus" | "nationality" | "phone" | "email" | "preferredLanguage" | "permanentAddress" | "currentAddress" | "city" | "state" | "pincode" | "idProofType" | "idProofNumber" | "abhaId" | "emergencyContactName" | "emergencyContactPhone" | "emergencyContactRelation" | "defaultPayerType" | "insuranceProvider" | "policyNumber" | "isDeceased" | "registrationDate", ExtArgs["result"]["patient"]>
  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalHistory?: boolean | Patient$medicalHistoryArgs<ExtArgs>
    documents?: boolean | Patient$documentsArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    opdVisits?: boolean | Patient$opdVisitsArgs<ExtArgs>
    admissions?: boolean | Patient$admissionsArgs<ExtArgs>
    clinicalNotes?: boolean | Patient$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | Patient$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | Patient$prescriptionsArgs<ExtArgs>
    pharmacySales?: boolean | Patient$pharmacySalesArgs<ExtArgs>
    invoices?: boolean | Patient$invoicesArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PatientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      medicalHistory: Prisma.$MedicalHistoryPayload<ExtArgs>[]
      documents: Prisma.$PatientDocumentPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      opdVisits: Prisma.$OpdVisitPayload<ExtArgs>[]
      admissions: Prisma.$AdmissionPayload<ExtArgs>[]
      clinicalNotes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      serviceOrders: Prisma.$ServiceOrderPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      pharmacySales: Prisma.$PharmacySalePayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      uhid: string
      firstName: string
      middleName: string | null
      lastName: string
      dob: Date
      gender: string | null
      maritalStatus: string | null
      nationality: string | null
      phone: string
      email: string | null
      preferredLanguage: string | null
      permanentAddress: string | null
      currentAddress: string | null
      city: string | null
      state: string | null
      pincode: string | null
      idProofType: string | null
      idProofNumber: string | null
      abhaId: string | null
      emergencyContactName: string | null
      emergencyContactPhone: string | null
      emergencyContactRelation: string | null
      defaultPayerType: string | null
      insuranceProvider: string | null
      policyNumber: string | null
      isDeceased: boolean
      registrationDate: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {PatientUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalHistory<T extends Patient$medicalHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicalHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Patient$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    opdVisits<T extends Patient$opdVisitsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$opdVisitsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admissions<T extends Patient$admissionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$admissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicalNotes<T extends Patient$clinicalNotesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$clinicalNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrders<T extends Patient$serviceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Patient$serviceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Patient$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pharmacySales<T extends Patient$pharmacySalesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$pharmacySalesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Patient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Patient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly uhid: FieldRef<"Patient", 'String'>
    readonly firstName: FieldRef<"Patient", 'String'>
    readonly middleName: FieldRef<"Patient", 'String'>
    readonly lastName: FieldRef<"Patient", 'String'>
    readonly dob: FieldRef<"Patient", 'DateTime'>
    readonly gender: FieldRef<"Patient", 'String'>
    readonly maritalStatus: FieldRef<"Patient", 'String'>
    readonly nationality: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly email: FieldRef<"Patient", 'String'>
    readonly preferredLanguage: FieldRef<"Patient", 'String'>
    readonly permanentAddress: FieldRef<"Patient", 'String'>
    readonly currentAddress: FieldRef<"Patient", 'String'>
    readonly city: FieldRef<"Patient", 'String'>
    readonly state: FieldRef<"Patient", 'String'>
    readonly pincode: FieldRef<"Patient", 'String'>
    readonly idProofType: FieldRef<"Patient", 'String'>
    readonly idProofNumber: FieldRef<"Patient", 'String'>
    readonly abhaId: FieldRef<"Patient", 'String'>
    readonly emergencyContactName: FieldRef<"Patient", 'String'>
    readonly emergencyContactPhone: FieldRef<"Patient", 'String'>
    readonly emergencyContactRelation: FieldRef<"Patient", 'String'>
    readonly defaultPayerType: FieldRef<"Patient", 'String'>
    readonly insuranceProvider: FieldRef<"Patient", 'String'>
    readonly policyNumber: FieldRef<"Patient", 'String'>
    readonly isDeceased: FieldRef<"Patient", 'Boolean'>
    readonly registrationDate: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient updateManyAndReturn
   */
  export type PatientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to update.
     */
    limit?: number
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
    /**
     * Limit how many Patients to delete.
     */
    limit?: number
  }

  /**
   * Patient.medicalHistory
   */
  export type Patient$medicalHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    where?: MedicalHistoryWhereInput
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    cursor?: MedicalHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * Patient.documents
   */
  export type Patient$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    where?: PatientDocumentWhereInput
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    cursor?: PatientDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.opdVisits
   */
  export type Patient$opdVisitsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    cursor?: OpdVisitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpdVisitScalarFieldEnum | OpdVisitScalarFieldEnum[]
  }

  /**
   * Patient.admissions
   */
  export type Patient$admissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    cursor?: AdmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Patient.clinicalNotes
   */
  export type Patient$clinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * Patient.serviceOrders
   */
  export type Patient$serviceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * Patient.prescriptions
   */
  export type Patient$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Patient.pharmacySales
   */
  export type Patient$pharmacySalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    where?: PharmacySaleWhereInput
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    cursor?: PharmacySaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacySaleScalarFieldEnum | PharmacySaleScalarFieldEnum[]
  }

  /**
   * Patient.invoices
   */
  export type Patient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Patient
     */
    omit?: PatientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model MedicalHistory
   */

  export type AggregateMedicalHistory = {
    _count: MedicalHistoryCountAggregateOutputType | null
    _min: MedicalHistoryMinAggregateOutputType | null
    _max: MedicalHistoryMaxAggregateOutputType | null
  }

  export type MedicalHistoryMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    category: string | null
    name: string | null
    severity: string | null
    status: string | null
    diagnosedDate: Date | null
    notes: string | null
  }

  export type MedicalHistoryMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    category: string | null
    name: string | null
    severity: string | null
    status: string | null
    diagnosedDate: Date | null
    notes: string | null
  }

  export type MedicalHistoryCountAggregateOutputType = {
    id: number
    patientId: number
    category: number
    name: number
    severity: number
    status: number
    diagnosedDate: number
    notes: number
    _all: number
  }


  export type MedicalHistoryMinAggregateInputType = {
    id?: true
    patientId?: true
    category?: true
    name?: true
    severity?: true
    status?: true
    diagnosedDate?: true
    notes?: true
  }

  export type MedicalHistoryMaxAggregateInputType = {
    id?: true
    patientId?: true
    category?: true
    name?: true
    severity?: true
    status?: true
    diagnosedDate?: true
    notes?: true
  }

  export type MedicalHistoryCountAggregateInputType = {
    id?: true
    patientId?: true
    category?: true
    name?: true
    severity?: true
    status?: true
    diagnosedDate?: true
    notes?: true
    _all?: true
  }

  export type MedicalHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalHistory to aggregate.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalHistories
    **/
    _count?: true | MedicalHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalHistoryMaxAggregateInputType
  }

  export type GetMedicalHistoryAggregateType<T extends MedicalHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalHistory[P]>
      : GetScalarType<T[P], AggregateMedicalHistory[P]>
  }




  export type MedicalHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalHistoryWhereInput
    orderBy?: MedicalHistoryOrderByWithAggregationInput | MedicalHistoryOrderByWithAggregationInput[]
    by: MedicalHistoryScalarFieldEnum[] | MedicalHistoryScalarFieldEnum
    having?: MedicalHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalHistoryCountAggregateInputType | true
    _min?: MedicalHistoryMinAggregateInputType
    _max?: MedicalHistoryMaxAggregateInputType
  }

  export type MedicalHistoryGroupByOutputType = {
    id: string
    patientId: string
    category: string
    name: string
    severity: string | null
    status: string | null
    diagnosedDate: Date | null
    notes: string | null
    _count: MedicalHistoryCountAggregateOutputType | null
    _min: MedicalHistoryMinAggregateOutputType | null
    _max: MedicalHistoryMaxAggregateOutputType | null
  }

  type GetMedicalHistoryGroupByPayload<T extends MedicalHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalHistoryGroupByOutputType[P]>
        }
      >
    >


  export type MedicalHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    category?: boolean
    name?: boolean
    severity?: boolean
    status?: boolean
    diagnosedDate?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalHistory"]>

  export type MedicalHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    category?: boolean
    name?: boolean
    severity?: boolean
    status?: boolean
    diagnosedDate?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalHistory"]>

  export type MedicalHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    category?: boolean
    name?: boolean
    severity?: boolean
    status?: boolean
    diagnosedDate?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalHistory"]>

  export type MedicalHistorySelectScalar = {
    id?: boolean
    patientId?: boolean
    category?: boolean
    name?: boolean
    severity?: boolean
    status?: boolean
    diagnosedDate?: boolean
    notes?: boolean
  }

  export type MedicalHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "category" | "name" | "severity" | "status" | "diagnosedDate" | "notes", ExtArgs["result"]["medicalHistory"]>
  export type MedicalHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicalHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicalHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $MedicalHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalHistory"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      category: string
      name: string
      severity: string | null
      status: string | null
      diagnosedDate: Date | null
      notes: string | null
    }, ExtArgs["result"]["medicalHistory"]>
    composites: {}
  }

  type MedicalHistoryGetPayload<S extends boolean | null | undefined | MedicalHistoryDefaultArgs> = $Result.GetResult<Prisma.$MedicalHistoryPayload, S>

  type MedicalHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalHistoryCountAggregateInputType | true
    }

  export interface MedicalHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalHistory'], meta: { name: 'MedicalHistory' } }
    /**
     * Find zero or one MedicalHistory that matches the filter.
     * @param {MedicalHistoryFindUniqueArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalHistoryFindUniqueArgs>(args: SelectSubset<T, MedicalHistoryFindUniqueArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalHistoryFindUniqueOrThrowArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindFirstArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalHistoryFindFirstArgs>(args?: SelectSubset<T, MedicalHistoryFindFirstArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindFirstOrThrowArgs} args - Arguments to find a MedicalHistory
     * @example
     * // Get one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalHistories
     * const medicalHistories = await prisma.medicalHistory.findMany()
     * 
     * // Get first 10 MedicalHistories
     * const medicalHistories = await prisma.medicalHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalHistoryWithIdOnly = await prisma.medicalHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalHistoryFindManyArgs>(args?: SelectSubset<T, MedicalHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalHistory.
     * @param {MedicalHistoryCreateArgs} args - Arguments to create a MedicalHistory.
     * @example
     * // Create one MedicalHistory
     * const MedicalHistory = await prisma.medicalHistory.create({
     *   data: {
     *     // ... data to create a MedicalHistory
     *   }
     * })
     * 
     */
    create<T extends MedicalHistoryCreateArgs>(args: SelectSubset<T, MedicalHistoryCreateArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalHistories.
     * @param {MedicalHistoryCreateManyArgs} args - Arguments to create many MedicalHistories.
     * @example
     * // Create many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalHistoryCreateManyArgs>(args?: SelectSubset<T, MedicalHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicalHistories and returns the data saved in the database.
     * @param {MedicalHistoryCreateManyAndReturnArgs} args - Arguments to create many MedicalHistories.
     * @example
     * // Create many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicalHistories and only return the `id`
     * const medicalHistoryWithIdOnly = await prisma.medicalHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicalHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicalHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MedicalHistory.
     * @param {MedicalHistoryDeleteArgs} args - Arguments to delete one MedicalHistory.
     * @example
     * // Delete one MedicalHistory
     * const MedicalHistory = await prisma.medicalHistory.delete({
     *   where: {
     *     // ... filter to delete one MedicalHistory
     *   }
     * })
     * 
     */
    delete<T extends MedicalHistoryDeleteArgs>(args: SelectSubset<T, MedicalHistoryDeleteArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalHistory.
     * @param {MedicalHistoryUpdateArgs} args - Arguments to update one MedicalHistory.
     * @example
     * // Update one MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalHistoryUpdateArgs>(args: SelectSubset<T, MedicalHistoryUpdateArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalHistories.
     * @param {MedicalHistoryDeleteManyArgs} args - Arguments to filter MedicalHistories to delete.
     * @example
     * // Delete a few MedicalHistories
     * const { count } = await prisma.medicalHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalHistoryDeleteManyArgs>(args?: SelectSubset<T, MedicalHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalHistoryUpdateManyArgs>(args: SelectSubset<T, MedicalHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalHistories and returns the data updated in the database.
     * @param {MedicalHistoryUpdateManyAndReturnArgs} args - Arguments to update many MedicalHistories.
     * @example
     * // Update many MedicalHistories
     * const medicalHistory = await prisma.medicalHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MedicalHistories and only return the `id`
     * const medicalHistoryWithIdOnly = await prisma.medicalHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicalHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicalHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MedicalHistory.
     * @param {MedicalHistoryUpsertArgs} args - Arguments to update or create a MedicalHistory.
     * @example
     * // Update or create a MedicalHistory
     * const medicalHistory = await prisma.medicalHistory.upsert({
     *   create: {
     *     // ... data to create a MedicalHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalHistory we want to update
     *   }
     * })
     */
    upsert<T extends MedicalHistoryUpsertArgs>(args: SelectSubset<T, MedicalHistoryUpsertArgs<ExtArgs>>): Prisma__MedicalHistoryClient<$Result.GetResult<Prisma.$MedicalHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MedicalHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryCountArgs} args - Arguments to filter MedicalHistories to count.
     * @example
     * // Count the number of MedicalHistories
     * const count = await prisma.medicalHistory.count({
     *   where: {
     *     // ... the filter for the MedicalHistories we want to count
     *   }
     * })
    **/
    count<T extends MedicalHistoryCountArgs>(
      args?: Subset<T, MedicalHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalHistoryAggregateArgs>(args: Subset<T, MedicalHistoryAggregateArgs>): Prisma.PrismaPromise<GetMedicalHistoryAggregateType<T>>

    /**
     * Group by MedicalHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalHistoryGroupByArgs['orderBy'] }
        : { orderBy?: MedicalHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalHistory model
   */
  readonly fields: MedicalHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalHistory model
   */
  interface MedicalHistoryFieldRefs {
    readonly id: FieldRef<"MedicalHistory", 'String'>
    readonly patientId: FieldRef<"MedicalHistory", 'String'>
    readonly category: FieldRef<"MedicalHistory", 'String'>
    readonly name: FieldRef<"MedicalHistory", 'String'>
    readonly severity: FieldRef<"MedicalHistory", 'String'>
    readonly status: FieldRef<"MedicalHistory", 'String'>
    readonly diagnosedDate: FieldRef<"MedicalHistory", 'DateTime'>
    readonly notes: FieldRef<"MedicalHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicalHistory findUnique
   */
  export type MedicalHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory findUniqueOrThrow
   */
  export type MedicalHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory findFirst
   */
  export type MedicalHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalHistories.
     */
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory findFirstOrThrow
   */
  export type MedicalHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistory to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalHistories.
     */
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory findMany
   */
  export type MedicalHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MedicalHistories to fetch.
     */
    where?: MedicalHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalHistories to fetch.
     */
    orderBy?: MedicalHistoryOrderByWithRelationInput | MedicalHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalHistories.
     */
    cursor?: MedicalHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalHistories.
     */
    skip?: number
    distinct?: MedicalHistoryScalarFieldEnum | MedicalHistoryScalarFieldEnum[]
  }

  /**
   * MedicalHistory create
   */
  export type MedicalHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalHistory.
     */
    data: XOR<MedicalHistoryCreateInput, MedicalHistoryUncheckedCreateInput>
  }

  /**
   * MedicalHistory createMany
   */
  export type MedicalHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalHistories.
     */
    data: MedicalHistoryCreateManyInput | MedicalHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicalHistory createManyAndReturn
   */
  export type MedicalHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many MedicalHistories.
     */
    data: MedicalHistoryCreateManyInput | MedicalHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalHistory update
   */
  export type MedicalHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalHistory.
     */
    data: XOR<MedicalHistoryUpdateInput, MedicalHistoryUncheckedUpdateInput>
    /**
     * Choose, which MedicalHistory to update.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory updateMany
   */
  export type MedicalHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalHistories.
     */
    data: XOR<MedicalHistoryUpdateManyMutationInput, MedicalHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MedicalHistories to update
     */
    where?: MedicalHistoryWhereInput
    /**
     * Limit how many MedicalHistories to update.
     */
    limit?: number
  }

  /**
   * MedicalHistory updateManyAndReturn
   */
  export type MedicalHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * The data used to update MedicalHistories.
     */
    data: XOR<MedicalHistoryUpdateManyMutationInput, MedicalHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MedicalHistories to update
     */
    where?: MedicalHistoryWhereInput
    /**
     * Limit how many MedicalHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicalHistory upsert
   */
  export type MedicalHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalHistory to update in case it exists.
     */
    where: MedicalHistoryWhereUniqueInput
    /**
     * In case the MedicalHistory found by the `where` argument doesn't exist, create a new MedicalHistory with this data.
     */
    create: XOR<MedicalHistoryCreateInput, MedicalHistoryUncheckedCreateInput>
    /**
     * In case the MedicalHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalHistoryUpdateInput, MedicalHistoryUncheckedUpdateInput>
  }

  /**
   * MedicalHistory delete
   */
  export type MedicalHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
    /**
     * Filter which MedicalHistory to delete.
     */
    where: MedicalHistoryWhereUniqueInput
  }

  /**
   * MedicalHistory deleteMany
   */
  export type MedicalHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalHistories to delete
     */
    where?: MedicalHistoryWhereInput
    /**
     * Limit how many MedicalHistories to delete.
     */
    limit?: number
  }

  /**
   * MedicalHistory without action
   */
  export type MedicalHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalHistory
     */
    select?: MedicalHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalHistory
     */
    omit?: MedicalHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PatientDocument
   */

  export type AggregatePatientDocument = {
    _count: PatientDocumentCountAggregateOutputType | null
    _min: PatientDocumentMinAggregateOutputType | null
    _max: PatientDocumentMaxAggregateOutputType | null
  }

  export type PatientDocumentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitId: string | null
    admissionId: string | null
    category: string | null
    fileUrl: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type PatientDocumentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitId: string | null
    admissionId: string | null
    category: string | null
    fileUrl: string | null
    uploadedBy: string | null
    uploadedAt: Date | null
  }

  export type PatientDocumentCountAggregateOutputType = {
    id: number
    patientId: number
    visitId: number
    admissionId: number
    category: number
    fileUrl: number
    uploadedBy: number
    uploadedAt: number
    _all: number
  }


  export type PatientDocumentMinAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    category?: true
    fileUrl?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type PatientDocumentMaxAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    category?: true
    fileUrl?: true
    uploadedBy?: true
    uploadedAt?: true
  }

  export type PatientDocumentCountAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    category?: true
    fileUrl?: true
    uploadedBy?: true
    uploadedAt?: true
    _all?: true
  }

  export type PatientDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientDocument to aggregate.
     */
    where?: PatientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDocuments to fetch.
     */
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientDocuments
    **/
    _count?: true | PatientDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientDocumentMaxAggregateInputType
  }

  export type GetPatientDocumentAggregateType<T extends PatientDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientDocument[P]>
      : GetScalarType<T[P], AggregatePatientDocument[P]>
  }




  export type PatientDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientDocumentWhereInput
    orderBy?: PatientDocumentOrderByWithAggregationInput | PatientDocumentOrderByWithAggregationInput[]
    by: PatientDocumentScalarFieldEnum[] | PatientDocumentScalarFieldEnum
    having?: PatientDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientDocumentCountAggregateInputType | true
    _min?: PatientDocumentMinAggregateInputType
    _max?: PatientDocumentMaxAggregateInputType
  }

  export type PatientDocumentGroupByOutputType = {
    id: string
    patientId: string
    visitId: string | null
    admissionId: string | null
    category: string
    fileUrl: string
    uploadedBy: string | null
    uploadedAt: Date
    _count: PatientDocumentCountAggregateOutputType | null
    _min: PatientDocumentMinAggregateOutputType | null
    _max: PatientDocumentMaxAggregateOutputType | null
  }

  type GetPatientDocumentGroupByPayload<T extends PatientDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PatientDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PatientDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    category?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["patientDocument"]>

  export type PatientDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    category?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["patientDocument"]>

  export type PatientDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    category?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["patientDocument"]>

  export type PatientDocumentSelectScalar = {
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    category?: boolean
    fileUrl?: boolean
    uploadedBy?: boolean
    uploadedAt?: boolean
  }

  export type PatientDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "visitId" | "admissionId" | "category" | "fileUrl" | "uploadedBy" | "uploadedAt", ExtArgs["result"]["patientDocument"]>
  export type PatientDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }
  export type PatientDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }
  export type PatientDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | PatientDocument$visitArgs<ExtArgs>
    admission?: boolean | PatientDocument$admissionArgs<ExtArgs>
  }

  export type $PatientDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientDocument"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      visitId: string | null
      admissionId: string | null
      category: string
      fileUrl: string
      uploadedBy: string | null
      uploadedAt: Date
    }, ExtArgs["result"]["patientDocument"]>
    composites: {}
  }

  type PatientDocumentGetPayload<S extends boolean | null | undefined | PatientDocumentDefaultArgs> = $Result.GetResult<Prisma.$PatientDocumentPayload, S>

  type PatientDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatientDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientDocumentCountAggregateInputType | true
    }

  export interface PatientDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientDocument'], meta: { name: 'PatientDocument' } }
    /**
     * Find zero or one PatientDocument that matches the filter.
     * @param {PatientDocumentFindUniqueArgs} args - Arguments to find a PatientDocument
     * @example
     * // Get one PatientDocument
     * const patientDocument = await prisma.patientDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientDocumentFindUniqueArgs>(args: SelectSubset<T, PatientDocumentFindUniqueArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatientDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatientDocumentFindUniqueOrThrowArgs} args - Arguments to find a PatientDocument
     * @example
     * // Get one PatientDocument
     * const patientDocument = await prisma.patientDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentFindFirstArgs} args - Arguments to find a PatientDocument
     * @example
     * // Get one PatientDocument
     * const patientDocument = await prisma.patientDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientDocumentFindFirstArgs>(args?: SelectSubset<T, PatientDocumentFindFirstArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatientDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentFindFirstOrThrowArgs} args - Arguments to find a PatientDocument
     * @example
     * // Get one PatientDocument
     * const patientDocument = await prisma.patientDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatientDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientDocuments
     * const patientDocuments = await prisma.patientDocument.findMany()
     * 
     * // Get first 10 PatientDocuments
     * const patientDocuments = await prisma.patientDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientDocumentWithIdOnly = await prisma.patientDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientDocumentFindManyArgs>(args?: SelectSubset<T, PatientDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatientDocument.
     * @param {PatientDocumentCreateArgs} args - Arguments to create a PatientDocument.
     * @example
     * // Create one PatientDocument
     * const PatientDocument = await prisma.patientDocument.create({
     *   data: {
     *     // ... data to create a PatientDocument
     *   }
     * })
     * 
     */
    create<T extends PatientDocumentCreateArgs>(args: SelectSubset<T, PatientDocumentCreateArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatientDocuments.
     * @param {PatientDocumentCreateManyArgs} args - Arguments to create many PatientDocuments.
     * @example
     * // Create many PatientDocuments
     * const patientDocument = await prisma.patientDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientDocumentCreateManyArgs>(args?: SelectSubset<T, PatientDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientDocuments and returns the data saved in the database.
     * @param {PatientDocumentCreateManyAndReturnArgs} args - Arguments to create many PatientDocuments.
     * @example
     * // Create many PatientDocuments
     * const patientDocument = await prisma.patientDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientDocuments and only return the `id`
     * const patientDocumentWithIdOnly = await prisma.patientDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatientDocument.
     * @param {PatientDocumentDeleteArgs} args - Arguments to delete one PatientDocument.
     * @example
     * // Delete one PatientDocument
     * const PatientDocument = await prisma.patientDocument.delete({
     *   where: {
     *     // ... filter to delete one PatientDocument
     *   }
     * })
     * 
     */
    delete<T extends PatientDocumentDeleteArgs>(args: SelectSubset<T, PatientDocumentDeleteArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatientDocument.
     * @param {PatientDocumentUpdateArgs} args - Arguments to update one PatientDocument.
     * @example
     * // Update one PatientDocument
     * const patientDocument = await prisma.patientDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientDocumentUpdateArgs>(args: SelectSubset<T, PatientDocumentUpdateArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatientDocuments.
     * @param {PatientDocumentDeleteManyArgs} args - Arguments to filter PatientDocuments to delete.
     * @example
     * // Delete a few PatientDocuments
     * const { count } = await prisma.patientDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDocumentDeleteManyArgs>(args?: SelectSubset<T, PatientDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientDocuments
     * const patientDocument = await prisma.patientDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientDocumentUpdateManyArgs>(args: SelectSubset<T, PatientDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientDocuments and returns the data updated in the database.
     * @param {PatientDocumentUpdateManyAndReturnArgs} args - Arguments to update many PatientDocuments.
     * @example
     * // Update many PatientDocuments
     * const patientDocument = await prisma.patientDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PatientDocuments and only return the `id`
     * const patientDocumentWithIdOnly = await prisma.patientDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PatientDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, PatientDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatientDocument.
     * @param {PatientDocumentUpsertArgs} args - Arguments to update or create a PatientDocument.
     * @example
     * // Update or create a PatientDocument
     * const patientDocument = await prisma.patientDocument.upsert({
     *   create: {
     *     // ... data to create a PatientDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientDocument we want to update
     *   }
     * })
     */
    upsert<T extends PatientDocumentUpsertArgs>(args: SelectSubset<T, PatientDocumentUpsertArgs<ExtArgs>>): Prisma__PatientDocumentClient<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatientDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentCountArgs} args - Arguments to filter PatientDocuments to count.
     * @example
     * // Count the number of PatientDocuments
     * const count = await prisma.patientDocument.count({
     *   where: {
     *     // ... the filter for the PatientDocuments we want to count
     *   }
     * })
    **/
    count<T extends PatientDocumentCountArgs>(
      args?: Subset<T, PatientDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientDocumentAggregateArgs>(args: Subset<T, PatientDocumentAggregateArgs>): Prisma.PrismaPromise<GetPatientDocumentAggregateType<T>>

    /**
     * Group by PatientDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PatientDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientDocument model
   */
  readonly fields: PatientDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visit<T extends PatientDocument$visitArgs<ExtArgs> = {}>(args?: Subset<T, PatientDocument$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admission<T extends PatientDocument$admissionArgs<ExtArgs> = {}>(args?: Subset<T, PatientDocument$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientDocument model
   */
  interface PatientDocumentFieldRefs {
    readonly id: FieldRef<"PatientDocument", 'String'>
    readonly patientId: FieldRef<"PatientDocument", 'String'>
    readonly visitId: FieldRef<"PatientDocument", 'String'>
    readonly admissionId: FieldRef<"PatientDocument", 'String'>
    readonly category: FieldRef<"PatientDocument", 'String'>
    readonly fileUrl: FieldRef<"PatientDocument", 'String'>
    readonly uploadedBy: FieldRef<"PatientDocument", 'String'>
    readonly uploadedAt: FieldRef<"PatientDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientDocument findUnique
   */
  export type PatientDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PatientDocument to fetch.
     */
    where: PatientDocumentWhereUniqueInput
  }

  /**
   * PatientDocument findUniqueOrThrow
   */
  export type PatientDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PatientDocument to fetch.
     */
    where: PatientDocumentWhereUniqueInput
  }

  /**
   * PatientDocument findFirst
   */
  export type PatientDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PatientDocument to fetch.
     */
    where?: PatientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDocuments to fetch.
     */
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientDocuments.
     */
    cursor?: PatientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientDocuments.
     */
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * PatientDocument findFirstOrThrow
   */
  export type PatientDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PatientDocument to fetch.
     */
    where?: PatientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDocuments to fetch.
     */
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientDocuments.
     */
    cursor?: PatientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientDocuments.
     */
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * PatientDocument findMany
   */
  export type PatientDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PatientDocuments to fetch.
     */
    where?: PatientDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientDocuments to fetch.
     */
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientDocuments.
     */
    cursor?: PatientDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientDocuments.
     */
    skip?: number
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * PatientDocument create
   */
  export type PatientDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientDocument.
     */
    data: XOR<PatientDocumentCreateInput, PatientDocumentUncheckedCreateInput>
  }

  /**
   * PatientDocument createMany
   */
  export type PatientDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientDocuments.
     */
    data: PatientDocumentCreateManyInput | PatientDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientDocument createManyAndReturn
   */
  export type PatientDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many PatientDocuments.
     */
    data: PatientDocumentCreateManyInput | PatientDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientDocument update
   */
  export type PatientDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientDocument.
     */
    data: XOR<PatientDocumentUpdateInput, PatientDocumentUncheckedUpdateInput>
    /**
     * Choose, which PatientDocument to update.
     */
    where: PatientDocumentWhereUniqueInput
  }

  /**
   * PatientDocument updateMany
   */
  export type PatientDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientDocuments.
     */
    data: XOR<PatientDocumentUpdateManyMutationInput, PatientDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PatientDocuments to update
     */
    where?: PatientDocumentWhereInput
    /**
     * Limit how many PatientDocuments to update.
     */
    limit?: number
  }

  /**
   * PatientDocument updateManyAndReturn
   */
  export type PatientDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * The data used to update PatientDocuments.
     */
    data: XOR<PatientDocumentUpdateManyMutationInput, PatientDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PatientDocuments to update
     */
    where?: PatientDocumentWhereInput
    /**
     * Limit how many PatientDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientDocument upsert
   */
  export type PatientDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientDocument to update in case it exists.
     */
    where: PatientDocumentWhereUniqueInput
    /**
     * In case the PatientDocument found by the `where` argument doesn't exist, create a new PatientDocument with this data.
     */
    create: XOR<PatientDocumentCreateInput, PatientDocumentUncheckedCreateInput>
    /**
     * In case the PatientDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientDocumentUpdateInput, PatientDocumentUncheckedUpdateInput>
  }

  /**
   * PatientDocument delete
   */
  export type PatientDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    /**
     * Filter which PatientDocument to delete.
     */
    where: PatientDocumentWhereUniqueInput
  }

  /**
   * PatientDocument deleteMany
   */
  export type PatientDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientDocuments to delete
     */
    where?: PatientDocumentWhereInput
    /**
     * Limit how many PatientDocuments to delete.
     */
    limit?: number
  }

  /**
   * PatientDocument.visit
   */
  export type PatientDocument$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * PatientDocument.admission
   */
  export type PatientDocument$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * PatientDocument without action
   */
  export type PatientDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    tokenNumber: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    tokenNumber: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    departmentId: string | null
    appointmentDate: Date | null
    tokenNumber: number | null
    status: $Enums.AppointmentStatus | null
    type: $Enums.AppointmentType | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    departmentId: string | null
    appointmentDate: Date | null
    tokenNumber: number | null
    status: $Enums.AppointmentStatus | null
    type: $Enums.AppointmentType | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    departmentId: number
    appointmentDate: number
    tokenNumber: number
    status: number
    type: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    tokenNumber?: true
  }

  export type AppointmentSumAggregateInputType = {
    tokenNumber?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    appointmentDate?: true
    tokenNumber?: true
    status?: true
    type?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    appointmentDate?: true
    tokenNumber?: true
    status?: true
    type?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    departmentId?: true
    appointmentDate?: true
    tokenNumber?: true
    status?: true
    type?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    departmentId: string
    appointmentDate: Date
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    appointmentDate?: boolean
    tokenNumber?: boolean
    status?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    opdVisit?: boolean | Appointment$opdVisitArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    appointmentDate?: boolean
    tokenNumber?: boolean
    status?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    appointmentDate?: boolean
    tokenNumber?: boolean
    status?: boolean
    type?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    departmentId?: boolean
    appointmentDate?: boolean
    tokenNumber?: boolean
    status?: boolean
    type?: boolean
  }

  export type AppointmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "departmentId" | "appointmentDate" | "tokenNumber" | "status" | "type", ExtArgs["result"]["appointment"]>
  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    opdVisit?: boolean | Appointment$opdVisitArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$StaffProfilePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      opdVisit: Prisma.$OpdVisitPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      departmentId: string
      appointmentDate: Date
      tokenNumber: number
      status: $Enums.AppointmentStatus
      type: $Enums.AppointmentType
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {AppointmentUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppointmentUpdateManyAndReturnArgs>(args: SelectSubset<T, AppointmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    opdVisit<T extends Appointment$opdVisitArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$opdVisitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly doctorId: FieldRef<"Appointment", 'String'>
    readonly departmentId: FieldRef<"Appointment", 'String'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly tokenNumber: FieldRef<"Appointment", 'Int'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly type: FieldRef<"Appointment", 'AppointmentType'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
  }

  /**
   * Appointment updateManyAndReturn
   */
  export type AppointmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
    /**
     * Limit how many Appointments to delete.
     */
    limit?: number
  }

  /**
   * Appointment.opdVisit
   */
  export type Appointment$opdVisitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model OpdVisit
   */

  export type AggregateOpdVisit = {
    _count: OpdVisitCountAggregateOutputType | null
    _min: OpdVisitMinAggregateOutputType | null
    _max: OpdVisitMaxAggregateOutputType | null
  }

  export type OpdVisitMinAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    patientId: string | null
    doctorId: string | null
    visitDate: Date | null
    visitType: $Enums.VisitType | null
    triageColor: $Enums.TriageColor | null
    status: $Enums.VisitStatus | null
    isMedicoLegal: boolean | null
  }

  export type OpdVisitMaxAggregateOutputType = {
    id: string | null
    appointmentId: string | null
    patientId: string | null
    doctorId: string | null
    visitDate: Date | null
    visitType: $Enums.VisitType | null
    triageColor: $Enums.TriageColor | null
    status: $Enums.VisitStatus | null
    isMedicoLegal: boolean | null
  }

  export type OpdVisitCountAggregateOutputType = {
    id: number
    appointmentId: number
    patientId: number
    doctorId: number
    visitDate: number
    visitType: number
    triageColor: number
    status: number
    isMedicoLegal: number
    _all: number
  }


  export type OpdVisitMinAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    doctorId?: true
    visitDate?: true
    visitType?: true
    triageColor?: true
    status?: true
    isMedicoLegal?: true
  }

  export type OpdVisitMaxAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    doctorId?: true
    visitDate?: true
    visitType?: true
    triageColor?: true
    status?: true
    isMedicoLegal?: true
  }

  export type OpdVisitCountAggregateInputType = {
    id?: true
    appointmentId?: true
    patientId?: true
    doctorId?: true
    visitDate?: true
    visitType?: true
    triageColor?: true
    status?: true
    isMedicoLegal?: true
    _all?: true
  }

  export type OpdVisitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpdVisit to aggregate.
     */
    where?: OpdVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpdVisits to fetch.
     */
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpdVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpdVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpdVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OpdVisits
    **/
    _count?: true | OpdVisitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpdVisitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpdVisitMaxAggregateInputType
  }

  export type GetOpdVisitAggregateType<T extends OpdVisitAggregateArgs> = {
        [P in keyof T & keyof AggregateOpdVisit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOpdVisit[P]>
      : GetScalarType<T[P], AggregateOpdVisit[P]>
  }




  export type OpdVisitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpdVisitWhereInput
    orderBy?: OpdVisitOrderByWithAggregationInput | OpdVisitOrderByWithAggregationInput[]
    by: OpdVisitScalarFieldEnum[] | OpdVisitScalarFieldEnum
    having?: OpdVisitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpdVisitCountAggregateInputType | true
    _min?: OpdVisitMinAggregateInputType
    _max?: OpdVisitMaxAggregateInputType
  }

  export type OpdVisitGroupByOutputType = {
    id: string
    appointmentId: string | null
    patientId: string
    doctorId: string
    visitDate: Date
    visitType: $Enums.VisitType
    triageColor: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal: boolean
    _count: OpdVisitCountAggregateOutputType | null
    _min: OpdVisitMinAggregateOutputType | null
    _max: OpdVisitMaxAggregateOutputType | null
  }

  type GetOpdVisitGroupByPayload<T extends OpdVisitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpdVisitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpdVisitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpdVisitGroupByOutputType[P]>
            : GetScalarType<T[P], OpdVisitGroupByOutputType[P]>
        }
      >
    >


  export type OpdVisitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    visitType?: boolean
    triageColor?: boolean
    status?: boolean
    isMedicoLegal?: boolean
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    clinicalNotes?: boolean | OpdVisit$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | OpdVisit$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | OpdVisit$prescriptionsArgs<ExtArgs>
    documents?: boolean | OpdVisit$documentsArgs<ExtArgs>
    invoices?: boolean | OpdVisit$invoicesArgs<ExtArgs>
    admission?: boolean | OpdVisit$admissionArgs<ExtArgs>
    _count?: boolean | OpdVisitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opdVisit"]>

  export type OpdVisitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    visitType?: boolean
    triageColor?: boolean
    status?: boolean
    isMedicoLegal?: boolean
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opdVisit"]>

  export type OpdVisitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    visitType?: boolean
    triageColor?: boolean
    status?: boolean
    isMedicoLegal?: boolean
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["opdVisit"]>

  export type OpdVisitSelectScalar = {
    id?: boolean
    appointmentId?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitDate?: boolean
    visitType?: boolean
    triageColor?: boolean
    status?: boolean
    isMedicoLegal?: boolean
  }

  export type OpdVisitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointmentId" | "patientId" | "doctorId" | "visitDate" | "visitType" | "triageColor" | "status" | "isMedicoLegal", ExtArgs["result"]["opdVisit"]>
  export type OpdVisitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    clinicalNotes?: boolean | OpdVisit$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | OpdVisit$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | OpdVisit$prescriptionsArgs<ExtArgs>
    documents?: boolean | OpdVisit$documentsArgs<ExtArgs>
    invoices?: boolean | OpdVisit$invoicesArgs<ExtArgs>
    admission?: boolean | OpdVisit$admissionArgs<ExtArgs>
    _count?: boolean | OpdVisitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OpdVisitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type OpdVisitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | OpdVisit$appointmentArgs<ExtArgs>
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $OpdVisitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OpdVisit"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$StaffProfilePayload<ExtArgs>
      clinicalNotes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      serviceOrders: Prisma.$ServiceOrderPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      documents: Prisma.$PatientDocumentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointmentId: string | null
      patientId: string
      doctorId: string
      visitDate: Date
      visitType: $Enums.VisitType
      triageColor: $Enums.TriageColor | null
      status: $Enums.VisitStatus
      isMedicoLegal: boolean
    }, ExtArgs["result"]["opdVisit"]>
    composites: {}
  }

  type OpdVisitGetPayload<S extends boolean | null | undefined | OpdVisitDefaultArgs> = $Result.GetResult<Prisma.$OpdVisitPayload, S>

  type OpdVisitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpdVisitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpdVisitCountAggregateInputType | true
    }

  export interface OpdVisitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OpdVisit'], meta: { name: 'OpdVisit' } }
    /**
     * Find zero or one OpdVisit that matches the filter.
     * @param {OpdVisitFindUniqueArgs} args - Arguments to find a OpdVisit
     * @example
     * // Get one OpdVisit
     * const opdVisit = await prisma.opdVisit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpdVisitFindUniqueArgs>(args: SelectSubset<T, OpdVisitFindUniqueArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OpdVisit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpdVisitFindUniqueOrThrowArgs} args - Arguments to find a OpdVisit
     * @example
     * // Get one OpdVisit
     * const opdVisit = await prisma.opdVisit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpdVisitFindUniqueOrThrowArgs>(args: SelectSubset<T, OpdVisitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpdVisit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitFindFirstArgs} args - Arguments to find a OpdVisit
     * @example
     * // Get one OpdVisit
     * const opdVisit = await prisma.opdVisit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpdVisitFindFirstArgs>(args?: SelectSubset<T, OpdVisitFindFirstArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OpdVisit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitFindFirstOrThrowArgs} args - Arguments to find a OpdVisit
     * @example
     * // Get one OpdVisit
     * const opdVisit = await prisma.opdVisit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpdVisitFindFirstOrThrowArgs>(args?: SelectSubset<T, OpdVisitFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OpdVisits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OpdVisits
     * const opdVisits = await prisma.opdVisit.findMany()
     * 
     * // Get first 10 OpdVisits
     * const opdVisits = await prisma.opdVisit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const opdVisitWithIdOnly = await prisma.opdVisit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OpdVisitFindManyArgs>(args?: SelectSubset<T, OpdVisitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OpdVisit.
     * @param {OpdVisitCreateArgs} args - Arguments to create a OpdVisit.
     * @example
     * // Create one OpdVisit
     * const OpdVisit = await prisma.opdVisit.create({
     *   data: {
     *     // ... data to create a OpdVisit
     *   }
     * })
     * 
     */
    create<T extends OpdVisitCreateArgs>(args: SelectSubset<T, OpdVisitCreateArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OpdVisits.
     * @param {OpdVisitCreateManyArgs} args - Arguments to create many OpdVisits.
     * @example
     * // Create many OpdVisits
     * const opdVisit = await prisma.opdVisit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpdVisitCreateManyArgs>(args?: SelectSubset<T, OpdVisitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OpdVisits and returns the data saved in the database.
     * @param {OpdVisitCreateManyAndReturnArgs} args - Arguments to create many OpdVisits.
     * @example
     * // Create many OpdVisits
     * const opdVisit = await prisma.opdVisit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OpdVisits and only return the `id`
     * const opdVisitWithIdOnly = await prisma.opdVisit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OpdVisitCreateManyAndReturnArgs>(args?: SelectSubset<T, OpdVisitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OpdVisit.
     * @param {OpdVisitDeleteArgs} args - Arguments to delete one OpdVisit.
     * @example
     * // Delete one OpdVisit
     * const OpdVisit = await prisma.opdVisit.delete({
     *   where: {
     *     // ... filter to delete one OpdVisit
     *   }
     * })
     * 
     */
    delete<T extends OpdVisitDeleteArgs>(args: SelectSubset<T, OpdVisitDeleteArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OpdVisit.
     * @param {OpdVisitUpdateArgs} args - Arguments to update one OpdVisit.
     * @example
     * // Update one OpdVisit
     * const opdVisit = await prisma.opdVisit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpdVisitUpdateArgs>(args: SelectSubset<T, OpdVisitUpdateArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OpdVisits.
     * @param {OpdVisitDeleteManyArgs} args - Arguments to filter OpdVisits to delete.
     * @example
     * // Delete a few OpdVisits
     * const { count } = await prisma.opdVisit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpdVisitDeleteManyArgs>(args?: SelectSubset<T, OpdVisitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpdVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OpdVisits
     * const opdVisit = await prisma.opdVisit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpdVisitUpdateManyArgs>(args: SelectSubset<T, OpdVisitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OpdVisits and returns the data updated in the database.
     * @param {OpdVisitUpdateManyAndReturnArgs} args - Arguments to update many OpdVisits.
     * @example
     * // Update many OpdVisits
     * const opdVisit = await prisma.opdVisit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OpdVisits and only return the `id`
     * const opdVisitWithIdOnly = await prisma.opdVisit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OpdVisitUpdateManyAndReturnArgs>(args: SelectSubset<T, OpdVisitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OpdVisit.
     * @param {OpdVisitUpsertArgs} args - Arguments to update or create a OpdVisit.
     * @example
     * // Update or create a OpdVisit
     * const opdVisit = await prisma.opdVisit.upsert({
     *   create: {
     *     // ... data to create a OpdVisit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OpdVisit we want to update
     *   }
     * })
     */
    upsert<T extends OpdVisitUpsertArgs>(args: SelectSubset<T, OpdVisitUpsertArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OpdVisits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitCountArgs} args - Arguments to filter OpdVisits to count.
     * @example
     * // Count the number of OpdVisits
     * const count = await prisma.opdVisit.count({
     *   where: {
     *     // ... the filter for the OpdVisits we want to count
     *   }
     * })
    **/
    count<T extends OpdVisitCountArgs>(
      args?: Subset<T, OpdVisitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpdVisitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OpdVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpdVisitAggregateArgs>(args: Subset<T, OpdVisitAggregateArgs>): Prisma.PrismaPromise<GetOpdVisitAggregateType<T>>

    /**
     * Group by OpdVisit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpdVisitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpdVisitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpdVisitGroupByArgs['orderBy'] }
        : { orderBy?: OpdVisitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpdVisitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpdVisitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OpdVisit model
   */
  readonly fields: OpdVisitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OpdVisit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpdVisitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends OpdVisit$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clinicalNotes<T extends OpdVisit$clinicalNotesArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$clinicalNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrders<T extends OpdVisit$serviceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$serviceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends OpdVisit$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends OpdVisit$documentsArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends OpdVisit$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    admission<T extends OpdVisit$admissionArgs<ExtArgs> = {}>(args?: Subset<T, OpdVisit$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OpdVisit model
   */
  interface OpdVisitFieldRefs {
    readonly id: FieldRef<"OpdVisit", 'String'>
    readonly appointmentId: FieldRef<"OpdVisit", 'String'>
    readonly patientId: FieldRef<"OpdVisit", 'String'>
    readonly doctorId: FieldRef<"OpdVisit", 'String'>
    readonly visitDate: FieldRef<"OpdVisit", 'DateTime'>
    readonly visitType: FieldRef<"OpdVisit", 'VisitType'>
    readonly triageColor: FieldRef<"OpdVisit", 'TriageColor'>
    readonly status: FieldRef<"OpdVisit", 'VisitStatus'>
    readonly isMedicoLegal: FieldRef<"OpdVisit", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * OpdVisit findUnique
   */
  export type OpdVisitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter, which OpdVisit to fetch.
     */
    where: OpdVisitWhereUniqueInput
  }

  /**
   * OpdVisit findUniqueOrThrow
   */
  export type OpdVisitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter, which OpdVisit to fetch.
     */
    where: OpdVisitWhereUniqueInput
  }

  /**
   * OpdVisit findFirst
   */
  export type OpdVisitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter, which OpdVisit to fetch.
     */
    where?: OpdVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpdVisits to fetch.
     */
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpdVisits.
     */
    cursor?: OpdVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpdVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpdVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpdVisits.
     */
    distinct?: OpdVisitScalarFieldEnum | OpdVisitScalarFieldEnum[]
  }

  /**
   * OpdVisit findFirstOrThrow
   */
  export type OpdVisitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter, which OpdVisit to fetch.
     */
    where?: OpdVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpdVisits to fetch.
     */
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OpdVisits.
     */
    cursor?: OpdVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpdVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpdVisits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OpdVisits.
     */
    distinct?: OpdVisitScalarFieldEnum | OpdVisitScalarFieldEnum[]
  }

  /**
   * OpdVisit findMany
   */
  export type OpdVisitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter, which OpdVisits to fetch.
     */
    where?: OpdVisitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OpdVisits to fetch.
     */
    orderBy?: OpdVisitOrderByWithRelationInput | OpdVisitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OpdVisits.
     */
    cursor?: OpdVisitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OpdVisits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OpdVisits.
     */
    skip?: number
    distinct?: OpdVisitScalarFieldEnum | OpdVisitScalarFieldEnum[]
  }

  /**
   * OpdVisit create
   */
  export type OpdVisitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * The data needed to create a OpdVisit.
     */
    data: XOR<OpdVisitCreateInput, OpdVisitUncheckedCreateInput>
  }

  /**
   * OpdVisit createMany
   */
  export type OpdVisitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OpdVisits.
     */
    data: OpdVisitCreateManyInput | OpdVisitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OpdVisit createManyAndReturn
   */
  export type OpdVisitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * The data used to create many OpdVisits.
     */
    data: OpdVisitCreateManyInput | OpdVisitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpdVisit update
   */
  export type OpdVisitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * The data needed to update a OpdVisit.
     */
    data: XOR<OpdVisitUpdateInput, OpdVisitUncheckedUpdateInput>
    /**
     * Choose, which OpdVisit to update.
     */
    where: OpdVisitWhereUniqueInput
  }

  /**
   * OpdVisit updateMany
   */
  export type OpdVisitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OpdVisits.
     */
    data: XOR<OpdVisitUpdateManyMutationInput, OpdVisitUncheckedUpdateManyInput>
    /**
     * Filter which OpdVisits to update
     */
    where?: OpdVisitWhereInput
    /**
     * Limit how many OpdVisits to update.
     */
    limit?: number
  }

  /**
   * OpdVisit updateManyAndReturn
   */
  export type OpdVisitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * The data used to update OpdVisits.
     */
    data: XOR<OpdVisitUpdateManyMutationInput, OpdVisitUncheckedUpdateManyInput>
    /**
     * Filter which OpdVisits to update
     */
    where?: OpdVisitWhereInput
    /**
     * Limit how many OpdVisits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OpdVisit upsert
   */
  export type OpdVisitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * The filter to search for the OpdVisit to update in case it exists.
     */
    where: OpdVisitWhereUniqueInput
    /**
     * In case the OpdVisit found by the `where` argument doesn't exist, create a new OpdVisit with this data.
     */
    create: XOR<OpdVisitCreateInput, OpdVisitUncheckedCreateInput>
    /**
     * In case the OpdVisit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpdVisitUpdateInput, OpdVisitUncheckedUpdateInput>
  }

  /**
   * OpdVisit delete
   */
  export type OpdVisitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    /**
     * Filter which OpdVisit to delete.
     */
    where: OpdVisitWhereUniqueInput
  }

  /**
   * OpdVisit deleteMany
   */
  export type OpdVisitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OpdVisits to delete
     */
    where?: OpdVisitWhereInput
    /**
     * Limit how many OpdVisits to delete.
     */
    limit?: number
  }

  /**
   * OpdVisit.appointment
   */
  export type OpdVisit$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Appointment
     */
    omit?: AppointmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * OpdVisit.clinicalNotes
   */
  export type OpdVisit$clinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * OpdVisit.serviceOrders
   */
  export type OpdVisit$serviceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * OpdVisit.prescriptions
   */
  export type OpdVisit$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * OpdVisit.documents
   */
  export type OpdVisit$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    where?: PatientDocumentWhereInput
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    cursor?: PatientDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * OpdVisit.invoices
   */
  export type OpdVisit$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * OpdVisit.admission
   */
  export type OpdVisit$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * OpdVisit without action
   */
  export type OpdVisitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
  }


  /**
   * Model Admission
   */

  export type AggregateAdmission = {
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  export type AdmissionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    admittingDoctorId: string | null
    departmentId: string | null
    visitId: string | null
    currentBedId: string | null
    admissionDate: Date | null
    dischargeDate: Date | null
    reasonForAdmission: string | null
    admissionType: $Enums.AdmissionType | null
    status: $Enums.AdmissionStatus | null
    dischargeType: $Enums.DischargeType | null
    mlc: boolean | null
  }

  export type AdmissionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    admittingDoctorId: string | null
    departmentId: string | null
    visitId: string | null
    currentBedId: string | null
    admissionDate: Date | null
    dischargeDate: Date | null
    reasonForAdmission: string | null
    admissionType: $Enums.AdmissionType | null
    status: $Enums.AdmissionStatus | null
    dischargeType: $Enums.DischargeType | null
    mlc: boolean | null
  }

  export type AdmissionCountAggregateOutputType = {
    id: number
    patientId: number
    admittingDoctorId: number
    departmentId: number
    visitId: number
    currentBedId: number
    admissionDate: number
    dischargeDate: number
    reasonForAdmission: number
    admissionType: number
    status: number
    dischargeType: number
    mlc: number
    _all: number
  }


  export type AdmissionMinAggregateInputType = {
    id?: true
    patientId?: true
    admittingDoctorId?: true
    departmentId?: true
    visitId?: true
    currentBedId?: true
    admissionDate?: true
    dischargeDate?: true
    reasonForAdmission?: true
    admissionType?: true
    status?: true
    dischargeType?: true
    mlc?: true
  }

  export type AdmissionMaxAggregateInputType = {
    id?: true
    patientId?: true
    admittingDoctorId?: true
    departmentId?: true
    visitId?: true
    currentBedId?: true
    admissionDate?: true
    dischargeDate?: true
    reasonForAdmission?: true
    admissionType?: true
    status?: true
    dischargeType?: true
    mlc?: true
  }

  export type AdmissionCountAggregateInputType = {
    id?: true
    patientId?: true
    admittingDoctorId?: true
    departmentId?: true
    visitId?: true
    currentBedId?: true
    admissionDate?: true
    dischargeDate?: true
    reasonForAdmission?: true
    admissionType?: true
    status?: true
    dischargeType?: true
    mlc?: true
    _all?: true
  }

  export type AdmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admission to aggregate.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admissions
    **/
    _count?: true | AdmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdmissionMaxAggregateInputType
  }

  export type GetAdmissionAggregateType<T extends AdmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmission[P]>
      : GetScalarType<T[P], AggregateAdmission[P]>
  }




  export type AdmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdmissionWhereInput
    orderBy?: AdmissionOrderByWithAggregationInput | AdmissionOrderByWithAggregationInput[]
    by: AdmissionScalarFieldEnum[] | AdmissionScalarFieldEnum
    having?: AdmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdmissionCountAggregateInputType | true
    _min?: AdmissionMinAggregateInputType
    _max?: AdmissionMaxAggregateInputType
  }

  export type AdmissionGroupByOutputType = {
    id: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId: string | null
    currentBedId: string | null
    admissionDate: Date
    dischargeDate: Date | null
    reasonForAdmission: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType: $Enums.DischargeType | null
    mlc: boolean
    _count: AdmissionCountAggregateOutputType | null
    _min: AdmissionMinAggregateOutputType | null
    _max: AdmissionMaxAggregateOutputType | null
  }

  type GetAdmissionGroupByPayload<T extends AdmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
            : GetScalarType<T[P], AdmissionGroupByOutputType[P]>
        }
      >
    >


  export type AdmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admittingDoctorId?: boolean
    departmentId?: boolean
    visitId?: boolean
    currentBedId?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    reasonForAdmission?: boolean
    admissionType?: boolean
    status?: boolean
    dischargeType?: boolean
    mlc?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
    bedTransfers?: boolean | Admission$bedTransfersArgs<ExtArgs>
    surgeries?: boolean | Admission$surgeriesArgs<ExtArgs>
    clinicalNotes?: boolean | Admission$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | Admission$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | Admission$prescriptionsArgs<ExtArgs>
    documents?: boolean | Admission$documentsArgs<ExtArgs>
    invoices?: boolean | Admission$invoicesArgs<ExtArgs>
    insuranceClaims?: boolean | Admission$insuranceClaimsArgs<ExtArgs>
    _count?: boolean | AdmissionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admittingDoctorId?: boolean
    departmentId?: boolean
    visitId?: boolean
    currentBedId?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    reasonForAdmission?: boolean
    admissionType?: boolean
    status?: boolean
    dischargeType?: boolean
    mlc?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admittingDoctorId?: boolean
    departmentId?: boolean
    visitId?: boolean
    currentBedId?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    reasonForAdmission?: boolean
    admissionType?: boolean
    status?: boolean
    dischargeType?: boolean
    mlc?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
  }, ExtArgs["result"]["admission"]>

  export type AdmissionSelectScalar = {
    id?: boolean
    patientId?: boolean
    admittingDoctorId?: boolean
    departmentId?: boolean
    visitId?: boolean
    currentBedId?: boolean
    admissionDate?: boolean
    dischargeDate?: boolean
    reasonForAdmission?: boolean
    admissionType?: boolean
    status?: boolean
    dischargeType?: boolean
    mlc?: boolean
  }

  export type AdmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "admittingDoctorId" | "departmentId" | "visitId" | "currentBedId" | "admissionDate" | "dischargeDate" | "reasonForAdmission" | "admissionType" | "status" | "dischargeType" | "mlc", ExtArgs["result"]["admission"]>
  export type AdmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
    bedTransfers?: boolean | Admission$bedTransfersArgs<ExtArgs>
    surgeries?: boolean | Admission$surgeriesArgs<ExtArgs>
    clinicalNotes?: boolean | Admission$clinicalNotesArgs<ExtArgs>
    serviceOrders?: boolean | Admission$serviceOrdersArgs<ExtArgs>
    prescriptions?: boolean | Admission$prescriptionsArgs<ExtArgs>
    documents?: boolean | Admission$documentsArgs<ExtArgs>
    invoices?: boolean | Admission$invoicesArgs<ExtArgs>
    insuranceClaims?: boolean | Admission$insuranceClaimsArgs<ExtArgs>
    _count?: boolean | AdmissionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AdmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
  }
  export type AdmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admittingDoctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    visit?: boolean | Admission$visitArgs<ExtArgs>
    currentBed?: boolean | Admission$currentBedArgs<ExtArgs>
  }

  export type $AdmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admission"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      admittingDoctor: Prisma.$StaffProfilePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      currentBed: Prisma.$BedPayload<ExtArgs> | null
      bedTransfers: Prisma.$BedTransferPayload<ExtArgs>[]
      surgeries: Prisma.$SurgeryPayload<ExtArgs>[]
      clinicalNotes: Prisma.$ClinicalNotePayload<ExtArgs>[]
      serviceOrders: Prisma.$ServiceOrderPayload<ExtArgs>[]
      prescriptions: Prisma.$PrescriptionPayload<ExtArgs>[]
      documents: Prisma.$PatientDocumentPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      insuranceClaims: Prisma.$InsuranceClaimPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      admittingDoctorId: string
      departmentId: string
      visitId: string | null
      currentBedId: string | null
      admissionDate: Date
      dischargeDate: Date | null
      reasonForAdmission: string | null
      admissionType: $Enums.AdmissionType
      status: $Enums.AdmissionStatus
      dischargeType: $Enums.DischargeType | null
      mlc: boolean
    }, ExtArgs["result"]["admission"]>
    composites: {}
  }

  type AdmissionGetPayload<S extends boolean | null | undefined | AdmissionDefaultArgs> = $Result.GetResult<Prisma.$AdmissionPayload, S>

  type AdmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdmissionCountAggregateInputType | true
    }

  export interface AdmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admission'], meta: { name: 'Admission' } }
    /**
     * Find zero or one Admission that matches the filter.
     * @param {AdmissionFindUniqueArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdmissionFindUniqueArgs>(args: SelectSubset<T, AdmissionFindUniqueArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdmissionFindUniqueOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, AdmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdmissionFindFirstArgs>(args?: SelectSubset<T, AdmissionFindFirstArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindFirstOrThrowArgs} args - Arguments to find a Admission
     * @example
     * // Get one Admission
     * const admission = await prisma.admission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, AdmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admissions
     * const admissions = await prisma.admission.findMany()
     * 
     * // Get first 10 Admissions
     * const admissions = await prisma.admission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const admissionWithIdOnly = await prisma.admission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdmissionFindManyArgs>(args?: SelectSubset<T, AdmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admission.
     * @param {AdmissionCreateArgs} args - Arguments to create a Admission.
     * @example
     * // Create one Admission
     * const Admission = await prisma.admission.create({
     *   data: {
     *     // ... data to create a Admission
     *   }
     * })
     * 
     */
    create<T extends AdmissionCreateArgs>(args: SelectSubset<T, AdmissionCreateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admissions.
     * @param {AdmissionCreateManyArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdmissionCreateManyArgs>(args?: SelectSubset<T, AdmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Admissions and returns the data saved in the database.
     * @param {AdmissionCreateManyAndReturnArgs} args - Arguments to create many Admissions.
     * @example
     * // Create many Admissions
     * const admission = await prisma.admission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, AdmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Admission.
     * @param {AdmissionDeleteArgs} args - Arguments to delete one Admission.
     * @example
     * // Delete one Admission
     * const Admission = await prisma.admission.delete({
     *   where: {
     *     // ... filter to delete one Admission
     *   }
     * })
     * 
     */
    delete<T extends AdmissionDeleteArgs>(args: SelectSubset<T, AdmissionDeleteArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admission.
     * @param {AdmissionUpdateArgs} args - Arguments to update one Admission.
     * @example
     * // Update one Admission
     * const admission = await prisma.admission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdmissionUpdateArgs>(args: SelectSubset<T, AdmissionUpdateArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admissions.
     * @param {AdmissionDeleteManyArgs} args - Arguments to filter Admissions to delete.
     * @example
     * // Delete a few Admissions
     * const { count } = await prisma.admission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdmissionDeleteManyArgs>(args?: SelectSubset<T, AdmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdmissionUpdateManyArgs>(args: SelectSubset<T, AdmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admissions and returns the data updated in the database.
     * @param {AdmissionUpdateManyAndReturnArgs} args - Arguments to update many Admissions.
     * @example
     * // Update many Admissions
     * const admission = await prisma.admission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Admissions and only return the `id`
     * const admissionWithIdOnly = await prisma.admission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, AdmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Admission.
     * @param {AdmissionUpsertArgs} args - Arguments to update or create a Admission.
     * @example
     * // Update or create a Admission
     * const admission = await prisma.admission.upsert({
     *   create: {
     *     // ... data to create a Admission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admission we want to update
     *   }
     * })
     */
    upsert<T extends AdmissionUpsertArgs>(args: SelectSubset<T, AdmissionUpsertArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Admissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionCountArgs} args - Arguments to filter Admissions to count.
     * @example
     * // Count the number of Admissions
     * const count = await prisma.admission.count({
     *   where: {
     *     // ... the filter for the Admissions we want to count
     *   }
     * })
    **/
    count<T extends AdmissionCountArgs>(
      args?: Subset<T, AdmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdmissionAggregateArgs>(args: Subset<T, AdmissionAggregateArgs>): Prisma.PrismaPromise<GetAdmissionAggregateType<T>>

    /**
     * Group by Admission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdmissionGroupByArgs['orderBy'] }
        : { orderBy?: AdmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admission model
   */
  readonly fields: AdmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admittingDoctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visit<T extends Admission$visitArgs<ExtArgs> = {}>(args?: Subset<T, Admission$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currentBed<T extends Admission$currentBedArgs<ExtArgs> = {}>(args?: Subset<T, Admission$currentBedArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bedTransfers<T extends Admission$bedTransfersArgs<ExtArgs> = {}>(args?: Subset<T, Admission$bedTransfersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surgeries<T extends Admission$surgeriesArgs<ExtArgs> = {}>(args?: Subset<T, Admission$surgeriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clinicalNotes<T extends Admission$clinicalNotesArgs<ExtArgs> = {}>(args?: Subset<T, Admission$clinicalNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceOrders<T extends Admission$serviceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Admission$serviceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prescriptions<T extends Admission$prescriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Admission$prescriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Admission$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Admission$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Admission$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Admission$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    insuranceClaims<T extends Admission$insuranceClaimsArgs<ExtArgs> = {}>(args?: Subset<T, Admission$insuranceClaimsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admission model
   */
  interface AdmissionFieldRefs {
    readonly id: FieldRef<"Admission", 'String'>
    readonly patientId: FieldRef<"Admission", 'String'>
    readonly admittingDoctorId: FieldRef<"Admission", 'String'>
    readonly departmentId: FieldRef<"Admission", 'String'>
    readonly visitId: FieldRef<"Admission", 'String'>
    readonly currentBedId: FieldRef<"Admission", 'String'>
    readonly admissionDate: FieldRef<"Admission", 'DateTime'>
    readonly dischargeDate: FieldRef<"Admission", 'DateTime'>
    readonly reasonForAdmission: FieldRef<"Admission", 'String'>
    readonly admissionType: FieldRef<"Admission", 'AdmissionType'>
    readonly status: FieldRef<"Admission", 'AdmissionStatus'>
    readonly dischargeType: FieldRef<"Admission", 'DischargeType'>
    readonly mlc: FieldRef<"Admission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Admission findUnique
   */
  export type AdmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findUniqueOrThrow
   */
  export type AdmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission findFirst
   */
  export type AdmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findFirstOrThrow
   */
  export type AdmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admission to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admissions.
     */
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission findMany
   */
  export type AdmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter, which Admissions to fetch.
     */
    where?: AdmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admissions to fetch.
     */
    orderBy?: AdmissionOrderByWithRelationInput | AdmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admissions.
     */
    cursor?: AdmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admissions.
     */
    skip?: number
    distinct?: AdmissionScalarFieldEnum | AdmissionScalarFieldEnum[]
  }

  /**
   * Admission create
   */
  export type AdmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Admission.
     */
    data: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
  }

  /**
   * Admission createMany
   */
  export type AdmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Admission createManyAndReturn
   */
  export type AdmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * The data used to create many Admissions.
     */
    data: AdmissionCreateManyInput | AdmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission update
   */
  export type AdmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Admission.
     */
    data: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
    /**
     * Choose, which Admission to update.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission updateMany
   */
  export type AdmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to update.
     */
    limit?: number
  }

  /**
   * Admission updateManyAndReturn
   */
  export type AdmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * The data used to update Admissions.
     */
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyInput>
    /**
     * Filter which Admissions to update
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Admission upsert
   */
  export type AdmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Admission to update in case it exists.
     */
    where: AdmissionWhereUniqueInput
    /**
     * In case the Admission found by the `where` argument doesn't exist, create a new Admission with this data.
     */
    create: XOR<AdmissionCreateInput, AdmissionUncheckedCreateInput>
    /**
     * In case the Admission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdmissionUpdateInput, AdmissionUncheckedUpdateInput>
  }

  /**
   * Admission delete
   */
  export type AdmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    /**
     * Filter which Admission to delete.
     */
    where: AdmissionWhereUniqueInput
  }

  /**
   * Admission deleteMany
   */
  export type AdmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admissions to delete
     */
    where?: AdmissionWhereInput
    /**
     * Limit how many Admissions to delete.
     */
    limit?: number
  }

  /**
   * Admission.visit
   */
  export type Admission$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * Admission.currentBed
   */
  export type Admission$currentBedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bed
     */
    select?: BedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bed
     */
    omit?: BedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedInclude<ExtArgs> | null
    where?: BedWhereInput
  }

  /**
   * Admission.bedTransfers
   */
  export type Admission$bedTransfersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    where?: BedTransferWhereInput
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    cursor?: BedTransferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BedTransferScalarFieldEnum | BedTransferScalarFieldEnum[]
  }

  /**
   * Admission.surgeries
   */
  export type Admission$surgeriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    where?: SurgeryWhereInput
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    cursor?: SurgeryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Admission.clinicalNotes
   */
  export type Admission$clinicalNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    cursor?: ClinicalNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * Admission.serviceOrders
   */
  export type Admission$serviceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    cursor?: ServiceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * Admission.prescriptions
   */
  export type Admission$prescriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    cursor?: PrescriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Admission.documents
   */
  export type Admission$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientDocument
     */
    select?: PatientDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatientDocument
     */
    omit?: PatientDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientDocumentInclude<ExtArgs> | null
    where?: PatientDocumentWhereInput
    orderBy?: PatientDocumentOrderByWithRelationInput | PatientDocumentOrderByWithRelationInput[]
    cursor?: PatientDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientDocumentScalarFieldEnum | PatientDocumentScalarFieldEnum[]
  }

  /**
   * Admission.invoices
   */
  export type Admission$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Admission.insuranceClaims
   */
  export type Admission$insuranceClaimsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    where?: InsuranceClaimWhereInput
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    cursor?: InsuranceClaimWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * Admission without action
   */
  export type AdmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
  }


  /**
   * Model BedTransfer
   */

  export type AggregateBedTransfer = {
    _count: BedTransferCountAggregateOutputType | null
    _min: BedTransferMinAggregateOutputType | null
    _max: BedTransferMaxAggregateOutputType | null
  }

  export type BedTransferMinAggregateOutputType = {
    id: string | null
    admissionId: string | null
    bedId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
  }

  export type BedTransferMaxAggregateOutputType = {
    id: string | null
    admissionId: string | null
    bedId: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
  }

  export type BedTransferCountAggregateOutputType = {
    id: number
    admissionId: number
    bedId: number
    startDate: number
    endDate: number
    reason: number
    _all: number
  }


  export type BedTransferMinAggregateInputType = {
    id?: true
    admissionId?: true
    bedId?: true
    startDate?: true
    endDate?: true
    reason?: true
  }

  export type BedTransferMaxAggregateInputType = {
    id?: true
    admissionId?: true
    bedId?: true
    startDate?: true
    endDate?: true
    reason?: true
  }

  export type BedTransferCountAggregateInputType = {
    id?: true
    admissionId?: true
    bedId?: true
    startDate?: true
    endDate?: true
    reason?: true
    _all?: true
  }

  export type BedTransferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedTransfer to aggregate.
     */
    where?: BedTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTransfers to fetch.
     */
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BedTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BedTransfers
    **/
    _count?: true | BedTransferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BedTransferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BedTransferMaxAggregateInputType
  }

  export type GetBedTransferAggregateType<T extends BedTransferAggregateArgs> = {
        [P in keyof T & keyof AggregateBedTransfer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBedTransfer[P]>
      : GetScalarType<T[P], AggregateBedTransfer[P]>
  }




  export type BedTransferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BedTransferWhereInput
    orderBy?: BedTransferOrderByWithAggregationInput | BedTransferOrderByWithAggregationInput[]
    by: BedTransferScalarFieldEnum[] | BedTransferScalarFieldEnum
    having?: BedTransferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BedTransferCountAggregateInputType | true
    _min?: BedTransferMinAggregateInputType
    _max?: BedTransferMaxAggregateInputType
  }

  export type BedTransferGroupByOutputType = {
    id: string
    admissionId: string
    bedId: string
    startDate: Date
    endDate: Date | null
    reason: string | null
    _count: BedTransferCountAggregateOutputType | null
    _min: BedTransferMinAggregateOutputType | null
    _max: BedTransferMaxAggregateOutputType | null
  }

  type GetBedTransferGroupByPayload<T extends BedTransferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BedTransferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BedTransferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BedTransferGroupByOutputType[P]>
            : GetScalarType<T[P], BedTransferGroupByOutputType[P]>
        }
      >
    >


  export type BedTransferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    bedId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bedTransfer"]>

  export type BedTransferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    bedId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bedTransfer"]>

  export type BedTransferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    bedId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bedTransfer"]>

  export type BedTransferSelectScalar = {
    id?: boolean
    admissionId?: boolean
    bedId?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
  }

  export type BedTransferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admissionId" | "bedId" | "startDate" | "endDate" | "reason", ExtArgs["result"]["bedTransfer"]>
  export type BedTransferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }
  export type BedTransferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }
  export type BedTransferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    bed?: boolean | BedDefaultArgs<ExtArgs>
  }

  export type $BedTransferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BedTransfer"
    objects: {
      admission: Prisma.$AdmissionPayload<ExtArgs>
      bed: Prisma.$BedPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admissionId: string
      bedId: string
      startDate: Date
      endDate: Date | null
      reason: string | null
    }, ExtArgs["result"]["bedTransfer"]>
    composites: {}
  }

  type BedTransferGetPayload<S extends boolean | null | undefined | BedTransferDefaultArgs> = $Result.GetResult<Prisma.$BedTransferPayload, S>

  type BedTransferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BedTransferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BedTransferCountAggregateInputType | true
    }

  export interface BedTransferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BedTransfer'], meta: { name: 'BedTransfer' } }
    /**
     * Find zero or one BedTransfer that matches the filter.
     * @param {BedTransferFindUniqueArgs} args - Arguments to find a BedTransfer
     * @example
     * // Get one BedTransfer
     * const bedTransfer = await prisma.bedTransfer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BedTransferFindUniqueArgs>(args: SelectSubset<T, BedTransferFindUniqueArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BedTransfer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BedTransferFindUniqueOrThrowArgs} args - Arguments to find a BedTransfer
     * @example
     * // Get one BedTransfer
     * const bedTransfer = await prisma.bedTransfer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BedTransferFindUniqueOrThrowArgs>(args: SelectSubset<T, BedTransferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedTransfer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferFindFirstArgs} args - Arguments to find a BedTransfer
     * @example
     * // Get one BedTransfer
     * const bedTransfer = await prisma.bedTransfer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BedTransferFindFirstArgs>(args?: SelectSubset<T, BedTransferFindFirstArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BedTransfer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferFindFirstOrThrowArgs} args - Arguments to find a BedTransfer
     * @example
     * // Get one BedTransfer
     * const bedTransfer = await prisma.bedTransfer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BedTransferFindFirstOrThrowArgs>(args?: SelectSubset<T, BedTransferFindFirstOrThrowArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BedTransfers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BedTransfers
     * const bedTransfers = await prisma.bedTransfer.findMany()
     * 
     * // Get first 10 BedTransfers
     * const bedTransfers = await prisma.bedTransfer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bedTransferWithIdOnly = await prisma.bedTransfer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BedTransferFindManyArgs>(args?: SelectSubset<T, BedTransferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BedTransfer.
     * @param {BedTransferCreateArgs} args - Arguments to create a BedTransfer.
     * @example
     * // Create one BedTransfer
     * const BedTransfer = await prisma.bedTransfer.create({
     *   data: {
     *     // ... data to create a BedTransfer
     *   }
     * })
     * 
     */
    create<T extends BedTransferCreateArgs>(args: SelectSubset<T, BedTransferCreateArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BedTransfers.
     * @param {BedTransferCreateManyArgs} args - Arguments to create many BedTransfers.
     * @example
     * // Create many BedTransfers
     * const bedTransfer = await prisma.bedTransfer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BedTransferCreateManyArgs>(args?: SelectSubset<T, BedTransferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BedTransfers and returns the data saved in the database.
     * @param {BedTransferCreateManyAndReturnArgs} args - Arguments to create many BedTransfers.
     * @example
     * // Create many BedTransfers
     * const bedTransfer = await prisma.bedTransfer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BedTransfers and only return the `id`
     * const bedTransferWithIdOnly = await prisma.bedTransfer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BedTransferCreateManyAndReturnArgs>(args?: SelectSubset<T, BedTransferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BedTransfer.
     * @param {BedTransferDeleteArgs} args - Arguments to delete one BedTransfer.
     * @example
     * // Delete one BedTransfer
     * const BedTransfer = await prisma.bedTransfer.delete({
     *   where: {
     *     // ... filter to delete one BedTransfer
     *   }
     * })
     * 
     */
    delete<T extends BedTransferDeleteArgs>(args: SelectSubset<T, BedTransferDeleteArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BedTransfer.
     * @param {BedTransferUpdateArgs} args - Arguments to update one BedTransfer.
     * @example
     * // Update one BedTransfer
     * const bedTransfer = await prisma.bedTransfer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BedTransferUpdateArgs>(args: SelectSubset<T, BedTransferUpdateArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BedTransfers.
     * @param {BedTransferDeleteManyArgs} args - Arguments to filter BedTransfers to delete.
     * @example
     * // Delete a few BedTransfers
     * const { count } = await prisma.bedTransfer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BedTransferDeleteManyArgs>(args?: SelectSubset<T, BedTransferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BedTransfers
     * const bedTransfer = await prisma.bedTransfer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BedTransferUpdateManyArgs>(args: SelectSubset<T, BedTransferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BedTransfers and returns the data updated in the database.
     * @param {BedTransferUpdateManyAndReturnArgs} args - Arguments to update many BedTransfers.
     * @example
     * // Update many BedTransfers
     * const bedTransfer = await prisma.bedTransfer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BedTransfers and only return the `id`
     * const bedTransferWithIdOnly = await prisma.bedTransfer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BedTransferUpdateManyAndReturnArgs>(args: SelectSubset<T, BedTransferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BedTransfer.
     * @param {BedTransferUpsertArgs} args - Arguments to update or create a BedTransfer.
     * @example
     * // Update or create a BedTransfer
     * const bedTransfer = await prisma.bedTransfer.upsert({
     *   create: {
     *     // ... data to create a BedTransfer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BedTransfer we want to update
     *   }
     * })
     */
    upsert<T extends BedTransferUpsertArgs>(args: SelectSubset<T, BedTransferUpsertArgs<ExtArgs>>): Prisma__BedTransferClient<$Result.GetResult<Prisma.$BedTransferPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BedTransfers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferCountArgs} args - Arguments to filter BedTransfers to count.
     * @example
     * // Count the number of BedTransfers
     * const count = await prisma.bedTransfer.count({
     *   where: {
     *     // ... the filter for the BedTransfers we want to count
     *   }
     * })
    **/
    count<T extends BedTransferCountArgs>(
      args?: Subset<T, BedTransferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BedTransferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BedTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BedTransferAggregateArgs>(args: Subset<T, BedTransferAggregateArgs>): Prisma.PrismaPromise<GetBedTransferAggregateType<T>>

    /**
     * Group by BedTransfer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BedTransferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BedTransferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BedTransferGroupByArgs['orderBy'] }
        : { orderBy?: BedTransferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BedTransferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBedTransferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BedTransfer model
   */
  readonly fields: BedTransferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BedTransfer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BedTransferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admission<T extends AdmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionDefaultArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bed<T extends BedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BedDefaultArgs<ExtArgs>>): Prisma__BedClient<$Result.GetResult<Prisma.$BedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BedTransfer model
   */
  interface BedTransferFieldRefs {
    readonly id: FieldRef<"BedTransfer", 'String'>
    readonly admissionId: FieldRef<"BedTransfer", 'String'>
    readonly bedId: FieldRef<"BedTransfer", 'String'>
    readonly startDate: FieldRef<"BedTransfer", 'DateTime'>
    readonly endDate: FieldRef<"BedTransfer", 'DateTime'>
    readonly reason: FieldRef<"BedTransfer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BedTransfer findUnique
   */
  export type BedTransferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter, which BedTransfer to fetch.
     */
    where: BedTransferWhereUniqueInput
  }

  /**
   * BedTransfer findUniqueOrThrow
   */
  export type BedTransferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter, which BedTransfer to fetch.
     */
    where: BedTransferWhereUniqueInput
  }

  /**
   * BedTransfer findFirst
   */
  export type BedTransferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter, which BedTransfer to fetch.
     */
    where?: BedTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTransfers to fetch.
     */
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedTransfers.
     */
    cursor?: BedTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedTransfers.
     */
    distinct?: BedTransferScalarFieldEnum | BedTransferScalarFieldEnum[]
  }

  /**
   * BedTransfer findFirstOrThrow
   */
  export type BedTransferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter, which BedTransfer to fetch.
     */
    where?: BedTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTransfers to fetch.
     */
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BedTransfers.
     */
    cursor?: BedTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTransfers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BedTransfers.
     */
    distinct?: BedTransferScalarFieldEnum | BedTransferScalarFieldEnum[]
  }

  /**
   * BedTransfer findMany
   */
  export type BedTransferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter, which BedTransfers to fetch.
     */
    where?: BedTransferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BedTransfers to fetch.
     */
    orderBy?: BedTransferOrderByWithRelationInput | BedTransferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BedTransfers.
     */
    cursor?: BedTransferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BedTransfers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BedTransfers.
     */
    skip?: number
    distinct?: BedTransferScalarFieldEnum | BedTransferScalarFieldEnum[]
  }

  /**
   * BedTransfer create
   */
  export type BedTransferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * The data needed to create a BedTransfer.
     */
    data: XOR<BedTransferCreateInput, BedTransferUncheckedCreateInput>
  }

  /**
   * BedTransfer createMany
   */
  export type BedTransferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BedTransfers.
     */
    data: BedTransferCreateManyInput | BedTransferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BedTransfer createManyAndReturn
   */
  export type BedTransferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * The data used to create many BedTransfers.
     */
    data: BedTransferCreateManyInput | BedTransferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BedTransfer update
   */
  export type BedTransferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * The data needed to update a BedTransfer.
     */
    data: XOR<BedTransferUpdateInput, BedTransferUncheckedUpdateInput>
    /**
     * Choose, which BedTransfer to update.
     */
    where: BedTransferWhereUniqueInput
  }

  /**
   * BedTransfer updateMany
   */
  export type BedTransferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BedTransfers.
     */
    data: XOR<BedTransferUpdateManyMutationInput, BedTransferUncheckedUpdateManyInput>
    /**
     * Filter which BedTransfers to update
     */
    where?: BedTransferWhereInput
    /**
     * Limit how many BedTransfers to update.
     */
    limit?: number
  }

  /**
   * BedTransfer updateManyAndReturn
   */
  export type BedTransferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * The data used to update BedTransfers.
     */
    data: XOR<BedTransferUpdateManyMutationInput, BedTransferUncheckedUpdateManyInput>
    /**
     * Filter which BedTransfers to update
     */
    where?: BedTransferWhereInput
    /**
     * Limit how many BedTransfers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BedTransfer upsert
   */
  export type BedTransferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * The filter to search for the BedTransfer to update in case it exists.
     */
    where: BedTransferWhereUniqueInput
    /**
     * In case the BedTransfer found by the `where` argument doesn't exist, create a new BedTransfer with this data.
     */
    create: XOR<BedTransferCreateInput, BedTransferUncheckedCreateInput>
    /**
     * In case the BedTransfer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BedTransferUpdateInput, BedTransferUncheckedUpdateInput>
  }

  /**
   * BedTransfer delete
   */
  export type BedTransferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
    /**
     * Filter which BedTransfer to delete.
     */
    where: BedTransferWhereUniqueInput
  }

  /**
   * BedTransfer deleteMany
   */
  export type BedTransferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BedTransfers to delete
     */
    where?: BedTransferWhereInput
    /**
     * Limit how many BedTransfers to delete.
     */
    limit?: number
  }

  /**
   * BedTransfer without action
   */
  export type BedTransferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BedTransfer
     */
    select?: BedTransferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BedTransfer
     */
    omit?: BedTransferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BedTransferInclude<ExtArgs> | null
  }


  /**
   * Model Surgery
   */

  export type AggregateSurgery = {
    _count: SurgeryCountAggregateOutputType | null
    _min: SurgeryMinAggregateOutputType | null
    _max: SurgeryMaxAggregateOutputType | null
  }

  export type SurgeryMinAggregateOutputType = {
    id: string | null
    admissionId: string | null
    procedureName: string | null
    surgeonId: string | null
    otRoomNumber: string | null
    surgeryDate: Date | null
    status: $Enums.SurgeryStatus | null
    notes: string | null
  }

  export type SurgeryMaxAggregateOutputType = {
    id: string | null
    admissionId: string | null
    procedureName: string | null
    surgeonId: string | null
    otRoomNumber: string | null
    surgeryDate: Date | null
    status: $Enums.SurgeryStatus | null
    notes: string | null
  }

  export type SurgeryCountAggregateOutputType = {
    id: number
    admissionId: number
    procedureName: number
    surgeonId: number
    otRoomNumber: number
    surgeryDate: number
    status: number
    notes: number
    _all: number
  }


  export type SurgeryMinAggregateInputType = {
    id?: true
    admissionId?: true
    procedureName?: true
    surgeonId?: true
    otRoomNumber?: true
    surgeryDate?: true
    status?: true
    notes?: true
  }

  export type SurgeryMaxAggregateInputType = {
    id?: true
    admissionId?: true
    procedureName?: true
    surgeonId?: true
    otRoomNumber?: true
    surgeryDate?: true
    status?: true
    notes?: true
  }

  export type SurgeryCountAggregateInputType = {
    id?: true
    admissionId?: true
    procedureName?: true
    surgeonId?: true
    otRoomNumber?: true
    surgeryDate?: true
    status?: true
    notes?: true
    _all?: true
  }

  export type SurgeryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surgery to aggregate.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Surgeries
    **/
    _count?: true | SurgeryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurgeryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurgeryMaxAggregateInputType
  }

  export type GetSurgeryAggregateType<T extends SurgeryAggregateArgs> = {
        [P in keyof T & keyof AggregateSurgery]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurgery[P]>
      : GetScalarType<T[P], AggregateSurgery[P]>
  }




  export type SurgeryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgeryWhereInput
    orderBy?: SurgeryOrderByWithAggregationInput | SurgeryOrderByWithAggregationInput[]
    by: SurgeryScalarFieldEnum[] | SurgeryScalarFieldEnum
    having?: SurgeryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurgeryCountAggregateInputType | true
    _min?: SurgeryMinAggregateInputType
    _max?: SurgeryMaxAggregateInputType
  }

  export type SurgeryGroupByOutputType = {
    id: string
    admissionId: string
    procedureName: string
    surgeonId: string
    otRoomNumber: string | null
    surgeryDate: Date
    status: $Enums.SurgeryStatus
    notes: string | null
    _count: SurgeryCountAggregateOutputType | null
    _min: SurgeryMinAggregateOutputType | null
    _max: SurgeryMaxAggregateOutputType | null
  }

  type GetSurgeryGroupByPayload<T extends SurgeryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurgeryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurgeryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurgeryGroupByOutputType[P]>
            : GetScalarType<T[P], SurgeryGroupByOutputType[P]>
        }
      >
    >


  export type SurgerySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    procedureName?: boolean
    surgeonId?: boolean
    otRoomNumber?: boolean
    surgeryDate?: boolean
    status?: boolean
    notes?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
    checklists?: boolean | Surgery$checklistsArgs<ExtArgs>
    surgerySStaffs?: boolean | Surgery$surgerySStaffsArgs<ExtArgs>
    _count?: boolean | SurgeryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    procedureName?: boolean
    surgeonId?: boolean
    otRoomNumber?: boolean
    surgeryDate?: boolean
    status?: boolean
    notes?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    procedureName?: boolean
    surgeonId?: boolean
    otRoomNumber?: boolean
    surgeryDate?: boolean
    status?: boolean
    notes?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgery"]>

  export type SurgerySelectScalar = {
    id?: boolean
    admissionId?: boolean
    procedureName?: boolean
    surgeonId?: boolean
    otRoomNumber?: boolean
    surgeryDate?: boolean
    status?: boolean
    notes?: boolean
  }

  export type SurgeryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admissionId" | "procedureName" | "surgeonId" | "otRoomNumber" | "surgeryDate" | "status" | "notes", ExtArgs["result"]["surgery"]>
  export type SurgeryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
    checklists?: boolean | Surgery$checklistsArgs<ExtArgs>
    surgerySStaffs?: boolean | Surgery$surgerySStaffsArgs<ExtArgs>
    _count?: boolean | SurgeryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SurgeryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type SurgeryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
    surgeon?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $SurgeryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Surgery"
    objects: {
      admission: Prisma.$AdmissionPayload<ExtArgs>
      surgeon: Prisma.$StaffProfilePayload<ExtArgs>
      checklists: Prisma.$SurgicalChecklistPayload<ExtArgs>[]
      surgerySStaffs: Prisma.$SurgerySStaffPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admissionId: string
      procedureName: string
      surgeonId: string
      otRoomNumber: string | null
      surgeryDate: Date
      status: $Enums.SurgeryStatus
      notes: string | null
    }, ExtArgs["result"]["surgery"]>
    composites: {}
  }

  type SurgeryGetPayload<S extends boolean | null | undefined | SurgeryDefaultArgs> = $Result.GetResult<Prisma.$SurgeryPayload, S>

  type SurgeryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurgeryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurgeryCountAggregateInputType | true
    }

  export interface SurgeryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Surgery'], meta: { name: 'Surgery' } }
    /**
     * Find zero or one Surgery that matches the filter.
     * @param {SurgeryFindUniqueArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurgeryFindUniqueArgs>(args: SelectSubset<T, SurgeryFindUniqueArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Surgery that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurgeryFindUniqueOrThrowArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurgeryFindUniqueOrThrowArgs>(args: SelectSubset<T, SurgeryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surgery that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindFirstArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurgeryFindFirstArgs>(args?: SelectSubset<T, SurgeryFindFirstArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Surgery that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindFirstOrThrowArgs} args - Arguments to find a Surgery
     * @example
     * // Get one Surgery
     * const surgery = await prisma.surgery.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurgeryFindFirstOrThrowArgs>(args?: SelectSubset<T, SurgeryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Surgeries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Surgeries
     * const surgeries = await prisma.surgery.findMany()
     * 
     * // Get first 10 Surgeries
     * const surgeries = await prisma.surgery.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surgeryWithIdOnly = await prisma.surgery.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurgeryFindManyArgs>(args?: SelectSubset<T, SurgeryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Surgery.
     * @param {SurgeryCreateArgs} args - Arguments to create a Surgery.
     * @example
     * // Create one Surgery
     * const Surgery = await prisma.surgery.create({
     *   data: {
     *     // ... data to create a Surgery
     *   }
     * })
     * 
     */
    create<T extends SurgeryCreateArgs>(args: SelectSubset<T, SurgeryCreateArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Surgeries.
     * @param {SurgeryCreateManyArgs} args - Arguments to create many Surgeries.
     * @example
     * // Create many Surgeries
     * const surgery = await prisma.surgery.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurgeryCreateManyArgs>(args?: SelectSubset<T, SurgeryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Surgeries and returns the data saved in the database.
     * @param {SurgeryCreateManyAndReturnArgs} args - Arguments to create many Surgeries.
     * @example
     * // Create many Surgeries
     * const surgery = await prisma.surgery.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Surgeries and only return the `id`
     * const surgeryWithIdOnly = await prisma.surgery.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurgeryCreateManyAndReturnArgs>(args?: SelectSubset<T, SurgeryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Surgery.
     * @param {SurgeryDeleteArgs} args - Arguments to delete one Surgery.
     * @example
     * // Delete one Surgery
     * const Surgery = await prisma.surgery.delete({
     *   where: {
     *     // ... filter to delete one Surgery
     *   }
     * })
     * 
     */
    delete<T extends SurgeryDeleteArgs>(args: SelectSubset<T, SurgeryDeleteArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Surgery.
     * @param {SurgeryUpdateArgs} args - Arguments to update one Surgery.
     * @example
     * // Update one Surgery
     * const surgery = await prisma.surgery.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurgeryUpdateArgs>(args: SelectSubset<T, SurgeryUpdateArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Surgeries.
     * @param {SurgeryDeleteManyArgs} args - Arguments to filter Surgeries to delete.
     * @example
     * // Delete a few Surgeries
     * const { count } = await prisma.surgery.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurgeryDeleteManyArgs>(args?: SelectSubset<T, SurgeryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Surgeries
     * const surgery = await prisma.surgery.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurgeryUpdateManyArgs>(args: SelectSubset<T, SurgeryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Surgeries and returns the data updated in the database.
     * @param {SurgeryUpdateManyAndReturnArgs} args - Arguments to update many Surgeries.
     * @example
     * // Update many Surgeries
     * const surgery = await prisma.surgery.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Surgeries and only return the `id`
     * const surgeryWithIdOnly = await prisma.surgery.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurgeryUpdateManyAndReturnArgs>(args: SelectSubset<T, SurgeryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Surgery.
     * @param {SurgeryUpsertArgs} args - Arguments to update or create a Surgery.
     * @example
     * // Update or create a Surgery
     * const surgery = await prisma.surgery.upsert({
     *   create: {
     *     // ... data to create a Surgery
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Surgery we want to update
     *   }
     * })
     */
    upsert<T extends SurgeryUpsertArgs>(args: SelectSubset<T, SurgeryUpsertArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Surgeries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryCountArgs} args - Arguments to filter Surgeries to count.
     * @example
     * // Count the number of Surgeries
     * const count = await prisma.surgery.count({
     *   where: {
     *     // ... the filter for the Surgeries we want to count
     *   }
     * })
    **/
    count<T extends SurgeryCountArgs>(
      args?: Subset<T, SurgeryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurgeryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Surgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurgeryAggregateArgs>(args: Subset<T, SurgeryAggregateArgs>): Prisma.PrismaPromise<GetSurgeryAggregateType<T>>

    /**
     * Group by Surgery.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgeryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurgeryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurgeryGroupByArgs['orderBy'] }
        : { orderBy?: SurgeryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurgeryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurgeryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Surgery model
   */
  readonly fields: SurgeryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Surgery.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurgeryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admission<T extends AdmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionDefaultArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    surgeon<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checklists<T extends Surgery$checklistsArgs<ExtArgs> = {}>(args?: Subset<T, Surgery$checklistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    surgerySStaffs<T extends Surgery$surgerySStaffsArgs<ExtArgs> = {}>(args?: Subset<T, Surgery$surgerySStaffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Surgery model
   */
  interface SurgeryFieldRefs {
    readonly id: FieldRef<"Surgery", 'String'>
    readonly admissionId: FieldRef<"Surgery", 'String'>
    readonly procedureName: FieldRef<"Surgery", 'String'>
    readonly surgeonId: FieldRef<"Surgery", 'String'>
    readonly otRoomNumber: FieldRef<"Surgery", 'String'>
    readonly surgeryDate: FieldRef<"Surgery", 'DateTime'>
    readonly status: FieldRef<"Surgery", 'SurgeryStatus'>
    readonly notes: FieldRef<"Surgery", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Surgery findUnique
   */
  export type SurgeryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery findUniqueOrThrow
   */
  export type SurgeryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery findFirst
   */
  export type SurgeryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surgeries.
     */
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery findFirstOrThrow
   */
  export type SurgeryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgery to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Surgeries.
     */
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery findMany
   */
  export type SurgeryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter, which Surgeries to fetch.
     */
    where?: SurgeryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Surgeries to fetch.
     */
    orderBy?: SurgeryOrderByWithRelationInput | SurgeryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Surgeries.
     */
    cursor?: SurgeryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Surgeries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Surgeries.
     */
    skip?: number
    distinct?: SurgeryScalarFieldEnum | SurgeryScalarFieldEnum[]
  }

  /**
   * Surgery create
   */
  export type SurgeryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The data needed to create a Surgery.
     */
    data: XOR<SurgeryCreateInput, SurgeryUncheckedCreateInput>
  }

  /**
   * Surgery createMany
   */
  export type SurgeryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Surgeries.
     */
    data: SurgeryCreateManyInput | SurgeryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Surgery createManyAndReturn
   */
  export type SurgeryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * The data used to create many Surgeries.
     */
    data: SurgeryCreateManyInput | SurgeryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Surgery update
   */
  export type SurgeryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The data needed to update a Surgery.
     */
    data: XOR<SurgeryUpdateInput, SurgeryUncheckedUpdateInput>
    /**
     * Choose, which Surgery to update.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery updateMany
   */
  export type SurgeryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Surgeries.
     */
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyInput>
    /**
     * Filter which Surgeries to update
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to update.
     */
    limit?: number
  }

  /**
   * Surgery updateManyAndReturn
   */
  export type SurgeryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * The data used to update Surgeries.
     */
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyInput>
    /**
     * Filter which Surgeries to update
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Surgery upsert
   */
  export type SurgeryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * The filter to search for the Surgery to update in case it exists.
     */
    where: SurgeryWhereUniqueInput
    /**
     * In case the Surgery found by the `where` argument doesn't exist, create a new Surgery with this data.
     */
    create: XOR<SurgeryCreateInput, SurgeryUncheckedCreateInput>
    /**
     * In case the Surgery was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurgeryUpdateInput, SurgeryUncheckedUpdateInput>
  }

  /**
   * Surgery delete
   */
  export type SurgeryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
    /**
     * Filter which Surgery to delete.
     */
    where: SurgeryWhereUniqueInput
  }

  /**
   * Surgery deleteMany
   */
  export type SurgeryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Surgeries to delete
     */
    where?: SurgeryWhereInput
    /**
     * Limit how many Surgeries to delete.
     */
    limit?: number
  }

  /**
   * Surgery.checklists
   */
  export type Surgery$checklistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    where?: SurgicalChecklistWhereInput
    orderBy?: SurgicalChecklistOrderByWithRelationInput | SurgicalChecklistOrderByWithRelationInput[]
    cursor?: SurgicalChecklistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgicalChecklistScalarFieldEnum | SurgicalChecklistScalarFieldEnum[]
  }

  /**
   * Surgery.surgerySStaffs
   */
  export type Surgery$surgerySStaffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    where?: SurgerySStaffWhereInput
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    cursor?: SurgerySStaffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SurgerySStaffScalarFieldEnum | SurgerySStaffScalarFieldEnum[]
  }

  /**
   * Surgery without action
   */
  export type SurgeryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Surgery
     */
    select?: SurgerySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Surgery
     */
    omit?: SurgeryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgeryInclude<ExtArgs> | null
  }


  /**
   * Model SurgerySStaff
   */

  export type AggregateSurgerySStaff = {
    _count: SurgerySStaffCountAggregateOutputType | null
    _min: SurgerySStaffMinAggregateOutputType | null
    _max: SurgerySStaffMaxAggregateOutputType | null
  }

  export type SurgerySStaffMinAggregateOutputType = {
    surgeryId: string | null
    staffId: string | null
    role: string | null
  }

  export type SurgerySStaffMaxAggregateOutputType = {
    surgeryId: string | null
    staffId: string | null
    role: string | null
  }

  export type SurgerySStaffCountAggregateOutputType = {
    surgeryId: number
    staffId: number
    role: number
    _all: number
  }


  export type SurgerySStaffMinAggregateInputType = {
    surgeryId?: true
    staffId?: true
    role?: true
  }

  export type SurgerySStaffMaxAggregateInputType = {
    surgeryId?: true
    staffId?: true
    role?: true
  }

  export type SurgerySStaffCountAggregateInputType = {
    surgeryId?: true
    staffId?: true
    role?: true
    _all?: true
  }

  export type SurgerySStaffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurgerySStaff to aggregate.
     */
    where?: SurgerySStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgerySStaffs to fetch.
     */
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurgerySStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgerySStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgerySStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurgerySStaffs
    **/
    _count?: true | SurgerySStaffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurgerySStaffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurgerySStaffMaxAggregateInputType
  }

  export type GetSurgerySStaffAggregateType<T extends SurgerySStaffAggregateArgs> = {
        [P in keyof T & keyof AggregateSurgerySStaff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurgerySStaff[P]>
      : GetScalarType<T[P], AggregateSurgerySStaff[P]>
  }




  export type SurgerySStaffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgerySStaffWhereInput
    orderBy?: SurgerySStaffOrderByWithAggregationInput | SurgerySStaffOrderByWithAggregationInput[]
    by: SurgerySStaffScalarFieldEnum[] | SurgerySStaffScalarFieldEnum
    having?: SurgerySStaffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurgerySStaffCountAggregateInputType | true
    _min?: SurgerySStaffMinAggregateInputType
    _max?: SurgerySStaffMaxAggregateInputType
  }

  export type SurgerySStaffGroupByOutputType = {
    surgeryId: string
    staffId: string
    role: string
    _count: SurgerySStaffCountAggregateOutputType | null
    _min: SurgerySStaffMinAggregateOutputType | null
    _max: SurgerySStaffMaxAggregateOutputType | null
  }

  type GetSurgerySStaffGroupByPayload<T extends SurgerySStaffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurgerySStaffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurgerySStaffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurgerySStaffGroupByOutputType[P]>
            : GetScalarType<T[P], SurgerySStaffGroupByOutputType[P]>
        }
      >
    >


  export type SurgerySStaffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surgeryId?: boolean
    staffId?: boolean
    role?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgerySStaff"]>

  export type SurgerySStaffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surgeryId?: boolean
    staffId?: boolean
    role?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgerySStaff"]>

  export type SurgerySStaffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    surgeryId?: boolean
    staffId?: boolean
    role?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgerySStaff"]>

  export type SurgerySStaffSelectScalar = {
    surgeryId?: boolean
    staffId?: boolean
    role?: boolean
  }

  export type SurgerySStaffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"surgeryId" | "staffId" | "role", ExtArgs["result"]["surgerySStaff"]>
  export type SurgerySStaffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type SurgerySStaffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type SurgerySStaffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $SurgerySStaffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurgerySStaff"
    objects: {
      surgery: Prisma.$SurgeryPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      surgeryId: string
      staffId: string
      role: string
    }, ExtArgs["result"]["surgerySStaff"]>
    composites: {}
  }

  type SurgerySStaffGetPayload<S extends boolean | null | undefined | SurgerySStaffDefaultArgs> = $Result.GetResult<Prisma.$SurgerySStaffPayload, S>

  type SurgerySStaffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurgerySStaffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurgerySStaffCountAggregateInputType | true
    }

  export interface SurgerySStaffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurgerySStaff'], meta: { name: 'SurgerySStaff' } }
    /**
     * Find zero or one SurgerySStaff that matches the filter.
     * @param {SurgerySStaffFindUniqueArgs} args - Arguments to find a SurgerySStaff
     * @example
     * // Get one SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurgerySStaffFindUniqueArgs>(args: SelectSubset<T, SurgerySStaffFindUniqueArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurgerySStaff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurgerySStaffFindUniqueOrThrowArgs} args - Arguments to find a SurgerySStaff
     * @example
     * // Get one SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurgerySStaffFindUniqueOrThrowArgs>(args: SelectSubset<T, SurgerySStaffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurgerySStaff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffFindFirstArgs} args - Arguments to find a SurgerySStaff
     * @example
     * // Get one SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurgerySStaffFindFirstArgs>(args?: SelectSubset<T, SurgerySStaffFindFirstArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurgerySStaff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffFindFirstOrThrowArgs} args - Arguments to find a SurgerySStaff
     * @example
     * // Get one SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurgerySStaffFindFirstOrThrowArgs>(args?: SelectSubset<T, SurgerySStaffFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurgerySStaffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurgerySStaffs
     * const surgerySStaffs = await prisma.surgerySStaff.findMany()
     * 
     * // Get first 10 SurgerySStaffs
     * const surgerySStaffs = await prisma.surgerySStaff.findMany({ take: 10 })
     * 
     * // Only select the `surgeryId`
     * const surgerySStaffWithSurgeryIdOnly = await prisma.surgerySStaff.findMany({ select: { surgeryId: true } })
     * 
     */
    findMany<T extends SurgerySStaffFindManyArgs>(args?: SelectSubset<T, SurgerySStaffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurgerySStaff.
     * @param {SurgerySStaffCreateArgs} args - Arguments to create a SurgerySStaff.
     * @example
     * // Create one SurgerySStaff
     * const SurgerySStaff = await prisma.surgerySStaff.create({
     *   data: {
     *     // ... data to create a SurgerySStaff
     *   }
     * })
     * 
     */
    create<T extends SurgerySStaffCreateArgs>(args: SelectSubset<T, SurgerySStaffCreateArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurgerySStaffs.
     * @param {SurgerySStaffCreateManyArgs} args - Arguments to create many SurgerySStaffs.
     * @example
     * // Create many SurgerySStaffs
     * const surgerySStaff = await prisma.surgerySStaff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurgerySStaffCreateManyArgs>(args?: SelectSubset<T, SurgerySStaffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurgerySStaffs and returns the data saved in the database.
     * @param {SurgerySStaffCreateManyAndReturnArgs} args - Arguments to create many SurgerySStaffs.
     * @example
     * // Create many SurgerySStaffs
     * const surgerySStaff = await prisma.surgerySStaff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurgerySStaffs and only return the `surgeryId`
     * const surgerySStaffWithSurgeryIdOnly = await prisma.surgerySStaff.createManyAndReturn({
     *   select: { surgeryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurgerySStaffCreateManyAndReturnArgs>(args?: SelectSubset<T, SurgerySStaffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurgerySStaff.
     * @param {SurgerySStaffDeleteArgs} args - Arguments to delete one SurgerySStaff.
     * @example
     * // Delete one SurgerySStaff
     * const SurgerySStaff = await prisma.surgerySStaff.delete({
     *   where: {
     *     // ... filter to delete one SurgerySStaff
     *   }
     * })
     * 
     */
    delete<T extends SurgerySStaffDeleteArgs>(args: SelectSubset<T, SurgerySStaffDeleteArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurgerySStaff.
     * @param {SurgerySStaffUpdateArgs} args - Arguments to update one SurgerySStaff.
     * @example
     * // Update one SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurgerySStaffUpdateArgs>(args: SelectSubset<T, SurgerySStaffUpdateArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurgerySStaffs.
     * @param {SurgerySStaffDeleteManyArgs} args - Arguments to filter SurgerySStaffs to delete.
     * @example
     * // Delete a few SurgerySStaffs
     * const { count } = await prisma.surgerySStaff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurgerySStaffDeleteManyArgs>(args?: SelectSubset<T, SurgerySStaffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurgerySStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurgerySStaffs
     * const surgerySStaff = await prisma.surgerySStaff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurgerySStaffUpdateManyArgs>(args: SelectSubset<T, SurgerySStaffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurgerySStaffs and returns the data updated in the database.
     * @param {SurgerySStaffUpdateManyAndReturnArgs} args - Arguments to update many SurgerySStaffs.
     * @example
     * // Update many SurgerySStaffs
     * const surgerySStaff = await prisma.surgerySStaff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurgerySStaffs and only return the `surgeryId`
     * const surgerySStaffWithSurgeryIdOnly = await prisma.surgerySStaff.updateManyAndReturn({
     *   select: { surgeryId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurgerySStaffUpdateManyAndReturnArgs>(args: SelectSubset<T, SurgerySStaffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurgerySStaff.
     * @param {SurgerySStaffUpsertArgs} args - Arguments to update or create a SurgerySStaff.
     * @example
     * // Update or create a SurgerySStaff
     * const surgerySStaff = await prisma.surgerySStaff.upsert({
     *   create: {
     *     // ... data to create a SurgerySStaff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurgerySStaff we want to update
     *   }
     * })
     */
    upsert<T extends SurgerySStaffUpsertArgs>(args: SelectSubset<T, SurgerySStaffUpsertArgs<ExtArgs>>): Prisma__SurgerySStaffClient<$Result.GetResult<Prisma.$SurgerySStaffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurgerySStaffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffCountArgs} args - Arguments to filter SurgerySStaffs to count.
     * @example
     * // Count the number of SurgerySStaffs
     * const count = await prisma.surgerySStaff.count({
     *   where: {
     *     // ... the filter for the SurgerySStaffs we want to count
     *   }
     * })
    **/
    count<T extends SurgerySStaffCountArgs>(
      args?: Subset<T, SurgerySStaffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurgerySStaffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurgerySStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurgerySStaffAggregateArgs>(args: Subset<T, SurgerySStaffAggregateArgs>): Prisma.PrismaPromise<GetSurgerySStaffAggregateType<T>>

    /**
     * Group by SurgerySStaff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgerySStaffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurgerySStaffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurgerySStaffGroupByArgs['orderBy'] }
        : { orderBy?: SurgerySStaffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurgerySStaffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurgerySStaffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurgerySStaff model
   */
  readonly fields: SurgerySStaffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurgerySStaff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurgerySStaffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surgery<T extends SurgeryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurgeryDefaultArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurgerySStaff model
   */
  interface SurgerySStaffFieldRefs {
    readonly surgeryId: FieldRef<"SurgerySStaff", 'String'>
    readonly staffId: FieldRef<"SurgerySStaff", 'String'>
    readonly role: FieldRef<"SurgerySStaff", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SurgerySStaff findUnique
   */
  export type SurgerySStaffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter, which SurgerySStaff to fetch.
     */
    where: SurgerySStaffWhereUniqueInput
  }

  /**
   * SurgerySStaff findUniqueOrThrow
   */
  export type SurgerySStaffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter, which SurgerySStaff to fetch.
     */
    where: SurgerySStaffWhereUniqueInput
  }

  /**
   * SurgerySStaff findFirst
   */
  export type SurgerySStaffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter, which SurgerySStaff to fetch.
     */
    where?: SurgerySStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgerySStaffs to fetch.
     */
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurgerySStaffs.
     */
    cursor?: SurgerySStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgerySStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgerySStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurgerySStaffs.
     */
    distinct?: SurgerySStaffScalarFieldEnum | SurgerySStaffScalarFieldEnum[]
  }

  /**
   * SurgerySStaff findFirstOrThrow
   */
  export type SurgerySStaffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter, which SurgerySStaff to fetch.
     */
    where?: SurgerySStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgerySStaffs to fetch.
     */
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurgerySStaffs.
     */
    cursor?: SurgerySStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgerySStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgerySStaffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurgerySStaffs.
     */
    distinct?: SurgerySStaffScalarFieldEnum | SurgerySStaffScalarFieldEnum[]
  }

  /**
   * SurgerySStaff findMany
   */
  export type SurgerySStaffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter, which SurgerySStaffs to fetch.
     */
    where?: SurgerySStaffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgerySStaffs to fetch.
     */
    orderBy?: SurgerySStaffOrderByWithRelationInput | SurgerySStaffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurgerySStaffs.
     */
    cursor?: SurgerySStaffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgerySStaffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgerySStaffs.
     */
    skip?: number
    distinct?: SurgerySStaffScalarFieldEnum | SurgerySStaffScalarFieldEnum[]
  }

  /**
   * SurgerySStaff create
   */
  export type SurgerySStaffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * The data needed to create a SurgerySStaff.
     */
    data: XOR<SurgerySStaffCreateInput, SurgerySStaffUncheckedCreateInput>
  }

  /**
   * SurgerySStaff createMany
   */
  export type SurgerySStaffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurgerySStaffs.
     */
    data: SurgerySStaffCreateManyInput | SurgerySStaffCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurgerySStaff createManyAndReturn
   */
  export type SurgerySStaffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * The data used to create many SurgerySStaffs.
     */
    data: SurgerySStaffCreateManyInput | SurgerySStaffCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurgerySStaff update
   */
  export type SurgerySStaffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * The data needed to update a SurgerySStaff.
     */
    data: XOR<SurgerySStaffUpdateInput, SurgerySStaffUncheckedUpdateInput>
    /**
     * Choose, which SurgerySStaff to update.
     */
    where: SurgerySStaffWhereUniqueInput
  }

  /**
   * SurgerySStaff updateMany
   */
  export type SurgerySStaffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurgerySStaffs.
     */
    data: XOR<SurgerySStaffUpdateManyMutationInput, SurgerySStaffUncheckedUpdateManyInput>
    /**
     * Filter which SurgerySStaffs to update
     */
    where?: SurgerySStaffWhereInput
    /**
     * Limit how many SurgerySStaffs to update.
     */
    limit?: number
  }

  /**
   * SurgerySStaff updateManyAndReturn
   */
  export type SurgerySStaffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * The data used to update SurgerySStaffs.
     */
    data: XOR<SurgerySStaffUpdateManyMutationInput, SurgerySStaffUncheckedUpdateManyInput>
    /**
     * Filter which SurgerySStaffs to update
     */
    where?: SurgerySStaffWhereInput
    /**
     * Limit how many SurgerySStaffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurgerySStaff upsert
   */
  export type SurgerySStaffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * The filter to search for the SurgerySStaff to update in case it exists.
     */
    where: SurgerySStaffWhereUniqueInput
    /**
     * In case the SurgerySStaff found by the `where` argument doesn't exist, create a new SurgerySStaff with this data.
     */
    create: XOR<SurgerySStaffCreateInput, SurgerySStaffUncheckedCreateInput>
    /**
     * In case the SurgerySStaff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurgerySStaffUpdateInput, SurgerySStaffUncheckedUpdateInput>
  }

  /**
   * SurgerySStaff delete
   */
  export type SurgerySStaffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
    /**
     * Filter which SurgerySStaff to delete.
     */
    where: SurgerySStaffWhereUniqueInput
  }

  /**
   * SurgerySStaff deleteMany
   */
  export type SurgerySStaffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurgerySStaffs to delete
     */
    where?: SurgerySStaffWhereInput
    /**
     * Limit how many SurgerySStaffs to delete.
     */
    limit?: number
  }

  /**
   * SurgerySStaff without action
   */
  export type SurgerySStaffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgerySStaff
     */
    select?: SurgerySStaffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgerySStaff
     */
    omit?: SurgerySStaffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgerySStaffInclude<ExtArgs> | null
  }


  /**
   * Model SurgicalChecklist
   */

  export type AggregateSurgicalChecklist = {
    _count: SurgicalChecklistCountAggregateOutputType | null
    _min: SurgicalChecklistMinAggregateOutputType | null
    _max: SurgicalChecklistMaxAggregateOutputType | null
  }

  export type SurgicalChecklistMinAggregateOutputType = {
    id: string | null
    surgeryId: string | null
    stage: $Enums.ChecklistStage | null
    itemName: string | null
    isChecked: boolean | null
    checkedBy: string | null
    timestamp: Date | null
  }

  export type SurgicalChecklistMaxAggregateOutputType = {
    id: string | null
    surgeryId: string | null
    stage: $Enums.ChecklistStage | null
    itemName: string | null
    isChecked: boolean | null
    checkedBy: string | null
    timestamp: Date | null
  }

  export type SurgicalChecklistCountAggregateOutputType = {
    id: number
    surgeryId: number
    stage: number
    itemName: number
    isChecked: number
    checkedBy: number
    timestamp: number
    _all: number
  }


  export type SurgicalChecklistMinAggregateInputType = {
    id?: true
    surgeryId?: true
    stage?: true
    itemName?: true
    isChecked?: true
    checkedBy?: true
    timestamp?: true
  }

  export type SurgicalChecklistMaxAggregateInputType = {
    id?: true
    surgeryId?: true
    stage?: true
    itemName?: true
    isChecked?: true
    checkedBy?: true
    timestamp?: true
  }

  export type SurgicalChecklistCountAggregateInputType = {
    id?: true
    surgeryId?: true
    stage?: true
    itemName?: true
    isChecked?: true
    checkedBy?: true
    timestamp?: true
    _all?: true
  }

  export type SurgicalChecklistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurgicalChecklist to aggregate.
     */
    where?: SurgicalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgicalChecklists to fetch.
     */
    orderBy?: SurgicalChecklistOrderByWithRelationInput | SurgicalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SurgicalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgicalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgicalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SurgicalChecklists
    **/
    _count?: true | SurgicalChecklistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SurgicalChecklistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SurgicalChecklistMaxAggregateInputType
  }

  export type GetSurgicalChecklistAggregateType<T extends SurgicalChecklistAggregateArgs> = {
        [P in keyof T & keyof AggregateSurgicalChecklist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSurgicalChecklist[P]>
      : GetScalarType<T[P], AggregateSurgicalChecklist[P]>
  }




  export type SurgicalChecklistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SurgicalChecklistWhereInput
    orderBy?: SurgicalChecklistOrderByWithAggregationInput | SurgicalChecklistOrderByWithAggregationInput[]
    by: SurgicalChecklistScalarFieldEnum[] | SurgicalChecklistScalarFieldEnum
    having?: SurgicalChecklistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SurgicalChecklistCountAggregateInputType | true
    _min?: SurgicalChecklistMinAggregateInputType
    _max?: SurgicalChecklistMaxAggregateInputType
  }

  export type SurgicalChecklistGroupByOutputType = {
    id: string
    surgeryId: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked: boolean
    checkedBy: string | null
    timestamp: Date
    _count: SurgicalChecklistCountAggregateOutputType | null
    _min: SurgicalChecklistMinAggregateOutputType | null
    _max: SurgicalChecklistMaxAggregateOutputType | null
  }

  type GetSurgicalChecklistGroupByPayload<T extends SurgicalChecklistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SurgicalChecklistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SurgicalChecklistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SurgicalChecklistGroupByOutputType[P]>
            : GetScalarType<T[P], SurgicalChecklistGroupByOutputType[P]>
        }
      >
    >


  export type SurgicalChecklistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surgeryId?: boolean
    stage?: boolean
    itemName?: boolean
    isChecked?: boolean
    checkedBy?: boolean
    timestamp?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgicalChecklist"]>

  export type SurgicalChecklistSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surgeryId?: boolean
    stage?: boolean
    itemName?: boolean
    isChecked?: boolean
    checkedBy?: boolean
    timestamp?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgicalChecklist"]>

  export type SurgicalChecklistSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    surgeryId?: boolean
    stage?: boolean
    itemName?: boolean
    isChecked?: boolean
    checkedBy?: boolean
    timestamp?: boolean
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["surgicalChecklist"]>

  export type SurgicalChecklistSelectScalar = {
    id?: boolean
    surgeryId?: boolean
    stage?: boolean
    itemName?: boolean
    isChecked?: boolean
    checkedBy?: boolean
    timestamp?: boolean
  }

  export type SurgicalChecklistOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "surgeryId" | "stage" | "itemName" | "isChecked" | "checkedBy" | "timestamp", ExtArgs["result"]["surgicalChecklist"]>
  export type SurgicalChecklistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }
  export type SurgicalChecklistIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }
  export type SurgicalChecklistIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    surgery?: boolean | SurgeryDefaultArgs<ExtArgs>
  }

  export type $SurgicalChecklistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SurgicalChecklist"
    objects: {
      surgery: Prisma.$SurgeryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      surgeryId: string
      stage: $Enums.ChecklistStage
      itemName: string
      isChecked: boolean
      checkedBy: string | null
      timestamp: Date
    }, ExtArgs["result"]["surgicalChecklist"]>
    composites: {}
  }

  type SurgicalChecklistGetPayload<S extends boolean | null | undefined | SurgicalChecklistDefaultArgs> = $Result.GetResult<Prisma.$SurgicalChecklistPayload, S>

  type SurgicalChecklistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SurgicalChecklistFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SurgicalChecklistCountAggregateInputType | true
    }

  export interface SurgicalChecklistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SurgicalChecklist'], meta: { name: 'SurgicalChecklist' } }
    /**
     * Find zero or one SurgicalChecklist that matches the filter.
     * @param {SurgicalChecklistFindUniqueArgs} args - Arguments to find a SurgicalChecklist
     * @example
     * // Get one SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SurgicalChecklistFindUniqueArgs>(args: SelectSubset<T, SurgicalChecklistFindUniqueArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SurgicalChecklist that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SurgicalChecklistFindUniqueOrThrowArgs} args - Arguments to find a SurgicalChecklist
     * @example
     * // Get one SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SurgicalChecklistFindUniqueOrThrowArgs>(args: SelectSubset<T, SurgicalChecklistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurgicalChecklist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistFindFirstArgs} args - Arguments to find a SurgicalChecklist
     * @example
     * // Get one SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SurgicalChecklistFindFirstArgs>(args?: SelectSubset<T, SurgicalChecklistFindFirstArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SurgicalChecklist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistFindFirstOrThrowArgs} args - Arguments to find a SurgicalChecklist
     * @example
     * // Get one SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SurgicalChecklistFindFirstOrThrowArgs>(args?: SelectSubset<T, SurgicalChecklistFindFirstOrThrowArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SurgicalChecklists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SurgicalChecklists
     * const surgicalChecklists = await prisma.surgicalChecklist.findMany()
     * 
     * // Get first 10 SurgicalChecklists
     * const surgicalChecklists = await prisma.surgicalChecklist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const surgicalChecklistWithIdOnly = await prisma.surgicalChecklist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SurgicalChecklistFindManyArgs>(args?: SelectSubset<T, SurgicalChecklistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SurgicalChecklist.
     * @param {SurgicalChecklistCreateArgs} args - Arguments to create a SurgicalChecklist.
     * @example
     * // Create one SurgicalChecklist
     * const SurgicalChecklist = await prisma.surgicalChecklist.create({
     *   data: {
     *     // ... data to create a SurgicalChecklist
     *   }
     * })
     * 
     */
    create<T extends SurgicalChecklistCreateArgs>(args: SelectSubset<T, SurgicalChecklistCreateArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SurgicalChecklists.
     * @param {SurgicalChecklistCreateManyArgs} args - Arguments to create many SurgicalChecklists.
     * @example
     * // Create many SurgicalChecklists
     * const surgicalChecklist = await prisma.surgicalChecklist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SurgicalChecklistCreateManyArgs>(args?: SelectSubset<T, SurgicalChecklistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SurgicalChecklists and returns the data saved in the database.
     * @param {SurgicalChecklistCreateManyAndReturnArgs} args - Arguments to create many SurgicalChecklists.
     * @example
     * // Create many SurgicalChecklists
     * const surgicalChecklist = await prisma.surgicalChecklist.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SurgicalChecklists and only return the `id`
     * const surgicalChecklistWithIdOnly = await prisma.surgicalChecklist.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SurgicalChecklistCreateManyAndReturnArgs>(args?: SelectSubset<T, SurgicalChecklistCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SurgicalChecklist.
     * @param {SurgicalChecklistDeleteArgs} args - Arguments to delete one SurgicalChecklist.
     * @example
     * // Delete one SurgicalChecklist
     * const SurgicalChecklist = await prisma.surgicalChecklist.delete({
     *   where: {
     *     // ... filter to delete one SurgicalChecklist
     *   }
     * })
     * 
     */
    delete<T extends SurgicalChecklistDeleteArgs>(args: SelectSubset<T, SurgicalChecklistDeleteArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SurgicalChecklist.
     * @param {SurgicalChecklistUpdateArgs} args - Arguments to update one SurgicalChecklist.
     * @example
     * // Update one SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SurgicalChecklistUpdateArgs>(args: SelectSubset<T, SurgicalChecklistUpdateArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SurgicalChecklists.
     * @param {SurgicalChecklistDeleteManyArgs} args - Arguments to filter SurgicalChecklists to delete.
     * @example
     * // Delete a few SurgicalChecklists
     * const { count } = await prisma.surgicalChecklist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SurgicalChecklistDeleteManyArgs>(args?: SelectSubset<T, SurgicalChecklistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurgicalChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SurgicalChecklists
     * const surgicalChecklist = await prisma.surgicalChecklist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SurgicalChecklistUpdateManyArgs>(args: SelectSubset<T, SurgicalChecklistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SurgicalChecklists and returns the data updated in the database.
     * @param {SurgicalChecklistUpdateManyAndReturnArgs} args - Arguments to update many SurgicalChecklists.
     * @example
     * // Update many SurgicalChecklists
     * const surgicalChecklist = await prisma.surgicalChecklist.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SurgicalChecklists and only return the `id`
     * const surgicalChecklistWithIdOnly = await prisma.surgicalChecklist.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SurgicalChecklistUpdateManyAndReturnArgs>(args: SelectSubset<T, SurgicalChecklistUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SurgicalChecklist.
     * @param {SurgicalChecklistUpsertArgs} args - Arguments to update or create a SurgicalChecklist.
     * @example
     * // Update or create a SurgicalChecklist
     * const surgicalChecklist = await prisma.surgicalChecklist.upsert({
     *   create: {
     *     // ... data to create a SurgicalChecklist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SurgicalChecklist we want to update
     *   }
     * })
     */
    upsert<T extends SurgicalChecklistUpsertArgs>(args: SelectSubset<T, SurgicalChecklistUpsertArgs<ExtArgs>>): Prisma__SurgicalChecklistClient<$Result.GetResult<Prisma.$SurgicalChecklistPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SurgicalChecklists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistCountArgs} args - Arguments to filter SurgicalChecklists to count.
     * @example
     * // Count the number of SurgicalChecklists
     * const count = await prisma.surgicalChecklist.count({
     *   where: {
     *     // ... the filter for the SurgicalChecklists we want to count
     *   }
     * })
    **/
    count<T extends SurgicalChecklistCountArgs>(
      args?: Subset<T, SurgicalChecklistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SurgicalChecklistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SurgicalChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SurgicalChecklistAggregateArgs>(args: Subset<T, SurgicalChecklistAggregateArgs>): Prisma.PrismaPromise<GetSurgicalChecklistAggregateType<T>>

    /**
     * Group by SurgicalChecklist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SurgicalChecklistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SurgicalChecklistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SurgicalChecklistGroupByArgs['orderBy'] }
        : { orderBy?: SurgicalChecklistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SurgicalChecklistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSurgicalChecklistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SurgicalChecklist model
   */
  readonly fields: SurgicalChecklistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SurgicalChecklist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SurgicalChecklistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    surgery<T extends SurgeryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SurgeryDefaultArgs<ExtArgs>>): Prisma__SurgeryClient<$Result.GetResult<Prisma.$SurgeryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SurgicalChecklist model
   */
  interface SurgicalChecklistFieldRefs {
    readonly id: FieldRef<"SurgicalChecklist", 'String'>
    readonly surgeryId: FieldRef<"SurgicalChecklist", 'String'>
    readonly stage: FieldRef<"SurgicalChecklist", 'ChecklistStage'>
    readonly itemName: FieldRef<"SurgicalChecklist", 'String'>
    readonly isChecked: FieldRef<"SurgicalChecklist", 'Boolean'>
    readonly checkedBy: FieldRef<"SurgicalChecklist", 'String'>
    readonly timestamp: FieldRef<"SurgicalChecklist", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SurgicalChecklist findUnique
   */
  export type SurgicalChecklistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SurgicalChecklist to fetch.
     */
    where: SurgicalChecklistWhereUniqueInput
  }

  /**
   * SurgicalChecklist findUniqueOrThrow
   */
  export type SurgicalChecklistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SurgicalChecklist to fetch.
     */
    where: SurgicalChecklistWhereUniqueInput
  }

  /**
   * SurgicalChecklist findFirst
   */
  export type SurgicalChecklistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SurgicalChecklist to fetch.
     */
    where?: SurgicalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgicalChecklists to fetch.
     */
    orderBy?: SurgicalChecklistOrderByWithRelationInput | SurgicalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurgicalChecklists.
     */
    cursor?: SurgicalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgicalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgicalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurgicalChecklists.
     */
    distinct?: SurgicalChecklistScalarFieldEnum | SurgicalChecklistScalarFieldEnum[]
  }

  /**
   * SurgicalChecklist findFirstOrThrow
   */
  export type SurgicalChecklistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SurgicalChecklist to fetch.
     */
    where?: SurgicalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgicalChecklists to fetch.
     */
    orderBy?: SurgicalChecklistOrderByWithRelationInput | SurgicalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SurgicalChecklists.
     */
    cursor?: SurgicalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgicalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgicalChecklists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SurgicalChecklists.
     */
    distinct?: SurgicalChecklistScalarFieldEnum | SurgicalChecklistScalarFieldEnum[]
  }

  /**
   * SurgicalChecklist findMany
   */
  export type SurgicalChecklistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter, which SurgicalChecklists to fetch.
     */
    where?: SurgicalChecklistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SurgicalChecklists to fetch.
     */
    orderBy?: SurgicalChecklistOrderByWithRelationInput | SurgicalChecklistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SurgicalChecklists.
     */
    cursor?: SurgicalChecklistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SurgicalChecklists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SurgicalChecklists.
     */
    skip?: number
    distinct?: SurgicalChecklistScalarFieldEnum | SurgicalChecklistScalarFieldEnum[]
  }

  /**
   * SurgicalChecklist create
   */
  export type SurgicalChecklistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * The data needed to create a SurgicalChecklist.
     */
    data: XOR<SurgicalChecklistCreateInput, SurgicalChecklistUncheckedCreateInput>
  }

  /**
   * SurgicalChecklist createMany
   */
  export type SurgicalChecklistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SurgicalChecklists.
     */
    data: SurgicalChecklistCreateManyInput | SurgicalChecklistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SurgicalChecklist createManyAndReturn
   */
  export type SurgicalChecklistCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * The data used to create many SurgicalChecklists.
     */
    data: SurgicalChecklistCreateManyInput | SurgicalChecklistCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurgicalChecklist update
   */
  export type SurgicalChecklistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * The data needed to update a SurgicalChecklist.
     */
    data: XOR<SurgicalChecklistUpdateInput, SurgicalChecklistUncheckedUpdateInput>
    /**
     * Choose, which SurgicalChecklist to update.
     */
    where: SurgicalChecklistWhereUniqueInput
  }

  /**
   * SurgicalChecklist updateMany
   */
  export type SurgicalChecklistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SurgicalChecklists.
     */
    data: XOR<SurgicalChecklistUpdateManyMutationInput, SurgicalChecklistUncheckedUpdateManyInput>
    /**
     * Filter which SurgicalChecklists to update
     */
    where?: SurgicalChecklistWhereInput
    /**
     * Limit how many SurgicalChecklists to update.
     */
    limit?: number
  }

  /**
   * SurgicalChecklist updateManyAndReturn
   */
  export type SurgicalChecklistUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * The data used to update SurgicalChecklists.
     */
    data: XOR<SurgicalChecklistUpdateManyMutationInput, SurgicalChecklistUncheckedUpdateManyInput>
    /**
     * Filter which SurgicalChecklists to update
     */
    where?: SurgicalChecklistWhereInput
    /**
     * Limit how many SurgicalChecklists to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SurgicalChecklist upsert
   */
  export type SurgicalChecklistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * The filter to search for the SurgicalChecklist to update in case it exists.
     */
    where: SurgicalChecklistWhereUniqueInput
    /**
     * In case the SurgicalChecklist found by the `where` argument doesn't exist, create a new SurgicalChecklist with this data.
     */
    create: XOR<SurgicalChecklistCreateInput, SurgicalChecklistUncheckedCreateInput>
    /**
     * In case the SurgicalChecklist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SurgicalChecklistUpdateInput, SurgicalChecklistUncheckedUpdateInput>
  }

  /**
   * SurgicalChecklist delete
   */
  export type SurgicalChecklistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
    /**
     * Filter which SurgicalChecklist to delete.
     */
    where: SurgicalChecklistWhereUniqueInput
  }

  /**
   * SurgicalChecklist deleteMany
   */
  export type SurgicalChecklistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SurgicalChecklists to delete
     */
    where?: SurgicalChecklistWhereInput
    /**
     * Limit how many SurgicalChecklists to delete.
     */
    limit?: number
  }

  /**
   * SurgicalChecklist without action
   */
  export type SurgicalChecklistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SurgicalChecklist
     */
    select?: SurgicalChecklistSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SurgicalChecklist
     */
    omit?: SurgicalChecklistOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SurgicalChecklistInclude<ExtArgs> | null
  }


  /**
   * Model ClinicalNote
   */

  export type AggregateClinicalNote = {
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  export type ClinicalNoteMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitId: string | null
    admissionId: string | null
    doctorId: string | null
    noteType: $Enums.NoteType | null
    createdAt: Date | null
    isFinalized: boolean | null
  }

  export type ClinicalNoteMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    visitId: string | null
    admissionId: string | null
    doctorId: string | null
    noteType: $Enums.NoteType | null
    createdAt: Date | null
    isFinalized: boolean | null
  }

  export type ClinicalNoteCountAggregateOutputType = {
    id: number
    patientId: number
    visitId: number
    admissionId: number
    doctorId: number
    noteType: number
    content: number
    createdAt: number
    isFinalized: number
    _all: number
  }


  export type ClinicalNoteMinAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    doctorId?: true
    noteType?: true
    createdAt?: true
    isFinalized?: true
  }

  export type ClinicalNoteMaxAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    doctorId?: true
    noteType?: true
    createdAt?: true
    isFinalized?: true
  }

  export type ClinicalNoteCountAggregateInputType = {
    id?: true
    patientId?: true
    visitId?: true
    admissionId?: true
    doctorId?: true
    noteType?: true
    content?: true
    createdAt?: true
    isFinalized?: true
    _all?: true
  }

  export type ClinicalNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNote to aggregate.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicalNotes
    **/
    _count?: true | ClinicalNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicalNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type GetClinicalNoteAggregateType<T extends ClinicalNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicalNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicalNote[P]>
      : GetScalarType<T[P], AggregateClinicalNote[P]>
  }




  export type ClinicalNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicalNoteWhereInput
    orderBy?: ClinicalNoteOrderByWithAggregationInput | ClinicalNoteOrderByWithAggregationInput[]
    by: ClinicalNoteScalarFieldEnum[] | ClinicalNoteScalarFieldEnum
    having?: ClinicalNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicalNoteCountAggregateInputType | true
    _min?: ClinicalNoteMinAggregateInputType
    _max?: ClinicalNoteMaxAggregateInputType
  }

  export type ClinicalNoteGroupByOutputType = {
    id: string
    patientId: string
    visitId: string | null
    admissionId: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonValue
    createdAt: Date
    isFinalized: boolean
    _count: ClinicalNoteCountAggregateOutputType | null
    _min: ClinicalNoteMinAggregateOutputType | null
    _max: ClinicalNoteMaxAggregateOutputType | null
  }

  type GetClinicalNoteGroupByPayload<T extends ClinicalNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicalNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicalNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicalNoteGroupByOutputType[P]>
        }
      >
    >


  export type ClinicalNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    doctorId?: boolean
    noteType?: boolean
    content?: boolean
    createdAt?: boolean
    isFinalized?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    doctorId?: boolean
    noteType?: boolean
    content?: boolean
    createdAt?: boolean
    isFinalized?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    doctorId?: boolean
    noteType?: boolean
    content?: boolean
    createdAt?: boolean
    isFinalized?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicalNote"]>

  export type ClinicalNoteSelectScalar = {
    id?: boolean
    patientId?: boolean
    visitId?: boolean
    admissionId?: boolean
    doctorId?: boolean
    noteType?: boolean
    content?: boolean
    createdAt?: boolean
    isFinalized?: boolean
  }

  export type ClinicalNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "visitId" | "admissionId" | "doctorId" | "noteType" | "content" | "createdAt" | "isFinalized", ExtArgs["result"]["clinicalNote"]>
  export type ClinicalNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    visit?: boolean | ClinicalNote$visitArgs<ExtArgs>
    admission?: boolean | ClinicalNote$admissionArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $ClinicalNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicalNote"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
      doctor: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      visitId: string | null
      admissionId: string | null
      doctorId: string
      noteType: $Enums.NoteType
      content: Prisma.JsonValue
      createdAt: Date
      isFinalized: boolean
    }, ExtArgs["result"]["clinicalNote"]>
    composites: {}
  }

  type ClinicalNoteGetPayload<S extends boolean | null | undefined | ClinicalNoteDefaultArgs> = $Result.GetResult<Prisma.$ClinicalNotePayload, S>

  type ClinicalNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClinicalNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClinicalNoteCountAggregateInputType | true
    }

  export interface ClinicalNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicalNote'], meta: { name: 'ClinicalNote' } }
    /**
     * Find zero or one ClinicalNote that matches the filter.
     * @param {ClinicalNoteFindUniqueArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicalNoteFindUniqueArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClinicalNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClinicalNoteFindUniqueOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicalNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicalNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicalNoteFindFirstArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClinicalNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindFirstOrThrowArgs} args - Arguments to find a ClinicalNote
     * @example
     * // Get one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicalNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicalNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClinicalNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany()
     * 
     * // Get first 10 ClinicalNotes
     * const clinicalNotes = await prisma.clinicalNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicalNoteFindManyArgs>(args?: SelectSubset<T, ClinicalNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClinicalNote.
     * @param {ClinicalNoteCreateArgs} args - Arguments to create a ClinicalNote.
     * @example
     * // Create one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.create({
     *   data: {
     *     // ... data to create a ClinicalNote
     *   }
     * })
     * 
     */
    create<T extends ClinicalNoteCreateArgs>(args: SelectSubset<T, ClinicalNoteCreateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClinicalNotes.
     * @param {ClinicalNoteCreateManyArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicalNoteCreateManyArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicalNotes and returns the data saved in the database.
     * @param {ClinicalNoteCreateManyAndReturnArgs} args - Arguments to create many ClinicalNotes.
     * @example
     * // Create many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicalNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicalNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClinicalNote.
     * @param {ClinicalNoteDeleteArgs} args - Arguments to delete one ClinicalNote.
     * @example
     * // Delete one ClinicalNote
     * const ClinicalNote = await prisma.clinicalNote.delete({
     *   where: {
     *     // ... filter to delete one ClinicalNote
     *   }
     * })
     * 
     */
    delete<T extends ClinicalNoteDeleteArgs>(args: SelectSubset<T, ClinicalNoteDeleteArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClinicalNote.
     * @param {ClinicalNoteUpdateArgs} args - Arguments to update one ClinicalNote.
     * @example
     * // Update one ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicalNoteUpdateArgs>(args: SelectSubset<T, ClinicalNoteUpdateArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClinicalNotes.
     * @param {ClinicalNoteDeleteManyArgs} args - Arguments to filter ClinicalNotes to delete.
     * @example
     * // Delete a few ClinicalNotes
     * const { count } = await prisma.clinicalNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicalNoteDeleteManyArgs>(args?: SelectSubset<T, ClinicalNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicalNoteUpdateManyArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicalNotes and returns the data updated in the database.
     * @param {ClinicalNoteUpdateManyAndReturnArgs} args - Arguments to update many ClinicalNotes.
     * @example
     * // Update many ClinicalNotes
     * const clinicalNote = await prisma.clinicalNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClinicalNotes and only return the `id`
     * const clinicalNoteWithIdOnly = await prisma.clinicalNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClinicalNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ClinicalNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClinicalNote.
     * @param {ClinicalNoteUpsertArgs} args - Arguments to update or create a ClinicalNote.
     * @example
     * // Update or create a ClinicalNote
     * const clinicalNote = await prisma.clinicalNote.upsert({
     *   create: {
     *     // ... data to create a ClinicalNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicalNote we want to update
     *   }
     * })
     */
    upsert<T extends ClinicalNoteUpsertArgs>(args: SelectSubset<T, ClinicalNoteUpsertArgs<ExtArgs>>): Prisma__ClinicalNoteClient<$Result.GetResult<Prisma.$ClinicalNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClinicalNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteCountArgs} args - Arguments to filter ClinicalNotes to count.
     * @example
     * // Count the number of ClinicalNotes
     * const count = await prisma.clinicalNote.count({
     *   where: {
     *     // ... the filter for the ClinicalNotes we want to count
     *   }
     * })
    **/
    count<T extends ClinicalNoteCountArgs>(
      args?: Subset<T, ClinicalNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicalNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicalNoteAggregateArgs>(args: Subset<T, ClinicalNoteAggregateArgs>): Prisma.PrismaPromise<GetClinicalNoteAggregateType<T>>

    /**
     * Group by ClinicalNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicalNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicalNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicalNoteGroupByArgs['orderBy'] }
        : { orderBy?: ClinicalNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicalNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicalNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicalNote model
   */
  readonly fields: ClinicalNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicalNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicalNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visit<T extends ClinicalNote$visitArgs<ExtArgs> = {}>(args?: Subset<T, ClinicalNote$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admission<T extends ClinicalNote$admissionArgs<ExtArgs> = {}>(args?: Subset<T, ClinicalNote$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    doctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicalNote model
   */
  interface ClinicalNoteFieldRefs {
    readonly id: FieldRef<"ClinicalNote", 'String'>
    readonly patientId: FieldRef<"ClinicalNote", 'String'>
    readonly visitId: FieldRef<"ClinicalNote", 'String'>
    readonly admissionId: FieldRef<"ClinicalNote", 'String'>
    readonly doctorId: FieldRef<"ClinicalNote", 'String'>
    readonly noteType: FieldRef<"ClinicalNote", 'NoteType'>
    readonly content: FieldRef<"ClinicalNote", 'Json'>
    readonly createdAt: FieldRef<"ClinicalNote", 'DateTime'>
    readonly isFinalized: FieldRef<"ClinicalNote", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ClinicalNote findUnique
   */
  export type ClinicalNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findUniqueOrThrow
   */
  export type ClinicalNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote findFirst
   */
  export type ClinicalNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findFirstOrThrow
   */
  export type ClinicalNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNote to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicalNotes.
     */
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote findMany
   */
  export type ClinicalNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter, which ClinicalNotes to fetch.
     */
    where?: ClinicalNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicalNotes to fetch.
     */
    orderBy?: ClinicalNoteOrderByWithRelationInput | ClinicalNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicalNotes.
     */
    cursor?: ClinicalNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicalNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicalNotes.
     */
    skip?: number
    distinct?: ClinicalNoteScalarFieldEnum | ClinicalNoteScalarFieldEnum[]
  }

  /**
   * ClinicalNote create
   */
  export type ClinicalNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicalNote.
     */
    data: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
  }

  /**
   * ClinicalNote createMany
   */
  export type ClinicalNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicalNote createManyAndReturn
   */
  export type ClinicalNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to create many ClinicalNotes.
     */
    data: ClinicalNoteCreateManyInput | ClinicalNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote update
   */
  export type ClinicalNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicalNote.
     */
    data: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
    /**
     * Choose, which ClinicalNote to update.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote updateMany
   */
  export type ClinicalNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
  }

  /**
   * ClinicalNote updateManyAndReturn
   */
  export type ClinicalNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * The data used to update ClinicalNotes.
     */
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyInput>
    /**
     * Filter which ClinicalNotes to update
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicalNote upsert
   */
  export type ClinicalNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicalNote to update in case it exists.
     */
    where: ClinicalNoteWhereUniqueInput
    /**
     * In case the ClinicalNote found by the `where` argument doesn't exist, create a new ClinicalNote with this data.
     */
    create: XOR<ClinicalNoteCreateInput, ClinicalNoteUncheckedCreateInput>
    /**
     * In case the ClinicalNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicalNoteUpdateInput, ClinicalNoteUncheckedUpdateInput>
  }

  /**
   * ClinicalNote delete
   */
  export type ClinicalNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
    /**
     * Filter which ClinicalNote to delete.
     */
    where: ClinicalNoteWhereUniqueInput
  }

  /**
   * ClinicalNote deleteMany
   */
  export type ClinicalNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicalNotes to delete
     */
    where?: ClinicalNoteWhereInput
    /**
     * Limit how many ClinicalNotes to delete.
     */
    limit?: number
  }

  /**
   * ClinicalNote.visit
   */
  export type ClinicalNote$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * ClinicalNote.admission
   */
  export type ClinicalNote$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * ClinicalNote without action
   */
  export type ClinicalNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicalNote
     */
    select?: ClinicalNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClinicalNote
     */
    omit?: ClinicalNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicalNoteInclude<ExtArgs> | null
  }


  /**
   * Model ServiceOrder
   */

  export type AggregateServiceOrder = {
    _count: ServiceOrderCountAggregateOutputType | null
    _min: ServiceOrderMinAggregateOutputType | null
    _max: ServiceOrderMaxAggregateOutputType | null
  }

  export type ServiceOrderMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    visitId: string | null
    admissionId: string | null
    serviceId: string | null
    orderType: $Enums.OrderType | null
    priority: $Enums.OrderPriority | null
    clinicalIndication: string | null
    isPaid: boolean | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
  }

  export type ServiceOrderMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    visitId: string | null
    admissionId: string | null
    serviceId: string | null
    orderType: $Enums.OrderType | null
    priority: $Enums.OrderPriority | null
    clinicalIndication: string | null
    isPaid: boolean | null
    status: $Enums.OrderStatus | null
    orderDate: Date | null
  }

  export type ServiceOrderCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    visitId: number
    admissionId: number
    serviceId: number
    orderType: number
    priority: number
    clinicalIndication: number
    isPaid: number
    status: number
    orderDate: number
    _all: number
  }


  export type ServiceOrderMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    serviceId?: true
    orderType?: true
    priority?: true
    clinicalIndication?: true
    isPaid?: true
    status?: true
    orderDate?: true
  }

  export type ServiceOrderMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    serviceId?: true
    orderType?: true
    priority?: true
    clinicalIndication?: true
    isPaid?: true
    status?: true
    orderDate?: true
  }

  export type ServiceOrderCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    serviceId?: true
    orderType?: true
    priority?: true
    clinicalIndication?: true
    isPaid?: true
    status?: true
    orderDate?: true
    _all?: true
  }

  export type ServiceOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOrder to aggregate.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceOrders
    **/
    _count?: true | ServiceOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceOrderMaxAggregateInputType
  }

  export type GetServiceOrderAggregateType<T extends ServiceOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceOrder[P]>
      : GetScalarType<T[P], AggregateServiceOrder[P]>
  }




  export type ServiceOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOrderWhereInput
    orderBy?: ServiceOrderOrderByWithAggregationInput | ServiceOrderOrderByWithAggregationInput[]
    by: ServiceOrderScalarFieldEnum[] | ServiceOrderScalarFieldEnum
    having?: ServiceOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceOrderCountAggregateInputType | true
    _min?: ServiceOrderMinAggregateInputType
    _max?: ServiceOrderMaxAggregateInputType
  }

  export type ServiceOrderGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    visitId: string | null
    admissionId: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication: string | null
    isPaid: boolean
    status: $Enums.OrderStatus
    orderDate: Date
    _count: ServiceOrderCountAggregateOutputType | null
    _min: ServiceOrderMinAggregateOutputType | null
    _max: ServiceOrderMaxAggregateOutputType | null
  }

  type GetServiceOrderGroupByPayload<T extends ServiceOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceOrderGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceOrderGroupByOutputType[P]>
        }
      >
    >


  export type ServiceOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    serviceId?: boolean
    orderType?: boolean
    priority?: boolean
    clinicalIndication?: boolean
    isPaid?: boolean
    status?: boolean
    orderDate?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    labResults?: boolean | ServiceOrder$labResultsArgs<ExtArgs>
    invoiceItems?: boolean | ServiceOrder$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    serviceId?: boolean
    orderType?: boolean
    priority?: boolean
    clinicalIndication?: boolean
    isPaid?: boolean
    status?: boolean
    orderDate?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    serviceId?: boolean
    orderType?: boolean
    priority?: boolean
    clinicalIndication?: boolean
    isPaid?: boolean
    status?: boolean
    orderDate?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOrder"]>

  export type ServiceOrderSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    serviceId?: boolean
    orderType?: boolean
    priority?: boolean
    clinicalIndication?: boolean
    isPaid?: boolean
    status?: boolean
    orderDate?: boolean
  }

  export type ServiceOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "visitId" | "admissionId" | "serviceId" | "orderType" | "priority" | "clinicalIndication" | "isPaid" | "status" | "orderDate", ExtArgs["result"]["serviceOrder"]>
  export type ServiceOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    labResults?: boolean | ServiceOrder$labResultsArgs<ExtArgs>
    invoiceItems?: boolean | ServiceOrder$invoiceItemsArgs<ExtArgs>
    _count?: boolean | ServiceOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ServiceOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | ServiceOrder$visitArgs<ExtArgs>
    admission?: boolean | ServiceOrder$admissionArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ServiceOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceOrder"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$StaffProfilePayload<ExtArgs>
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
      labResults: Prisma.$LabResultPayload<ExtArgs>[]
      invoiceItems: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      visitId: string | null
      admissionId: string | null
      serviceId: string
      orderType: $Enums.OrderType
      priority: $Enums.OrderPriority
      clinicalIndication: string | null
      isPaid: boolean
      status: $Enums.OrderStatus
      orderDate: Date
    }, ExtArgs["result"]["serviceOrder"]>
    composites: {}
  }

  type ServiceOrderGetPayload<S extends boolean | null | undefined | ServiceOrderDefaultArgs> = $Result.GetResult<Prisma.$ServiceOrderPayload, S>

  type ServiceOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceOrderCountAggregateInputType | true
    }

  export interface ServiceOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceOrder'], meta: { name: 'ServiceOrder' } }
    /**
     * Find zero or one ServiceOrder that matches the filter.
     * @param {ServiceOrderFindUniqueArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceOrderFindUniqueArgs>(args: SelectSubset<T, ServiceOrderFindUniqueArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceOrderFindUniqueOrThrowArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindFirstArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceOrderFindFirstArgs>(args?: SelectSubset<T, ServiceOrderFindFirstArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindFirstOrThrowArgs} args - Arguments to find a ServiceOrder
     * @example
     * // Get one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceOrders
     * const serviceOrders = await prisma.serviceOrder.findMany()
     * 
     * // Get first 10 ServiceOrders
     * const serviceOrders = await prisma.serviceOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceOrderFindManyArgs>(args?: SelectSubset<T, ServiceOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceOrder.
     * @param {ServiceOrderCreateArgs} args - Arguments to create a ServiceOrder.
     * @example
     * // Create one ServiceOrder
     * const ServiceOrder = await prisma.serviceOrder.create({
     *   data: {
     *     // ... data to create a ServiceOrder
     *   }
     * })
     * 
     */
    create<T extends ServiceOrderCreateArgs>(args: SelectSubset<T, ServiceOrderCreateArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceOrders.
     * @param {ServiceOrderCreateManyArgs} args - Arguments to create many ServiceOrders.
     * @example
     * // Create many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceOrderCreateManyArgs>(args?: SelectSubset<T, ServiceOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceOrders and returns the data saved in the database.
     * @param {ServiceOrderCreateManyAndReturnArgs} args - Arguments to create many ServiceOrders.
     * @example
     * // Create many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceOrders and only return the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceOrder.
     * @param {ServiceOrderDeleteArgs} args - Arguments to delete one ServiceOrder.
     * @example
     * // Delete one ServiceOrder
     * const ServiceOrder = await prisma.serviceOrder.delete({
     *   where: {
     *     // ... filter to delete one ServiceOrder
     *   }
     * })
     * 
     */
    delete<T extends ServiceOrderDeleteArgs>(args: SelectSubset<T, ServiceOrderDeleteArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceOrder.
     * @param {ServiceOrderUpdateArgs} args - Arguments to update one ServiceOrder.
     * @example
     * // Update one ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceOrderUpdateArgs>(args: SelectSubset<T, ServiceOrderUpdateArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceOrders.
     * @param {ServiceOrderDeleteManyArgs} args - Arguments to filter ServiceOrders to delete.
     * @example
     * // Delete a few ServiceOrders
     * const { count } = await prisma.serviceOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceOrderDeleteManyArgs>(args?: SelectSubset<T, ServiceOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceOrderUpdateManyArgs>(args: SelectSubset<T, ServiceOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOrders and returns the data updated in the database.
     * @param {ServiceOrderUpdateManyAndReturnArgs} args - Arguments to update many ServiceOrders.
     * @example
     * // Update many ServiceOrders
     * const serviceOrder = await prisma.serviceOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceOrders and only return the `id`
     * const serviceOrderWithIdOnly = await prisma.serviceOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceOrder.
     * @param {ServiceOrderUpsertArgs} args - Arguments to update or create a ServiceOrder.
     * @example
     * // Update or create a ServiceOrder
     * const serviceOrder = await prisma.serviceOrder.upsert({
     *   create: {
     *     // ... data to create a ServiceOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceOrder we want to update
     *   }
     * })
     */
    upsert<T extends ServiceOrderUpsertArgs>(args: SelectSubset<T, ServiceOrderUpsertArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderCountArgs} args - Arguments to filter ServiceOrders to count.
     * @example
     * // Count the number of ServiceOrders
     * const count = await prisma.serviceOrder.count({
     *   where: {
     *     // ... the filter for the ServiceOrders we want to count
     *   }
     * })
    **/
    count<T extends ServiceOrderCountArgs>(
      args?: Subset<T, ServiceOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceOrderAggregateArgs>(args: Subset<T, ServiceOrderAggregateArgs>): Prisma.PrismaPromise<GetServiceOrderAggregateType<T>>

    /**
     * Group by ServiceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceOrderGroupByArgs['orderBy'] }
        : { orderBy?: ServiceOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceOrder model
   */
  readonly fields: ServiceOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visit<T extends ServiceOrder$visitArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOrder$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admission<T extends ServiceOrder$admissionArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOrder$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    labResults<T extends ServiceOrder$labResultsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOrder$labResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoiceItems<T extends ServiceOrder$invoiceItemsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOrder$invoiceItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceOrder model
   */
  interface ServiceOrderFieldRefs {
    readonly id: FieldRef<"ServiceOrder", 'String'>
    readonly patientId: FieldRef<"ServiceOrder", 'String'>
    readonly doctorId: FieldRef<"ServiceOrder", 'String'>
    readonly visitId: FieldRef<"ServiceOrder", 'String'>
    readonly admissionId: FieldRef<"ServiceOrder", 'String'>
    readonly serviceId: FieldRef<"ServiceOrder", 'String'>
    readonly orderType: FieldRef<"ServiceOrder", 'OrderType'>
    readonly priority: FieldRef<"ServiceOrder", 'OrderPriority'>
    readonly clinicalIndication: FieldRef<"ServiceOrder", 'String'>
    readonly isPaid: FieldRef<"ServiceOrder", 'Boolean'>
    readonly status: FieldRef<"ServiceOrder", 'OrderStatus'>
    readonly orderDate: FieldRef<"ServiceOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceOrder findUnique
   */
  export type ServiceOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder findUniqueOrThrow
   */
  export type ServiceOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder findFirst
   */
  export type ServiceOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOrders.
     */
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder findFirstOrThrow
   */
  export type ServiceOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrder to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOrders.
     */
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder findMany
   */
  export type ServiceOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOrders to fetch.
     */
    where?: ServiceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOrders to fetch.
     */
    orderBy?: ServiceOrderOrderByWithRelationInput | ServiceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceOrders.
     */
    cursor?: ServiceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOrders.
     */
    skip?: number
    distinct?: ServiceOrderScalarFieldEnum | ServiceOrderScalarFieldEnum[]
  }

  /**
   * ServiceOrder create
   */
  export type ServiceOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceOrder.
     */
    data: XOR<ServiceOrderCreateInput, ServiceOrderUncheckedCreateInput>
  }

  /**
   * ServiceOrder createMany
   */
  export type ServiceOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceOrders.
     */
    data: ServiceOrderCreateManyInput | ServiceOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceOrder createManyAndReturn
   */
  export type ServiceOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceOrders.
     */
    data: ServiceOrderCreateManyInput | ServiceOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceOrder update
   */
  export type ServiceOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceOrder.
     */
    data: XOR<ServiceOrderUpdateInput, ServiceOrderUncheckedUpdateInput>
    /**
     * Choose, which ServiceOrder to update.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder updateMany
   */
  export type ServiceOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceOrders.
     */
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOrders to update
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to update.
     */
    limit?: number
  }

  /**
   * ServiceOrder updateManyAndReturn
   */
  export type ServiceOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * The data used to update ServiceOrders.
     */
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOrders to update
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceOrder upsert
   */
  export type ServiceOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceOrder to update in case it exists.
     */
    where: ServiceOrderWhereUniqueInput
    /**
     * In case the ServiceOrder found by the `where` argument doesn't exist, create a new ServiceOrder with this data.
     */
    create: XOR<ServiceOrderCreateInput, ServiceOrderUncheckedCreateInput>
    /**
     * In case the ServiceOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceOrderUpdateInput, ServiceOrderUncheckedUpdateInput>
  }

  /**
   * ServiceOrder delete
   */
  export type ServiceOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    /**
     * Filter which ServiceOrder to delete.
     */
    where: ServiceOrderWhereUniqueInput
  }

  /**
   * ServiceOrder deleteMany
   */
  export type ServiceOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOrders to delete
     */
    where?: ServiceOrderWhereInput
    /**
     * Limit how many ServiceOrders to delete.
     */
    limit?: number
  }

  /**
   * ServiceOrder.visit
   */
  export type ServiceOrder$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * ServiceOrder.admission
   */
  export type ServiceOrder$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * ServiceOrder.labResults
   */
  export type ServiceOrder$labResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    cursor?: LabResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * ServiceOrder.invoiceItems
   */
  export type ServiceOrder$invoiceItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * ServiceOrder without action
   */
  export type ServiceOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
  }


  /**
   * Model LabResult
   */

  export type AggregateLabResult = {
    _count: LabResultCountAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  export type LabResultMinAggregateOutputType = {
    id: string | null
    serviceOrderId: string | null
    testName: string | null
    resultValue: string | null
    referenceRange: string | null
    unit: string | null
    technicianId: string | null
    verifiedByDoctorId: string | null
    resultDate: Date | null
  }

  export type LabResultMaxAggregateOutputType = {
    id: string | null
    serviceOrderId: string | null
    testName: string | null
    resultValue: string | null
    referenceRange: string | null
    unit: string | null
    technicianId: string | null
    verifiedByDoctorId: string | null
    resultDate: Date | null
  }

  export type LabResultCountAggregateOutputType = {
    id: number
    serviceOrderId: number
    testName: number
    resultValue: number
    referenceRange: number
    unit: number
    technicianId: number
    verifiedByDoctorId: number
    resultDate: number
    _all: number
  }


  export type LabResultMinAggregateInputType = {
    id?: true
    serviceOrderId?: true
    testName?: true
    resultValue?: true
    referenceRange?: true
    unit?: true
    technicianId?: true
    verifiedByDoctorId?: true
    resultDate?: true
  }

  export type LabResultMaxAggregateInputType = {
    id?: true
    serviceOrderId?: true
    testName?: true
    resultValue?: true
    referenceRange?: true
    unit?: true
    technicianId?: true
    verifiedByDoctorId?: true
    resultDate?: true
  }

  export type LabResultCountAggregateInputType = {
    id?: true
    serviceOrderId?: true
    testName?: true
    resultValue?: true
    referenceRange?: true
    unit?: true
    technicianId?: true
    verifiedByDoctorId?: true
    resultDate?: true
    _all?: true
  }

  export type LabResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResult to aggregate.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabResults
    **/
    _count?: true | LabResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabResultMaxAggregateInputType
  }

  export type GetLabResultAggregateType<T extends LabResultAggregateArgs> = {
        [P in keyof T & keyof AggregateLabResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabResult[P]>
      : GetScalarType<T[P], AggregateLabResult[P]>
  }




  export type LabResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabResultWhereInput
    orderBy?: LabResultOrderByWithAggregationInput | LabResultOrderByWithAggregationInput[]
    by: LabResultScalarFieldEnum[] | LabResultScalarFieldEnum
    having?: LabResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabResultCountAggregateInputType | true
    _min?: LabResultMinAggregateInputType
    _max?: LabResultMaxAggregateInputType
  }

  export type LabResultGroupByOutputType = {
    id: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange: string | null
    unit: string | null
    technicianId: string | null
    verifiedByDoctorId: string | null
    resultDate: Date
    _count: LabResultCountAggregateOutputType | null
    _min: LabResultMinAggregateOutputType | null
    _max: LabResultMaxAggregateOutputType | null
  }

  type GetLabResultGroupByPayload<T extends LabResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabResultGroupByOutputType[P]>
            : GetScalarType<T[P], LabResultGroupByOutputType[P]>
        }
      >
    >


  export type LabResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOrderId?: boolean
    testName?: boolean
    resultValue?: boolean
    referenceRange?: boolean
    unit?: boolean
    technicianId?: boolean
    verifiedByDoctorId?: boolean
    resultDate?: boolean
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOrderId?: boolean
    testName?: boolean
    resultValue?: boolean
    referenceRange?: boolean
    unit?: boolean
    technicianId?: boolean
    verifiedByDoctorId?: boolean
    resultDate?: boolean
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOrderId?: boolean
    testName?: boolean
    resultValue?: boolean
    referenceRange?: boolean
    unit?: boolean
    technicianId?: boolean
    verifiedByDoctorId?: boolean
    resultDate?: boolean
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }, ExtArgs["result"]["labResult"]>

  export type LabResultSelectScalar = {
    id?: boolean
    serviceOrderId?: boolean
    testName?: boolean
    resultValue?: boolean
    referenceRange?: boolean
    unit?: boolean
    technicianId?: boolean
    verifiedByDoctorId?: boolean
    resultDate?: boolean
  }

  export type LabResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceOrderId" | "testName" | "resultValue" | "referenceRange" | "unit" | "technicianId" | "verifiedByDoctorId" | "resultDate", ExtArgs["result"]["labResult"]>
  export type LabResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }
  export type LabResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }
  export type LabResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceOrder?: boolean | ServiceOrderDefaultArgs<ExtArgs>
    technician?: boolean | LabResult$technicianArgs<ExtArgs>
    verifiedBy?: boolean | LabResult$verifiedByArgs<ExtArgs>
  }

  export type $LabResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabResult"
    objects: {
      serviceOrder: Prisma.$ServiceOrderPayload<ExtArgs>
      technician: Prisma.$UserPayload<ExtArgs> | null
      verifiedBy: Prisma.$StaffProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceOrderId: string
      testName: string
      resultValue: string
      referenceRange: string | null
      unit: string | null
      technicianId: string | null
      verifiedByDoctorId: string | null
      resultDate: Date
    }, ExtArgs["result"]["labResult"]>
    composites: {}
  }

  type LabResultGetPayload<S extends boolean | null | undefined | LabResultDefaultArgs> = $Result.GetResult<Prisma.$LabResultPayload, S>

  type LabResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabResultCountAggregateInputType | true
    }

  export interface LabResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabResult'], meta: { name: 'LabResult' } }
    /**
     * Find zero or one LabResult that matches the filter.
     * @param {LabResultFindUniqueArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabResultFindUniqueArgs>(args: SelectSubset<T, LabResultFindUniqueArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabResultFindUniqueOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabResultFindUniqueOrThrowArgs>(args: SelectSubset<T, LabResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabResultFindFirstArgs>(args?: SelectSubset<T, LabResultFindFirstArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindFirstOrThrowArgs} args - Arguments to find a LabResult
     * @example
     * // Get one LabResult
     * const labResult = await prisma.labResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabResultFindFirstOrThrowArgs>(args?: SelectSubset<T, LabResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabResults
     * const labResults = await prisma.labResult.findMany()
     * 
     * // Get first 10 LabResults
     * const labResults = await prisma.labResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labResultWithIdOnly = await prisma.labResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabResultFindManyArgs>(args?: SelectSubset<T, LabResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabResult.
     * @param {LabResultCreateArgs} args - Arguments to create a LabResult.
     * @example
     * // Create one LabResult
     * const LabResult = await prisma.labResult.create({
     *   data: {
     *     // ... data to create a LabResult
     *   }
     * })
     * 
     */
    create<T extends LabResultCreateArgs>(args: SelectSubset<T, LabResultCreateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabResults.
     * @param {LabResultCreateManyArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabResultCreateManyArgs>(args?: SelectSubset<T, LabResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabResults and returns the data saved in the database.
     * @param {LabResultCreateManyAndReturnArgs} args - Arguments to create many LabResults.
     * @example
     * // Create many LabResults
     * const labResult = await prisma.labResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabResultCreateManyAndReturnArgs>(args?: SelectSubset<T, LabResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabResult.
     * @param {LabResultDeleteArgs} args - Arguments to delete one LabResult.
     * @example
     * // Delete one LabResult
     * const LabResult = await prisma.labResult.delete({
     *   where: {
     *     // ... filter to delete one LabResult
     *   }
     * })
     * 
     */
    delete<T extends LabResultDeleteArgs>(args: SelectSubset<T, LabResultDeleteArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabResult.
     * @param {LabResultUpdateArgs} args - Arguments to update one LabResult.
     * @example
     * // Update one LabResult
     * const labResult = await prisma.labResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabResultUpdateArgs>(args: SelectSubset<T, LabResultUpdateArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabResults.
     * @param {LabResultDeleteManyArgs} args - Arguments to filter LabResults to delete.
     * @example
     * // Delete a few LabResults
     * const { count } = await prisma.labResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabResultDeleteManyArgs>(args?: SelectSubset<T, LabResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabResultUpdateManyArgs>(args: SelectSubset<T, LabResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabResults and returns the data updated in the database.
     * @param {LabResultUpdateManyAndReturnArgs} args - Arguments to update many LabResults.
     * @example
     * // Update many LabResults
     * const labResult = await prisma.labResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabResults and only return the `id`
     * const labResultWithIdOnly = await prisma.labResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabResultUpdateManyAndReturnArgs>(args: SelectSubset<T, LabResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabResult.
     * @param {LabResultUpsertArgs} args - Arguments to update or create a LabResult.
     * @example
     * // Update or create a LabResult
     * const labResult = await prisma.labResult.upsert({
     *   create: {
     *     // ... data to create a LabResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabResult we want to update
     *   }
     * })
     */
    upsert<T extends LabResultUpsertArgs>(args: SelectSubset<T, LabResultUpsertArgs<ExtArgs>>): Prisma__LabResultClient<$Result.GetResult<Prisma.$LabResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultCountArgs} args - Arguments to filter LabResults to count.
     * @example
     * // Count the number of LabResults
     * const count = await prisma.labResult.count({
     *   where: {
     *     // ... the filter for the LabResults we want to count
     *   }
     * })
    **/
    count<T extends LabResultCountArgs>(
      args?: Subset<T, LabResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabResultAggregateArgs>(args: Subset<T, LabResultAggregateArgs>): Prisma.PrismaPromise<GetLabResultAggregateType<T>>

    /**
     * Group by LabResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabResultGroupByArgs['orderBy'] }
        : { orderBy?: LabResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabResult model
   */
  readonly fields: LabResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceOrder<T extends ServiceOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOrderDefaultArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    technician<T extends LabResult$technicianArgs<ExtArgs> = {}>(args?: Subset<T, LabResult$technicianArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    verifiedBy<T extends LabResult$verifiedByArgs<ExtArgs> = {}>(args?: Subset<T, LabResult$verifiedByArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabResult model
   */
  interface LabResultFieldRefs {
    readonly id: FieldRef<"LabResult", 'String'>
    readonly serviceOrderId: FieldRef<"LabResult", 'String'>
    readonly testName: FieldRef<"LabResult", 'String'>
    readonly resultValue: FieldRef<"LabResult", 'String'>
    readonly referenceRange: FieldRef<"LabResult", 'String'>
    readonly unit: FieldRef<"LabResult", 'String'>
    readonly technicianId: FieldRef<"LabResult", 'String'>
    readonly verifiedByDoctorId: FieldRef<"LabResult", 'String'>
    readonly resultDate: FieldRef<"LabResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabResult findUnique
   */
  export type LabResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findUniqueOrThrow
   */
  export type LabResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult findFirst
   */
  export type LabResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findFirstOrThrow
   */
  export type LabResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResult to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabResults.
     */
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult findMany
   */
  export type LabResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter, which LabResults to fetch.
     */
    where?: LabResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabResults to fetch.
     */
    orderBy?: LabResultOrderByWithRelationInput | LabResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabResults.
     */
    cursor?: LabResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabResults.
     */
    skip?: number
    distinct?: LabResultScalarFieldEnum | LabResultScalarFieldEnum[]
  }

  /**
   * LabResult create
   */
  export type LabResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to create a LabResult.
     */
    data: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
  }

  /**
   * LabResult createMany
   */
  export type LabResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabResult createManyAndReturn
   */
  export type LabResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to create many LabResults.
     */
    data: LabResultCreateManyInput | LabResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult update
   */
  export type LabResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The data needed to update a LabResult.
     */
    data: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
    /**
     * Choose, which LabResult to update.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult updateMany
   */
  export type LabResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
  }

  /**
   * LabResult updateManyAndReturn
   */
  export type LabResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * The data used to update LabResults.
     */
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyInput>
    /**
     * Filter which LabResults to update
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabResult upsert
   */
  export type LabResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * The filter to search for the LabResult to update in case it exists.
     */
    where: LabResultWhereUniqueInput
    /**
     * In case the LabResult found by the `where` argument doesn't exist, create a new LabResult with this data.
     */
    create: XOR<LabResultCreateInput, LabResultUncheckedCreateInput>
    /**
     * In case the LabResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabResultUpdateInput, LabResultUncheckedUpdateInput>
  }

  /**
   * LabResult delete
   */
  export type LabResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
    /**
     * Filter which LabResult to delete.
     */
    where: LabResultWhereUniqueInput
  }

  /**
   * LabResult deleteMany
   */
  export type LabResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabResults to delete
     */
    where?: LabResultWhereInput
    /**
     * Limit how many LabResults to delete.
     */
    limit?: number
  }

  /**
   * LabResult.technician
   */
  export type LabResult$technicianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LabResult.verifiedBy
   */
  export type LabResult$verifiedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * LabResult without action
   */
  export type LabResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabResult
     */
    select?: LabResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabResult
     */
    omit?: LabResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabResultInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    visitId: string | null
    admissionId: string | null
    isPaid: boolean | null
    date: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    doctorId: string | null
    visitId: string | null
    admissionId: string | null
    isPaid: boolean | null
    date: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    patientId: number
    doctorId: number
    visitId: number
    admissionId: number
    isPaid: number
    date: number
    _all: number
  }


  export type PrescriptionMinAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    isPaid?: true
    date?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    isPaid?: true
    date?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    patientId?: true
    doctorId?: true
    visitId?: true
    admissionId?: true
    isPaid?: true
    date?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: string
    patientId: string
    doctorId: string
    visitId: string | null
    admissionId: string | null
    isPaid: boolean
    date: Date
    _count: PrescriptionCountAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    isPaid?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    sales?: boolean | Prescription$salesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    isPaid?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    isPaid?: boolean
    date?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    patientId?: boolean
    doctorId?: boolean
    visitId?: boolean
    admissionId?: boolean
    isPaid?: boolean
    date?: boolean
  }

  export type PrescriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "doctorId" | "visitId" | "admissionId" | "isPaid" | "date", ExtArgs["result"]["prescription"]>
  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
    items?: boolean | Prescription$itemsArgs<ExtArgs>
    sales?: boolean | Prescription$salesArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
  }
  export type PrescriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    doctor?: boolean | StaffProfileDefaultArgs<ExtArgs>
    visit?: boolean | Prescription$visitArgs<ExtArgs>
    admission?: boolean | Prescription$admissionArgs<ExtArgs>
  }

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      doctor: Prisma.$StaffProfilePayload<ExtArgs>
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
      items: Prisma.$PrescriptionItemPayload<ExtArgs>[]
      sales: Prisma.$PharmacySalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      doctorId: string
      visitId: string | null
      admissionId: string | null
      isPaid: boolean
      date: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions and returns the data updated in the database.
     * @param {PrescriptionUpdateManyAndReturnArgs} args - Arguments to update many Prescriptions.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    doctor<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    visit<T extends Prescription$visitArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    admission<T extends Prescription$admissionArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Prescription$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends Prescription$salesArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'String'>
    readonly patientId: FieldRef<"Prescription", 'String'>
    readonly doctorId: FieldRef<"Prescription", 'String'>
    readonly visitId: FieldRef<"Prescription", 'String'>
    readonly admissionId: FieldRef<"Prescription", 'String'>
    readonly isPaid: FieldRef<"Prescription", 'Boolean'>
    readonly date: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
  }

  /**
   * Prescription updateManyAndReturn
   */
  export type PrescriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
    /**
     * Limit how many Prescriptions to delete.
     */
    limit?: number
  }

  /**
   * Prescription.visit
   */
  export type Prescription$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * Prescription.admission
   */
  export type Prescription$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * Prescription.items
   */
  export type Prescription$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Prescription.sales
   */
  export type Prescription$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    where?: PharmacySaleWhereInput
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    cursor?: PharmacySaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PharmacySaleScalarFieldEnum | PharmacySaleScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model PrescriptionItem
   */

  export type AggregatePrescriptionItem = {
    _count: PrescriptionItemCountAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  export type PrescriptionItemMinAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicineId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instruction: string | null
  }

  export type PrescriptionItemMaxAggregateOutputType = {
    id: string | null
    prescriptionId: string | null
    medicineId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instruction: string | null
  }

  export type PrescriptionItemCountAggregateOutputType = {
    id: number
    prescriptionId: number
    medicineId: number
    dosage: number
    frequency: number
    duration: number
    instruction: number
    _all: number
  }


  export type PrescriptionItemMinAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instruction?: true
  }

  export type PrescriptionItemMaxAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instruction?: true
  }

  export type PrescriptionItemCountAggregateInputType = {
    id?: true
    prescriptionId?: true
    medicineId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instruction?: true
    _all?: true
  }

  export type PrescriptionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItem to aggregate.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrescriptionItems
    **/
    _count?: true | PrescriptionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type GetPrescriptionItemAggregateType<T extends PrescriptionItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescriptionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescriptionItem[P]>
      : GetScalarType<T[P], AggregatePrescriptionItem[P]>
  }




  export type PrescriptionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithAggregationInput | PrescriptionItemOrderByWithAggregationInput[]
    by: PrescriptionItemScalarFieldEnum[] | PrescriptionItemScalarFieldEnum
    having?: PrescriptionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionItemCountAggregateInputType | true
    _min?: PrescriptionItemMinAggregateInputType
    _max?: PrescriptionItemMaxAggregateInputType
  }

  export type PrescriptionItemGroupByOutputType = {
    id: string
    prescriptionId: string
    medicineId: string
    dosage: string
    frequency: string
    duration: string
    instruction: string | null
    _count: PrescriptionItemCountAggregateOutputType | null
    _min: PrescriptionItemMinAggregateOutputType | null
    _max: PrescriptionItemMaxAggregateOutputType | null
  }

  type GetPrescriptionItemGroupByPayload<T extends PrescriptionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionItemGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instruction?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instruction?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instruction?: boolean
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescriptionItem"]>

  export type PrescriptionItemSelectScalar = {
    id?: boolean
    prescriptionId?: boolean
    medicineId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instruction?: boolean
  }

  export type PrescriptionItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prescriptionId" | "medicineId" | "dosage" | "frequency" | "duration" | "instruction", ExtArgs["result"]["prescriptionItem"]>
  export type PrescriptionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescription?: boolean | PrescriptionDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $PrescriptionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrescriptionItem"
    objects: {
      prescription: Prisma.$PrescriptionPayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prescriptionId: string
      medicineId: string
      dosage: string
      frequency: string
      duration: string
      instruction: string | null
    }, ExtArgs["result"]["prescriptionItem"]>
    composites: {}
  }

  type PrescriptionItemGetPayload<S extends boolean | null | undefined | PrescriptionItemDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionItemPayload, S>

  type PrescriptionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrescriptionItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrescriptionItemCountAggregateInputType | true
    }

  export interface PrescriptionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrescriptionItem'], meta: { name: 'PrescriptionItem' } }
    /**
     * Find zero or one PrescriptionItem that matches the filter.
     * @param {PrescriptionItemFindUniqueArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionItemFindUniqueArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrescriptionItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrescriptionItemFindUniqueOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionItemFindFirstArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrescriptionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindFirstOrThrowArgs} args - Arguments to find a PrescriptionItem
     * @example
     * // Get one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrescriptionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany()
     * 
     * // Get first 10 PrescriptionItems
     * const prescriptionItems = await prisma.prescriptionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionItemFindManyArgs>(args?: SelectSubset<T, PrescriptionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrescriptionItem.
     * @param {PrescriptionItemCreateArgs} args - Arguments to create a PrescriptionItem.
     * @example
     * // Create one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.create({
     *   data: {
     *     // ... data to create a PrescriptionItem
     *   }
     * })
     * 
     */
    create<T extends PrescriptionItemCreateArgs>(args: SelectSubset<T, PrescriptionItemCreateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrescriptionItems.
     * @param {PrescriptionItemCreateManyArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionItemCreateManyArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrescriptionItems and returns the data saved in the database.
     * @param {PrescriptionItemCreateManyAndReturnArgs} args - Arguments to create many PrescriptionItems.
     * @example
     * // Create many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrescriptionItem.
     * @param {PrescriptionItemDeleteArgs} args - Arguments to delete one PrescriptionItem.
     * @example
     * // Delete one PrescriptionItem
     * const PrescriptionItem = await prisma.prescriptionItem.delete({
     *   where: {
     *     // ... filter to delete one PrescriptionItem
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionItemDeleteArgs>(args: SelectSubset<T, PrescriptionItemDeleteArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrescriptionItem.
     * @param {PrescriptionItemUpdateArgs} args - Arguments to update one PrescriptionItem.
     * @example
     * // Update one PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionItemUpdateArgs>(args: SelectSubset<T, PrescriptionItemUpdateArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrescriptionItems.
     * @param {PrescriptionItemDeleteManyArgs} args - Arguments to filter PrescriptionItems to delete.
     * @example
     * // Delete a few PrescriptionItems
     * const { count } = await prisma.prescriptionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionItemDeleteManyArgs>(args?: SelectSubset<T, PrescriptionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionItemUpdateManyArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrescriptionItems and returns the data updated in the database.
     * @param {PrescriptionItemUpdateManyAndReturnArgs} args - Arguments to update many PrescriptionItems.
     * @example
     * // Update many PrescriptionItems
     * const prescriptionItem = await prisma.prescriptionItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrescriptionItems and only return the `id`
     * const prescriptionItemWithIdOnly = await prisma.prescriptionItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrescriptionItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PrescriptionItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrescriptionItem.
     * @param {PrescriptionItemUpsertArgs} args - Arguments to update or create a PrescriptionItem.
     * @example
     * // Update or create a PrescriptionItem
     * const prescriptionItem = await prisma.prescriptionItem.upsert({
     *   create: {
     *     // ... data to create a PrescriptionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrescriptionItem we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionItemUpsertArgs>(args: SelectSubset<T, PrescriptionItemUpsertArgs<ExtArgs>>): Prisma__PrescriptionItemClient<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrescriptionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemCountArgs} args - Arguments to filter PrescriptionItems to count.
     * @example
     * // Count the number of PrescriptionItems
     * const count = await prisma.prescriptionItem.count({
     *   where: {
     *     // ... the filter for the PrescriptionItems we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionItemCountArgs>(
      args?: Subset<T, PrescriptionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionItemAggregateArgs>(args: Subset<T, PrescriptionItemAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionItemAggregateType<T>>

    /**
     * Group by PrescriptionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionItemGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrescriptionItem model
   */
  readonly fields: PrescriptionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrescriptionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescription<T extends PrescriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrescriptionDefaultArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrescriptionItem model
   */
  interface PrescriptionItemFieldRefs {
    readonly id: FieldRef<"PrescriptionItem", 'String'>
    readonly prescriptionId: FieldRef<"PrescriptionItem", 'String'>
    readonly medicineId: FieldRef<"PrescriptionItem", 'String'>
    readonly dosage: FieldRef<"PrescriptionItem", 'String'>
    readonly frequency: FieldRef<"PrescriptionItem", 'String'>
    readonly duration: FieldRef<"PrescriptionItem", 'String'>
    readonly instruction: FieldRef<"PrescriptionItem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrescriptionItem findUnique
   */
  export type PrescriptionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findUniqueOrThrow
   */
  export type PrescriptionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem findFirst
   */
  export type PrescriptionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findFirstOrThrow
   */
  export type PrescriptionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItem to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrescriptionItems.
     */
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem findMany
   */
  export type PrescriptionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter, which PrescriptionItems to fetch.
     */
    where?: PrescriptionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrescriptionItems to fetch.
     */
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrescriptionItems.
     */
    cursor?: PrescriptionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrescriptionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrescriptionItems.
     */
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * PrescriptionItem create
   */
  export type PrescriptionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PrescriptionItem.
     */
    data: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
  }

  /**
   * PrescriptionItem createMany
   */
  export type PrescriptionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrescriptionItem createManyAndReturn
   */
  export type PrescriptionItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to create many PrescriptionItems.
     */
    data: PrescriptionItemCreateManyInput | PrescriptionItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem update
   */
  export type PrescriptionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PrescriptionItem.
     */
    data: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
    /**
     * Choose, which PrescriptionItem to update.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem updateMany
   */
  export type PrescriptionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
  }

  /**
   * PrescriptionItem updateManyAndReturn
   */
  export type PrescriptionItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * The data used to update PrescriptionItems.
     */
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyInput>
    /**
     * Filter which PrescriptionItems to update
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrescriptionItem upsert
   */
  export type PrescriptionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PrescriptionItem to update in case it exists.
     */
    where: PrescriptionItemWhereUniqueInput
    /**
     * In case the PrescriptionItem found by the `where` argument doesn't exist, create a new PrescriptionItem with this data.
     */
    create: XOR<PrescriptionItemCreateInput, PrescriptionItemUncheckedCreateInput>
    /**
     * In case the PrescriptionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionItemUpdateInput, PrescriptionItemUncheckedUpdateInput>
  }

  /**
   * PrescriptionItem delete
   */
  export type PrescriptionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    /**
     * Filter which PrescriptionItem to delete.
     */
    where: PrescriptionItemWhereUniqueInput
  }

  /**
   * PrescriptionItem deleteMany
   */
  export type PrescriptionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrescriptionItems to delete
     */
    where?: PrescriptionItemWhereInput
    /**
     * Limit how many PrescriptionItems to delete.
     */
    limit?: number
  }

  /**
   * PrescriptionItem without action
   */
  export type PrescriptionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
  }


  /**
   * Model Medicine
   */

  export type AggregateMedicine = {
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  export type MedicineAvgAggregateOutputType = {
    stockQuantity: number | null
    reorderLevel: number | null
    unitPrice: Decimal | null
  }

  export type MedicineSumAggregateOutputType = {
    stockQuantity: number | null
    reorderLevel: number | null
    unitPrice: Decimal | null
  }

  export type MedicineMinAggregateOutputType = {
    id: string | null
    name: string | null
    genericName: string | null
    batchNumber: string | null
    expiryDate: Date | null
    stockQuantity: number | null
    reorderLevel: number | null
    unitPrice: Decimal | null
  }

  export type MedicineMaxAggregateOutputType = {
    id: string | null
    name: string | null
    genericName: string | null
    batchNumber: string | null
    expiryDate: Date | null
    stockQuantity: number | null
    reorderLevel: number | null
    unitPrice: Decimal | null
  }

  export type MedicineCountAggregateOutputType = {
    id: number
    name: number
    genericName: number
    batchNumber: number
    expiryDate: number
    stockQuantity: number
    reorderLevel: number
    unitPrice: number
    _all: number
  }


  export type MedicineAvgAggregateInputType = {
    stockQuantity?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type MedicineSumAggregateInputType = {
    stockQuantity?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type MedicineMinAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    batchNumber?: true
    expiryDate?: true
    stockQuantity?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type MedicineMaxAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    batchNumber?: true
    expiryDate?: true
    stockQuantity?: true
    reorderLevel?: true
    unitPrice?: true
  }

  export type MedicineCountAggregateInputType = {
    id?: true
    name?: true
    genericName?: true
    batchNumber?: true
    expiryDate?: true
    stockQuantity?: true
    reorderLevel?: true
    unitPrice?: true
    _all?: true
  }

  export type MedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicine to aggregate.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicines
    **/
    _count?: true | MedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineMaxAggregateInputType
  }

  export type GetMedicineAggregateType<T extends MedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicine[P]>
      : GetScalarType<T[P], AggregateMedicine[P]>
  }




  export type MedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithAggregationInput | MedicineOrderByWithAggregationInput[]
    by: MedicineScalarFieldEnum[] | MedicineScalarFieldEnum
    having?: MedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineCountAggregateInputType | true
    _avg?: MedicineAvgAggregateInputType
    _sum?: MedicineSumAggregateInputType
    _min?: MedicineMinAggregateInputType
    _max?: MedicineMaxAggregateInputType
  }

  export type MedicineGroupByOutputType = {
    id: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  type GetMedicineGroupByPayload<T extends MedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineGroupByOutputType[P]>
        }
      >
    >


  export type MedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
    prescriptionItems?: boolean | Medicine$prescriptionItemsArgs<ExtArgs>
    saleItems?: boolean | Medicine$saleItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    genericName?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectScalar = {
    id?: boolean
    name?: boolean
    genericName?: boolean
    batchNumber?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    reorderLevel?: boolean
    unitPrice?: boolean
  }

  export type MedicineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "genericName" | "batchNumber" | "expiryDate" | "stockQuantity" | "reorderLevel" | "unitPrice", ExtArgs["result"]["medicine"]>
  export type MedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    prescriptionItems?: boolean | Medicine$prescriptionItemsArgs<ExtArgs>
    saleItems?: boolean | Medicine$saleItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MedicineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicine"
    objects: {
      prescriptionItems: Prisma.$PrescriptionItemPayload<ExtArgs>[]
      saleItems: Prisma.$SaleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      genericName: string
      batchNumber: string
      expiryDate: Date
      stockQuantity: number
      reorderLevel: number
      unitPrice: Prisma.Decimal
    }, ExtArgs["result"]["medicine"]>
    composites: {}
  }

  type MedicineGetPayload<S extends boolean | null | undefined | MedicineDefaultArgs> = $Result.GetResult<Prisma.$MedicinePayload, S>

  type MedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicineCountAggregateInputType | true
    }

  export interface MedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicine'], meta: { name: 'Medicine' } }
    /**
     * Find zero or one Medicine that matches the filter.
     * @param {MedicineFindUniqueArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineFindUniqueArgs>(args: SelectSubset<T, MedicineFindUniqueArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medicine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicineFindUniqueOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineFindFirstArgs>(args?: SelectSubset<T, MedicineFindFirstArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicines
     * const medicines = await prisma.medicine.findMany()
     * 
     * // Get first 10 Medicines
     * const medicines = await prisma.medicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineWithIdOnly = await prisma.medicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineFindManyArgs>(args?: SelectSubset<T, MedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medicine.
     * @param {MedicineCreateArgs} args - Arguments to create a Medicine.
     * @example
     * // Create one Medicine
     * const Medicine = await prisma.medicine.create({
     *   data: {
     *     // ... data to create a Medicine
     *   }
     * })
     * 
     */
    create<T extends MedicineCreateArgs>(args: SelectSubset<T, MedicineCreateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medicines.
     * @param {MedicineCreateManyArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineCreateManyArgs>(args?: SelectSubset<T, MedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicines and returns the data saved in the database.
     * @param {MedicineCreateManyAndReturnArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medicine.
     * @param {MedicineDeleteArgs} args - Arguments to delete one Medicine.
     * @example
     * // Delete one Medicine
     * const Medicine = await prisma.medicine.delete({
     *   where: {
     *     // ... filter to delete one Medicine
     *   }
     * })
     * 
     */
    delete<T extends MedicineDeleteArgs>(args: SelectSubset<T, MedicineDeleteArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medicine.
     * @param {MedicineUpdateArgs} args - Arguments to update one Medicine.
     * @example
     * // Update one Medicine
     * const medicine = await prisma.medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineUpdateArgs>(args: SelectSubset<T, MedicineUpdateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medicines.
     * @param {MedicineDeleteManyArgs} args - Arguments to filter Medicines to delete.
     * @example
     * // Delete a few Medicines
     * const { count } = await prisma.medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineDeleteManyArgs>(args?: SelectSubset<T, MedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineUpdateManyArgs>(args: SelectSubset<T, MedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines and returns the data updated in the database.
     * @param {MedicineUpdateManyAndReturnArgs} args - Arguments to update many Medicines.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MedicineUpdateManyAndReturnArgs>(args: SelectSubset<T, MedicineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medicine.
     * @param {MedicineUpsertArgs} args - Arguments to update or create a Medicine.
     * @example
     * // Update or create a Medicine
     * const medicine = await prisma.medicine.upsert({
     *   create: {
     *     // ... data to create a Medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicine we want to update
     *   }
     * })
     */
    upsert<T extends MedicineUpsertArgs>(args: SelectSubset<T, MedicineUpsertArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineCountArgs} args - Arguments to filter Medicines to count.
     * @example
     * // Count the number of Medicines
     * const count = await prisma.medicine.count({
     *   where: {
     *     // ... the filter for the Medicines we want to count
     *   }
     * })
    **/
    count<T extends MedicineCountArgs>(
      args?: Subset<T, MedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAggregateArgs>(args: Subset<T, MedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicineAggregateType<T>>

    /**
     * Group by Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineGroupByArgs['orderBy'] }
        : { orderBy?: MedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicine model
   */
  readonly fields: MedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    prescriptionItems<T extends Medicine$prescriptionItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$prescriptionItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    saleItems<T extends Medicine$saleItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$saleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicine model
   */
  interface MedicineFieldRefs {
    readonly id: FieldRef<"Medicine", 'String'>
    readonly name: FieldRef<"Medicine", 'String'>
    readonly genericName: FieldRef<"Medicine", 'String'>
    readonly batchNumber: FieldRef<"Medicine", 'String'>
    readonly expiryDate: FieldRef<"Medicine", 'DateTime'>
    readonly stockQuantity: FieldRef<"Medicine", 'Int'>
    readonly reorderLevel: FieldRef<"Medicine", 'Int'>
    readonly unitPrice: FieldRef<"Medicine", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * Medicine findUnique
   */
  export type MedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findUniqueOrThrow
   */
  export type MedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findFirst
   */
  export type MedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findFirstOrThrow
   */
  export type MedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findMany
   */
  export type MedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicines to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine create
   */
  export type MedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicine.
     */
    data: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
  }

  /**
   * Medicine createMany
   */
  export type MedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicine createManyAndReturn
   */
  export type MedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Medicine update
   */
  export type MedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicine.
     */
    data: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
    /**
     * Choose, which Medicine to update.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine updateMany
   */
  export type MedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
  }

  /**
   * Medicine updateManyAndReturn
   */
  export type MedicineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to update.
     */
    limit?: number
  }

  /**
   * Medicine upsert
   */
  export type MedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicine to update in case it exists.
     */
    where: MedicineWhereUniqueInput
    /**
     * In case the Medicine found by the `where` argument doesn't exist, create a new Medicine with this data.
     */
    create: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
    /**
     * In case the Medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
  }

  /**
   * Medicine delete
   */
  export type MedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter which Medicine to delete.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine deleteMany
   */
  export type MedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicines to delete
     */
    where?: MedicineWhereInput
    /**
     * Limit how many Medicines to delete.
     */
    limit?: number
  }

  /**
   * Medicine.prescriptionItems
   */
  export type Medicine$prescriptionItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionItem
     */
    select?: PrescriptionItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrescriptionItem
     */
    omit?: PrescriptionItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionItemInclude<ExtArgs> | null
    where?: PrescriptionItemWhereInput
    orderBy?: PrescriptionItemOrderByWithRelationInput | PrescriptionItemOrderByWithRelationInput[]
    cursor?: PrescriptionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrescriptionItemScalarFieldEnum | PrescriptionItemScalarFieldEnum[]
  }

  /**
   * Medicine.saleItems
   */
  export type Medicine$saleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * Medicine without action
   */
  export type MedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medicine
     */
    omit?: MedicineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
  }


  /**
   * Model PharmacySale
   */

  export type AggregatePharmacySale = {
    _count: PharmacySaleCountAggregateOutputType | null
    _avg: PharmacySaleAvgAggregateOutputType | null
    _sum: PharmacySaleSumAggregateOutputType | null
    _min: PharmacySaleMinAggregateOutputType | null
    _max: PharmacySaleMaxAggregateOutputType | null
  }

  export type PharmacySaleAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PharmacySaleSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type PharmacySaleMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    prescriptionId: string | null
    saleDate: Date | null
    totalAmount: Decimal | null
  }

  export type PharmacySaleMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    prescriptionId: string | null
    saleDate: Date | null
    totalAmount: Decimal | null
  }

  export type PharmacySaleCountAggregateOutputType = {
    id: number
    patientId: number
    prescriptionId: number
    saleDate: number
    totalAmount: number
    _all: number
  }


  export type PharmacySaleAvgAggregateInputType = {
    totalAmount?: true
  }

  export type PharmacySaleSumAggregateInputType = {
    totalAmount?: true
  }

  export type PharmacySaleMinAggregateInputType = {
    id?: true
    patientId?: true
    prescriptionId?: true
    saleDate?: true
    totalAmount?: true
  }

  export type PharmacySaleMaxAggregateInputType = {
    id?: true
    patientId?: true
    prescriptionId?: true
    saleDate?: true
    totalAmount?: true
  }

  export type PharmacySaleCountAggregateInputType = {
    id?: true
    patientId?: true
    prescriptionId?: true
    saleDate?: true
    totalAmount?: true
    _all?: true
  }

  export type PharmacySaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacySale to aggregate.
     */
    where?: PharmacySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacySales to fetch.
     */
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PharmacySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PharmacySales
    **/
    _count?: true | PharmacySaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PharmacySaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PharmacySaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PharmacySaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PharmacySaleMaxAggregateInputType
  }

  export type GetPharmacySaleAggregateType<T extends PharmacySaleAggregateArgs> = {
        [P in keyof T & keyof AggregatePharmacySale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePharmacySale[P]>
      : GetScalarType<T[P], AggregatePharmacySale[P]>
  }




  export type PharmacySaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PharmacySaleWhereInput
    orderBy?: PharmacySaleOrderByWithAggregationInput | PharmacySaleOrderByWithAggregationInput[]
    by: PharmacySaleScalarFieldEnum[] | PharmacySaleScalarFieldEnum
    having?: PharmacySaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PharmacySaleCountAggregateInputType | true
    _avg?: PharmacySaleAvgAggregateInputType
    _sum?: PharmacySaleSumAggregateInputType
    _min?: PharmacySaleMinAggregateInputType
    _max?: PharmacySaleMaxAggregateInputType
  }

  export type PharmacySaleGroupByOutputType = {
    id: string
    patientId: string
    prescriptionId: string | null
    saleDate: Date
    totalAmount: Decimal
    _count: PharmacySaleCountAggregateOutputType | null
    _avg: PharmacySaleAvgAggregateOutputType | null
    _sum: PharmacySaleSumAggregateOutputType | null
    _min: PharmacySaleMinAggregateOutputType | null
    _max: PharmacySaleMaxAggregateOutputType | null
  }

  type GetPharmacySaleGroupByPayload<T extends PharmacySaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PharmacySaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PharmacySaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PharmacySaleGroupByOutputType[P]>
            : GetScalarType<T[P], PharmacySaleGroupByOutputType[P]>
        }
      >
    >


  export type PharmacySaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    prescriptionId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
    items?: boolean | PharmacySale$itemsArgs<ExtArgs>
    _count?: boolean | PharmacySaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacySale"]>

  export type PharmacySaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    prescriptionId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacySale"]>

  export type PharmacySaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    prescriptionId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["pharmacySale"]>

  export type PharmacySaleSelectScalar = {
    id?: boolean
    patientId?: boolean
    prescriptionId?: boolean
    saleDate?: boolean
    totalAmount?: boolean
  }

  export type PharmacySaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "prescriptionId" | "saleDate" | "totalAmount", ExtArgs["result"]["pharmacySale"]>
  export type PharmacySaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
    items?: boolean | PharmacySale$itemsArgs<ExtArgs>
    _count?: boolean | PharmacySaleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PharmacySaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
  }
  export type PharmacySaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    prescription?: boolean | PharmacySale$prescriptionArgs<ExtArgs>
  }

  export type $PharmacySalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PharmacySale"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
      items: Prisma.$SaleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      prescriptionId: string | null
      saleDate: Date
      totalAmount: Prisma.Decimal
    }, ExtArgs["result"]["pharmacySale"]>
    composites: {}
  }

  type PharmacySaleGetPayload<S extends boolean | null | undefined | PharmacySaleDefaultArgs> = $Result.GetResult<Prisma.$PharmacySalePayload, S>

  type PharmacySaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PharmacySaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PharmacySaleCountAggregateInputType | true
    }

  export interface PharmacySaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PharmacySale'], meta: { name: 'PharmacySale' } }
    /**
     * Find zero or one PharmacySale that matches the filter.
     * @param {PharmacySaleFindUniqueArgs} args - Arguments to find a PharmacySale
     * @example
     * // Get one PharmacySale
     * const pharmacySale = await prisma.pharmacySale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PharmacySaleFindUniqueArgs>(args: SelectSubset<T, PharmacySaleFindUniqueArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PharmacySale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PharmacySaleFindUniqueOrThrowArgs} args - Arguments to find a PharmacySale
     * @example
     * // Get one PharmacySale
     * const pharmacySale = await prisma.pharmacySale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PharmacySaleFindUniqueOrThrowArgs>(args: SelectSubset<T, PharmacySaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacySale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleFindFirstArgs} args - Arguments to find a PharmacySale
     * @example
     * // Get one PharmacySale
     * const pharmacySale = await prisma.pharmacySale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PharmacySaleFindFirstArgs>(args?: SelectSubset<T, PharmacySaleFindFirstArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PharmacySale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleFindFirstOrThrowArgs} args - Arguments to find a PharmacySale
     * @example
     * // Get one PharmacySale
     * const pharmacySale = await prisma.pharmacySale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PharmacySaleFindFirstOrThrowArgs>(args?: SelectSubset<T, PharmacySaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PharmacySales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PharmacySales
     * const pharmacySales = await prisma.pharmacySale.findMany()
     * 
     * // Get first 10 PharmacySales
     * const pharmacySales = await prisma.pharmacySale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pharmacySaleWithIdOnly = await prisma.pharmacySale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PharmacySaleFindManyArgs>(args?: SelectSubset<T, PharmacySaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PharmacySale.
     * @param {PharmacySaleCreateArgs} args - Arguments to create a PharmacySale.
     * @example
     * // Create one PharmacySale
     * const PharmacySale = await prisma.pharmacySale.create({
     *   data: {
     *     // ... data to create a PharmacySale
     *   }
     * })
     * 
     */
    create<T extends PharmacySaleCreateArgs>(args: SelectSubset<T, PharmacySaleCreateArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PharmacySales.
     * @param {PharmacySaleCreateManyArgs} args - Arguments to create many PharmacySales.
     * @example
     * // Create many PharmacySales
     * const pharmacySale = await prisma.pharmacySale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PharmacySaleCreateManyArgs>(args?: SelectSubset<T, PharmacySaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PharmacySales and returns the data saved in the database.
     * @param {PharmacySaleCreateManyAndReturnArgs} args - Arguments to create many PharmacySales.
     * @example
     * // Create many PharmacySales
     * const pharmacySale = await prisma.pharmacySale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PharmacySales and only return the `id`
     * const pharmacySaleWithIdOnly = await prisma.pharmacySale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PharmacySaleCreateManyAndReturnArgs>(args?: SelectSubset<T, PharmacySaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PharmacySale.
     * @param {PharmacySaleDeleteArgs} args - Arguments to delete one PharmacySale.
     * @example
     * // Delete one PharmacySale
     * const PharmacySale = await prisma.pharmacySale.delete({
     *   where: {
     *     // ... filter to delete one PharmacySale
     *   }
     * })
     * 
     */
    delete<T extends PharmacySaleDeleteArgs>(args: SelectSubset<T, PharmacySaleDeleteArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PharmacySale.
     * @param {PharmacySaleUpdateArgs} args - Arguments to update one PharmacySale.
     * @example
     * // Update one PharmacySale
     * const pharmacySale = await prisma.pharmacySale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PharmacySaleUpdateArgs>(args: SelectSubset<T, PharmacySaleUpdateArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PharmacySales.
     * @param {PharmacySaleDeleteManyArgs} args - Arguments to filter PharmacySales to delete.
     * @example
     * // Delete a few PharmacySales
     * const { count } = await prisma.pharmacySale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PharmacySaleDeleteManyArgs>(args?: SelectSubset<T, PharmacySaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacySales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PharmacySales
     * const pharmacySale = await prisma.pharmacySale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PharmacySaleUpdateManyArgs>(args: SelectSubset<T, PharmacySaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PharmacySales and returns the data updated in the database.
     * @param {PharmacySaleUpdateManyAndReturnArgs} args - Arguments to update many PharmacySales.
     * @example
     * // Update many PharmacySales
     * const pharmacySale = await prisma.pharmacySale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PharmacySales and only return the `id`
     * const pharmacySaleWithIdOnly = await prisma.pharmacySale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PharmacySaleUpdateManyAndReturnArgs>(args: SelectSubset<T, PharmacySaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PharmacySale.
     * @param {PharmacySaleUpsertArgs} args - Arguments to update or create a PharmacySale.
     * @example
     * // Update or create a PharmacySale
     * const pharmacySale = await prisma.pharmacySale.upsert({
     *   create: {
     *     // ... data to create a PharmacySale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PharmacySale we want to update
     *   }
     * })
     */
    upsert<T extends PharmacySaleUpsertArgs>(args: SelectSubset<T, PharmacySaleUpsertArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PharmacySales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleCountArgs} args - Arguments to filter PharmacySales to count.
     * @example
     * // Count the number of PharmacySales
     * const count = await prisma.pharmacySale.count({
     *   where: {
     *     // ... the filter for the PharmacySales we want to count
     *   }
     * })
    **/
    count<T extends PharmacySaleCountArgs>(
      args?: Subset<T, PharmacySaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PharmacySaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PharmacySale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PharmacySaleAggregateArgs>(args: Subset<T, PharmacySaleAggregateArgs>): Prisma.PrismaPromise<GetPharmacySaleAggregateType<T>>

    /**
     * Group by PharmacySale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PharmacySaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PharmacySaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PharmacySaleGroupByArgs['orderBy'] }
        : { orderBy?: PharmacySaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PharmacySaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPharmacySaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PharmacySale model
   */
  readonly fields: PharmacySaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PharmacySale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PharmacySaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    prescription<T extends PharmacySale$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, PharmacySale$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends PharmacySale$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PharmacySale$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PharmacySale model
   */
  interface PharmacySaleFieldRefs {
    readonly id: FieldRef<"PharmacySale", 'String'>
    readonly patientId: FieldRef<"PharmacySale", 'String'>
    readonly prescriptionId: FieldRef<"PharmacySale", 'String'>
    readonly saleDate: FieldRef<"PharmacySale", 'DateTime'>
    readonly totalAmount: FieldRef<"PharmacySale", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * PharmacySale findUnique
   */
  export type PharmacySaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter, which PharmacySale to fetch.
     */
    where: PharmacySaleWhereUniqueInput
  }

  /**
   * PharmacySale findUniqueOrThrow
   */
  export type PharmacySaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter, which PharmacySale to fetch.
     */
    where: PharmacySaleWhereUniqueInput
  }

  /**
   * PharmacySale findFirst
   */
  export type PharmacySaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter, which PharmacySale to fetch.
     */
    where?: PharmacySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacySales to fetch.
     */
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacySales.
     */
    cursor?: PharmacySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacySales.
     */
    distinct?: PharmacySaleScalarFieldEnum | PharmacySaleScalarFieldEnum[]
  }

  /**
   * PharmacySale findFirstOrThrow
   */
  export type PharmacySaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter, which PharmacySale to fetch.
     */
    where?: PharmacySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacySales to fetch.
     */
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PharmacySales.
     */
    cursor?: PharmacySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacySales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PharmacySales.
     */
    distinct?: PharmacySaleScalarFieldEnum | PharmacySaleScalarFieldEnum[]
  }

  /**
   * PharmacySale findMany
   */
  export type PharmacySaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter, which PharmacySales to fetch.
     */
    where?: PharmacySaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PharmacySales to fetch.
     */
    orderBy?: PharmacySaleOrderByWithRelationInput | PharmacySaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PharmacySales.
     */
    cursor?: PharmacySaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PharmacySales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PharmacySales.
     */
    skip?: number
    distinct?: PharmacySaleScalarFieldEnum | PharmacySaleScalarFieldEnum[]
  }

  /**
   * PharmacySale create
   */
  export type PharmacySaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * The data needed to create a PharmacySale.
     */
    data: XOR<PharmacySaleCreateInput, PharmacySaleUncheckedCreateInput>
  }

  /**
   * PharmacySale createMany
   */
  export type PharmacySaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PharmacySales.
     */
    data: PharmacySaleCreateManyInput | PharmacySaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PharmacySale createManyAndReturn
   */
  export type PharmacySaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * The data used to create many PharmacySales.
     */
    data: PharmacySaleCreateManyInput | PharmacySaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacySale update
   */
  export type PharmacySaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * The data needed to update a PharmacySale.
     */
    data: XOR<PharmacySaleUpdateInput, PharmacySaleUncheckedUpdateInput>
    /**
     * Choose, which PharmacySale to update.
     */
    where: PharmacySaleWhereUniqueInput
  }

  /**
   * PharmacySale updateMany
   */
  export type PharmacySaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PharmacySales.
     */
    data: XOR<PharmacySaleUpdateManyMutationInput, PharmacySaleUncheckedUpdateManyInput>
    /**
     * Filter which PharmacySales to update
     */
    where?: PharmacySaleWhereInput
    /**
     * Limit how many PharmacySales to update.
     */
    limit?: number
  }

  /**
   * PharmacySale updateManyAndReturn
   */
  export type PharmacySaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * The data used to update PharmacySales.
     */
    data: XOR<PharmacySaleUpdateManyMutationInput, PharmacySaleUncheckedUpdateManyInput>
    /**
     * Filter which PharmacySales to update
     */
    where?: PharmacySaleWhereInput
    /**
     * Limit how many PharmacySales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PharmacySale upsert
   */
  export type PharmacySaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * The filter to search for the PharmacySale to update in case it exists.
     */
    where: PharmacySaleWhereUniqueInput
    /**
     * In case the PharmacySale found by the `where` argument doesn't exist, create a new PharmacySale with this data.
     */
    create: XOR<PharmacySaleCreateInput, PharmacySaleUncheckedCreateInput>
    /**
     * In case the PharmacySale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PharmacySaleUpdateInput, PharmacySaleUncheckedUpdateInput>
  }

  /**
   * PharmacySale delete
   */
  export type PharmacySaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
    /**
     * Filter which PharmacySale to delete.
     */
    where: PharmacySaleWhereUniqueInput
  }

  /**
   * PharmacySale deleteMany
   */
  export type PharmacySaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PharmacySales to delete
     */
    where?: PharmacySaleWhereInput
    /**
     * Limit how many PharmacySales to delete.
     */
    limit?: number
  }

  /**
   * PharmacySale.prescription
   */
  export type PharmacySale$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Prescription
     */
    omit?: PrescriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * PharmacySale.items
   */
  export type PharmacySale$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    cursor?: SaleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * PharmacySale without action
   */
  export type PharmacySaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PharmacySale
     */
    select?: PharmacySaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PharmacySale
     */
    omit?: PharmacySaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PharmacySaleInclude<ExtArgs> | null
  }


  /**
   * Model SaleItem
   */

  export type AggregateSaleItem = {
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  export type SaleItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemMinAggregateOutputType = {
    id: string | null
    pharmacySaleId: string | null
    medicineId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemMaxAggregateOutputType = {
    id: string | null
    pharmacySaleId: string | null
    medicineId: string | null
    quantity: number | null
    unitPrice: Decimal | null
    totalPrice: Decimal | null
  }

  export type SaleItemCountAggregateOutputType = {
    id: number
    pharmacySaleId: number
    medicineId: number
    quantity: number
    unitPrice: number
    totalPrice: number
    _all: number
  }


  export type SaleItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleItemMinAggregateInputType = {
    id?: true
    pharmacySaleId?: true
    medicineId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleItemMaxAggregateInputType = {
    id?: true
    pharmacySaleId?: true
    medicineId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
  }

  export type SaleItemCountAggregateInputType = {
    id?: true
    pharmacySaleId?: true
    medicineId?: true
    quantity?: true
    unitPrice?: true
    totalPrice?: true
    _all?: true
  }

  export type SaleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItem to aggregate.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaleItems
    **/
    _count?: true | SaleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleItemMaxAggregateInputType
  }

  export type GetSaleItemAggregateType<T extends SaleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSaleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaleItem[P]>
      : GetScalarType<T[P], AggregateSaleItem[P]>
  }




  export type SaleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleItemWhereInput
    orderBy?: SaleItemOrderByWithAggregationInput | SaleItemOrderByWithAggregationInput[]
    by: SaleItemScalarFieldEnum[] | SaleItemScalarFieldEnum
    having?: SaleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleItemCountAggregateInputType | true
    _avg?: SaleItemAvgAggregateInputType
    _sum?: SaleItemSumAggregateInputType
    _min?: SaleItemMinAggregateInputType
    _max?: SaleItemMaxAggregateInputType
  }

  export type SaleItemGroupByOutputType = {
    id: string
    pharmacySaleId: string
    medicineId: string
    quantity: number
    unitPrice: Decimal
    totalPrice: Decimal
    _count: SaleItemCountAggregateOutputType | null
    _avg: SaleItemAvgAggregateOutputType | null
    _sum: SaleItemSumAggregateOutputType | null
    _min: SaleItemMinAggregateOutputType | null
    _max: SaleItemMaxAggregateOutputType | null
  }

  type GetSaleItemGroupByPayload<T extends SaleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
            : GetScalarType<T[P], SaleItemGroupByOutputType[P]>
        }
      >
    >


  export type SaleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pharmacySaleId?: boolean
    medicineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pharmacySaleId?: boolean
    medicineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pharmacySaleId?: boolean
    medicineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["saleItem"]>

  export type SaleItemSelectScalar = {
    id?: boolean
    pharmacySaleId?: boolean
    medicineId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    totalPrice?: boolean
  }

  export type SaleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pharmacySaleId" | "medicineId" | "quantity" | "unitPrice" | "totalPrice", ExtArgs["result"]["saleItem"]>
  export type SaleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type SaleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pharmacySale?: boolean | PharmacySaleDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $SaleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SaleItem"
    objects: {
      pharmacySale: Prisma.$PharmacySalePayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pharmacySaleId: string
      medicineId: string
      quantity: number
      unitPrice: Prisma.Decimal
      totalPrice: Prisma.Decimal
    }, ExtArgs["result"]["saleItem"]>
    composites: {}
  }

  type SaleItemGetPayload<S extends boolean | null | undefined | SaleItemDefaultArgs> = $Result.GetResult<Prisma.$SaleItemPayload, S>

  type SaleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleItemCountAggregateInputType | true
    }

  export interface SaleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SaleItem'], meta: { name: 'SaleItem' } }
    /**
     * Find zero or one SaleItem that matches the filter.
     * @param {SaleItemFindUniqueArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleItemFindUniqueArgs>(args: SelectSubset<T, SaleItemFindUniqueArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SaleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleItemFindUniqueOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleItemFindFirstArgs>(args?: SelectSubset<T, SaleItemFindFirstArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SaleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindFirstOrThrowArgs} args - Arguments to find a SaleItem
     * @example
     * // Get one SaleItem
     * const saleItem = await prisma.saleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SaleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaleItems
     * const saleItems = await prisma.saleItem.findMany()
     * 
     * // Get first 10 SaleItems
     * const saleItems = await prisma.saleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleItemFindManyArgs>(args?: SelectSubset<T, SaleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SaleItem.
     * @param {SaleItemCreateArgs} args - Arguments to create a SaleItem.
     * @example
     * // Create one SaleItem
     * const SaleItem = await prisma.saleItem.create({
     *   data: {
     *     // ... data to create a SaleItem
     *   }
     * })
     * 
     */
    create<T extends SaleItemCreateArgs>(args: SelectSubset<T, SaleItemCreateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SaleItems.
     * @param {SaleItemCreateManyArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleItemCreateManyArgs>(args?: SelectSubset<T, SaleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SaleItems and returns the data saved in the database.
     * @param {SaleItemCreateManyAndReturnArgs} args - Arguments to create many SaleItems.
     * @example
     * // Create many SaleItems
     * const saleItem = await prisma.saleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SaleItem.
     * @param {SaleItemDeleteArgs} args - Arguments to delete one SaleItem.
     * @example
     * // Delete one SaleItem
     * const SaleItem = await prisma.saleItem.delete({
     *   where: {
     *     // ... filter to delete one SaleItem
     *   }
     * })
     * 
     */
    delete<T extends SaleItemDeleteArgs>(args: SelectSubset<T, SaleItemDeleteArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SaleItem.
     * @param {SaleItemUpdateArgs} args - Arguments to update one SaleItem.
     * @example
     * // Update one SaleItem
     * const saleItem = await prisma.saleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleItemUpdateArgs>(args: SelectSubset<T, SaleItemUpdateArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SaleItems.
     * @param {SaleItemDeleteManyArgs} args - Arguments to filter SaleItems to delete.
     * @example
     * // Delete a few SaleItems
     * const { count } = await prisma.saleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleItemDeleteManyArgs>(args?: SelectSubset<T, SaleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleItemUpdateManyArgs>(args: SelectSubset<T, SaleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaleItems and returns the data updated in the database.
     * @param {SaleItemUpdateManyAndReturnArgs} args - Arguments to update many SaleItems.
     * @example
     * // Update many SaleItems
     * const saleItem = await prisma.saleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SaleItems and only return the `id`
     * const saleItemWithIdOnly = await prisma.saleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SaleItem.
     * @param {SaleItemUpsertArgs} args - Arguments to update or create a SaleItem.
     * @example
     * // Update or create a SaleItem
     * const saleItem = await prisma.saleItem.upsert({
     *   create: {
     *     // ... data to create a SaleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaleItem we want to update
     *   }
     * })
     */
    upsert<T extends SaleItemUpsertArgs>(args: SelectSubset<T, SaleItemUpsertArgs<ExtArgs>>): Prisma__SaleItemClient<$Result.GetResult<Prisma.$SaleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SaleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemCountArgs} args - Arguments to filter SaleItems to count.
     * @example
     * // Count the number of SaleItems
     * const count = await prisma.saleItem.count({
     *   where: {
     *     // ... the filter for the SaleItems we want to count
     *   }
     * })
    **/
    count<T extends SaleItemCountArgs>(
      args?: Subset<T, SaleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleItemAggregateArgs>(args: Subset<T, SaleItemAggregateArgs>): Prisma.PrismaPromise<GetSaleItemAggregateType<T>>

    /**
     * Group by SaleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleItemGroupByArgs['orderBy'] }
        : { orderBy?: SaleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SaleItem model
   */
  readonly fields: SaleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pharmacySale<T extends PharmacySaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PharmacySaleDefaultArgs<ExtArgs>>): Prisma__PharmacySaleClient<$Result.GetResult<Prisma.$PharmacySalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SaleItem model
   */
  interface SaleItemFieldRefs {
    readonly id: FieldRef<"SaleItem", 'String'>
    readonly pharmacySaleId: FieldRef<"SaleItem", 'String'>
    readonly medicineId: FieldRef<"SaleItem", 'String'>
    readonly quantity: FieldRef<"SaleItem", 'Int'>
    readonly unitPrice: FieldRef<"SaleItem", 'Decimal'>
    readonly totalPrice: FieldRef<"SaleItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * SaleItem findUnique
   */
  export type SaleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findUniqueOrThrow
   */
  export type SaleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem findFirst
   */
  export type SaleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findFirstOrThrow
   */
  export type SaleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItem to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaleItems.
     */
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem findMany
   */
  export type SaleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter, which SaleItems to fetch.
     */
    where?: SaleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaleItems to fetch.
     */
    orderBy?: SaleItemOrderByWithRelationInput | SaleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaleItems.
     */
    cursor?: SaleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaleItems.
     */
    skip?: number
    distinct?: SaleItemScalarFieldEnum | SaleItemScalarFieldEnum[]
  }

  /**
   * SaleItem create
   */
  export type SaleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SaleItem.
     */
    data: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
  }

  /**
   * SaleItem createMany
   */
  export type SaleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SaleItem createManyAndReturn
   */
  export type SaleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to create many SaleItems.
     */
    data: SaleItemCreateManyInput | SaleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem update
   */
  export type SaleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SaleItem.
     */
    data: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
    /**
     * Choose, which SaleItem to update.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem updateMany
   */
  export type SaleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
  }

  /**
   * SaleItem updateManyAndReturn
   */
  export type SaleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * The data used to update SaleItems.
     */
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyInput>
    /**
     * Filter which SaleItems to update
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SaleItem upsert
   */
  export type SaleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SaleItem to update in case it exists.
     */
    where: SaleItemWhereUniqueInput
    /**
     * In case the SaleItem found by the `where` argument doesn't exist, create a new SaleItem with this data.
     */
    create: XOR<SaleItemCreateInput, SaleItemUncheckedCreateInput>
    /**
     * In case the SaleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleItemUpdateInput, SaleItemUncheckedUpdateInput>
  }

  /**
   * SaleItem delete
   */
  export type SaleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
    /**
     * Filter which SaleItem to delete.
     */
    where: SaleItemWhereUniqueInput
  }

  /**
   * SaleItem deleteMany
   */
  export type SaleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SaleItems to delete
     */
    where?: SaleItemWhereInput
    /**
     * Limit how many SaleItems to delete.
     */
    limit?: number
  }

  /**
   * SaleItem without action
   */
  export type SaleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleItem
     */
    select?: SaleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SaleItem
     */
    omit?: SaleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleItemInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    admissionId: string | null
    visitId: string | null
    invoiceDate: Date | null
    totalAmount: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    admissionId: string | null
    visitId: string | null
    invoiceDate: Date | null
    totalAmount: Decimal | null
    taxAmount: Decimal | null
    discountAmount: Decimal | null
    netAmount: Decimal | null
    status: $Enums.InvoiceStatus | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    patientId: number
    admissionId: number
    visitId: number
    invoiceDate: number
    totalAmount: number
    taxAmount: number
    discountAmount: number
    netAmount: number
    status: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
    taxAmount?: true
    discountAmount?: true
    netAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
    taxAmount?: true
    discountAmount?: true
    netAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    patientId?: true
    admissionId?: true
    visitId?: true
    invoiceDate?: true
    totalAmount?: true
    taxAmount?: true
    discountAmount?: true
    netAmount?: true
    status?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    patientId?: true
    admissionId?: true
    visitId?: true
    invoiceDate?: true
    totalAmount?: true
    taxAmount?: true
    discountAmount?: true
    netAmount?: true
    status?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    patientId?: true
    admissionId?: true
    visitId?: true
    invoiceDate?: true
    totalAmount?: true
    taxAmount?: true
    discountAmount?: true
    netAmount?: true
    status?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    patientId: string
    admissionId: string | null
    visitId: string | null
    invoiceDate: Date
    totalAmount: Decimal
    taxAmount: Decimal
    discountAmount: Decimal
    netAmount: Decimal
    status: $Enums.InvoiceStatus
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admissionId?: boolean
    visitId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admissionId?: boolean
    visitId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    admissionId?: boolean
    visitId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    status?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    patientId?: boolean
    admissionId?: boolean
    visitId?: boolean
    invoiceDate?: boolean
    totalAmount?: boolean
    taxAmount?: boolean
    discountAmount?: boolean
    netAmount?: boolean
    status?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patientId" | "admissionId" | "visitId" | "invoiceDate" | "totalAmount" | "taxAmount" | "discountAmount" | "netAmount" | "status", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
    items?: boolean | Invoice$itemsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    admission?: boolean | Invoice$admissionArgs<ExtArgs>
    visit?: boolean | Invoice$visitArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      admission: Prisma.$AdmissionPayload<ExtArgs> | null
      visit: Prisma.$OpdVisitPayload<ExtArgs> | null
      items: Prisma.$InvoiceItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      admissionId: string | null
      visitId: string | null
      invoiceDate: Date
      totalAmount: Prisma.Decimal
      taxAmount: Prisma.Decimal
      discountAmount: Prisma.Decimal
      netAmount: Prisma.Decimal
      status: $Enums.InvoiceStatus
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    admission<T extends Invoice$admissionArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$admissionArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visit<T extends Invoice$visitArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$visitArgs<ExtArgs>>): Prisma__OpdVisitClient<$Result.GetResult<Prisma.$OpdVisitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    items<T extends Invoice$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly patientId: FieldRef<"Invoice", 'String'>
    readonly admissionId: FieldRef<"Invoice", 'String'>
    readonly visitId: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Decimal'>
    readonly taxAmount: FieldRef<"Invoice", 'Decimal'>
    readonly discountAmount: FieldRef<"Invoice", 'Decimal'>
    readonly netAmount: FieldRef<"Invoice", 'Decimal'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.admission
   */
  export type Invoice$admissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admission
     */
    select?: AdmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admission
     */
    omit?: AdmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdmissionInclude<ExtArgs> | null
    where?: AdmissionWhereInput
  }

  /**
   * Invoice.visit
   */
  export type Invoice$visitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpdVisit
     */
    select?: OpdVisitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OpdVisit
     */
    omit?: OpdVisitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpdVisitInclude<ExtArgs> | null
    where?: OpdVisitWhereInput
  }

  /**
   * Invoice.items
   */
  export type Invoice$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    cursor?: InvoiceItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceItem
   */

  export type AggregateInvoiceItem = {
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  export type InvoiceItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    serviceId: string | null
    serviceOrderId: string | null
    itemName: string | null
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    serviceId: string | null
    serviceOrderId: string | null
    itemName: string | null
    quantity: number | null
    unitPrice: Decimal | null
    total: Decimal | null
  }

  export type InvoiceItemCountAggregateOutputType = {
    id: number
    invoiceId: number
    serviceId: number
    serviceOrderId: number
    itemName: number
    quantity: number
    unitPrice: number
    total: number
    _all: number
  }


  export type InvoiceItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMinAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    serviceOrderId?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    serviceOrderId?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    total?: true
  }

  export type InvoiceItemCountAggregateInputType = {
    id?: true
    invoiceId?: true
    serviceId?: true
    serviceOrderId?: true
    itemName?: true
    quantity?: true
    unitPrice?: true
    total?: true
    _all?: true
  }

  export type InvoiceItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItem to aggregate.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceItems
    **/
    _count?: true | InvoiceItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type GetInvoiceItemAggregateType<T extends InvoiceItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceItem[P]>
      : GetScalarType<T[P], AggregateInvoiceItem[P]>
  }




  export type InvoiceItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceItemWhereInput
    orderBy?: InvoiceItemOrderByWithAggregationInput | InvoiceItemOrderByWithAggregationInput[]
    by: InvoiceItemScalarFieldEnum[] | InvoiceItemScalarFieldEnum
    having?: InvoiceItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceItemCountAggregateInputType | true
    _avg?: InvoiceItemAvgAggregateInputType
    _sum?: InvoiceItemSumAggregateInputType
    _min?: InvoiceItemMinAggregateInputType
    _max?: InvoiceItemMaxAggregateInputType
  }

  export type InvoiceItemGroupByOutputType = {
    id: string
    invoiceId: string
    serviceId: string
    serviceOrderId: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal
    total: Decimal
    _count: InvoiceItemCountAggregateOutputType | null
    _avg: InvoiceItemAvgAggregateOutputType | null
    _sum: InvoiceItemSumAggregateOutputType | null
    _min: InvoiceItemMinAggregateOutputType | null
    _max: InvoiceItemMaxAggregateOutputType | null
  }

  type GetInvoiceItemGroupByPayload<T extends InvoiceItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceItemGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    serviceId?: boolean
    serviceOrderId?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    serviceId?: boolean
    serviceOrderId?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    serviceId?: boolean
    serviceOrderId?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceItem"]>

  export type InvoiceItemSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    serviceId?: boolean
    serviceOrderId?: boolean
    itemName?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
  }

  export type InvoiceItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "serviceId" | "serviceOrderId" | "itemName" | "quantity" | "unitPrice" | "total", ExtArgs["result"]["invoiceItem"]>
  export type InvoiceItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }
  export type InvoiceItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }
  export type InvoiceItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    serviceOrder?: boolean | InvoiceItem$serviceOrderArgs<ExtArgs>
  }

  export type $InvoiceItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceItem"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      serviceOrder: Prisma.$ServiceOrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      serviceId: string
      serviceOrderId: string | null
      itemName: string
      quantity: number
      unitPrice: Prisma.Decimal
      total: Prisma.Decimal
    }, ExtArgs["result"]["invoiceItem"]>
    composites: {}
  }

  type InvoiceItemGetPayload<S extends boolean | null | undefined | InvoiceItemDefaultArgs> = $Result.GetResult<Prisma.$InvoiceItemPayload, S>

  type InvoiceItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceItemCountAggregateInputType | true
    }

  export interface InvoiceItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceItem'], meta: { name: 'InvoiceItem' } }
    /**
     * Find zero or one InvoiceItem that matches the filter.
     * @param {InvoiceItemFindUniqueArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceItemFindUniqueArgs>(args: SelectSubset<T, InvoiceItemFindUniqueArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceItemFindUniqueOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceItemFindFirstArgs>(args?: SelectSubset<T, InvoiceItemFindFirstArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindFirstOrThrowArgs} args - Arguments to find a InvoiceItem
     * @example
     * // Get one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany()
     * 
     * // Get first 10 InvoiceItems
     * const invoiceItems = await prisma.invoiceItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceItemFindManyArgs>(args?: SelectSubset<T, InvoiceItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceItem.
     * @param {InvoiceItemCreateArgs} args - Arguments to create a InvoiceItem.
     * @example
     * // Create one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.create({
     *   data: {
     *     // ... data to create a InvoiceItem
     *   }
     * })
     * 
     */
    create<T extends InvoiceItemCreateArgs>(args: SelectSubset<T, InvoiceItemCreateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceItems.
     * @param {InvoiceItemCreateManyArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceItemCreateManyArgs>(args?: SelectSubset<T, InvoiceItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceItems and returns the data saved in the database.
     * @param {InvoiceItemCreateManyAndReturnArgs} args - Arguments to create many InvoiceItems.
     * @example
     * // Create many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceItem.
     * @param {InvoiceItemDeleteArgs} args - Arguments to delete one InvoiceItem.
     * @example
     * // Delete one InvoiceItem
     * const InvoiceItem = await prisma.invoiceItem.delete({
     *   where: {
     *     // ... filter to delete one InvoiceItem
     *   }
     * })
     * 
     */
    delete<T extends InvoiceItemDeleteArgs>(args: SelectSubset<T, InvoiceItemDeleteArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceItem.
     * @param {InvoiceItemUpdateArgs} args - Arguments to update one InvoiceItem.
     * @example
     * // Update one InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceItemUpdateArgs>(args: SelectSubset<T, InvoiceItemUpdateArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceItems.
     * @param {InvoiceItemDeleteManyArgs} args - Arguments to filter InvoiceItems to delete.
     * @example
     * // Delete a few InvoiceItems
     * const { count } = await prisma.invoiceItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceItemDeleteManyArgs>(args?: SelectSubset<T, InvoiceItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceItemUpdateManyArgs>(args: SelectSubset<T, InvoiceItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceItems and returns the data updated in the database.
     * @param {InvoiceItemUpdateManyAndReturnArgs} args - Arguments to update many InvoiceItems.
     * @example
     * // Update many InvoiceItems
     * const invoiceItem = await prisma.invoiceItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceItems and only return the `id`
     * const invoiceItemWithIdOnly = await prisma.invoiceItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceItem.
     * @param {InvoiceItemUpsertArgs} args - Arguments to update or create a InvoiceItem.
     * @example
     * // Update or create a InvoiceItem
     * const invoiceItem = await prisma.invoiceItem.upsert({
     *   create: {
     *     // ... data to create a InvoiceItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceItem we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceItemUpsertArgs>(args: SelectSubset<T, InvoiceItemUpsertArgs<ExtArgs>>): Prisma__InvoiceItemClient<$Result.GetResult<Prisma.$InvoiceItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemCountArgs} args - Arguments to filter InvoiceItems to count.
     * @example
     * // Count the number of InvoiceItems
     * const count = await prisma.invoiceItem.count({
     *   where: {
     *     // ... the filter for the InvoiceItems we want to count
     *   }
     * })
    **/
    count<T extends InvoiceItemCountArgs>(
      args?: Subset<T, InvoiceItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceItemAggregateArgs>(args: Subset<T, InvoiceItemAggregateArgs>): Prisma.PrismaPromise<GetInvoiceItemAggregateType<T>>

    /**
     * Group by InvoiceItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceItemGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceItem model
   */
  readonly fields: InvoiceItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceOrder<T extends InvoiceItem$serviceOrderArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceItem$serviceOrderArgs<ExtArgs>>): Prisma__ServiceOrderClient<$Result.GetResult<Prisma.$ServiceOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceItem model
   */
  interface InvoiceItemFieldRefs {
    readonly id: FieldRef<"InvoiceItem", 'String'>
    readonly invoiceId: FieldRef<"InvoiceItem", 'String'>
    readonly serviceId: FieldRef<"InvoiceItem", 'String'>
    readonly serviceOrderId: FieldRef<"InvoiceItem", 'String'>
    readonly itemName: FieldRef<"InvoiceItem", 'String'>
    readonly quantity: FieldRef<"InvoiceItem", 'Int'>
    readonly unitPrice: FieldRef<"InvoiceItem", 'Decimal'>
    readonly total: FieldRef<"InvoiceItem", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceItem findUnique
   */
  export type InvoiceItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findUniqueOrThrow
   */
  export type InvoiceItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem findFirst
   */
  export type InvoiceItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findFirstOrThrow
   */
  export type InvoiceItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItem to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceItems.
     */
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem findMany
   */
  export type InvoiceItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceItems to fetch.
     */
    where?: InvoiceItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceItems to fetch.
     */
    orderBy?: InvoiceItemOrderByWithRelationInput | InvoiceItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceItems.
     */
    cursor?: InvoiceItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceItems.
     */
    skip?: number
    distinct?: InvoiceItemScalarFieldEnum | InvoiceItemScalarFieldEnum[]
  }

  /**
   * InvoiceItem create
   */
  export type InvoiceItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceItem.
     */
    data: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
  }

  /**
   * InvoiceItem createMany
   */
  export type InvoiceItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceItem createManyAndReturn
   */
  export type InvoiceItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceItems.
     */
    data: InvoiceItemCreateManyInput | InvoiceItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem update
   */
  export type InvoiceItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceItem.
     */
    data: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
    /**
     * Choose, which InvoiceItem to update.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem updateMany
   */
  export type InvoiceItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
  }

  /**
   * InvoiceItem updateManyAndReturn
   */
  export type InvoiceItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceItems.
     */
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceItems to update
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceItem upsert
   */
  export type InvoiceItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceItem to update in case it exists.
     */
    where: InvoiceItemWhereUniqueInput
    /**
     * In case the InvoiceItem found by the `where` argument doesn't exist, create a new InvoiceItem with this data.
     */
    create: XOR<InvoiceItemCreateInput, InvoiceItemUncheckedCreateInput>
    /**
     * In case the InvoiceItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceItemUpdateInput, InvoiceItemUncheckedUpdateInput>
  }

  /**
   * InvoiceItem delete
   */
  export type InvoiceItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
    /**
     * Filter which InvoiceItem to delete.
     */
    where: InvoiceItemWhereUniqueInput
  }

  /**
   * InvoiceItem deleteMany
   */
  export type InvoiceItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceItems to delete
     */
    where?: InvoiceItemWhereInput
    /**
     * Limit how many InvoiceItems to delete.
     */
    limit?: number
  }

  /**
   * InvoiceItem.serviceOrder
   */
  export type InvoiceItem$serviceOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOrder
     */
    select?: ServiceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOrder
     */
    omit?: ServiceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOrderInclude<ExtArgs> | null
    where?: ServiceOrderWhereInput
  }

  /**
   * InvoiceItem without action
   */
  export type InvoiceItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceItem
     */
    select?: InvoiceItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceItem
     */
    omit?: InvoiceItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceItemInclude<ExtArgs> | null
  }


  /**
   * Model InsuranceClaim
   */

  export type AggregateInsuranceClaim = {
    _count: InsuranceClaimCountAggregateOutputType | null
    _avg: InsuranceClaimAvgAggregateOutputType | null
    _sum: InsuranceClaimSumAggregateOutputType | null
    _min: InsuranceClaimMinAggregateOutputType | null
    _max: InsuranceClaimMaxAggregateOutputType | null
  }

  export type InsuranceClaimAvgAggregateOutputType = {
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
  }

  export type InsuranceClaimSumAggregateOutputType = {
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
  }

  export type InsuranceClaimMinAggregateOutputType = {
    id: string | null
    admissionId: string | null
    providerName: string | null
    policyNumber: string | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    status: $Enums.ClaimStatus | null
    submissionDate: Date | null
  }

  export type InsuranceClaimMaxAggregateOutputType = {
    id: string | null
    admissionId: string | null
    providerName: string | null
    policyNumber: string | null
    claimAmount: Decimal | null
    approvedAmount: Decimal | null
    status: $Enums.ClaimStatus | null
    submissionDate: Date | null
  }

  export type InsuranceClaimCountAggregateOutputType = {
    id: number
    admissionId: number
    providerName: number
    policyNumber: number
    claimAmount: number
    approvedAmount: number
    status: number
    submissionDate: number
    _all: number
  }


  export type InsuranceClaimAvgAggregateInputType = {
    claimAmount?: true
    approvedAmount?: true
  }

  export type InsuranceClaimSumAggregateInputType = {
    claimAmount?: true
    approvedAmount?: true
  }

  export type InsuranceClaimMinAggregateInputType = {
    id?: true
    admissionId?: true
    providerName?: true
    policyNumber?: true
    claimAmount?: true
    approvedAmount?: true
    status?: true
    submissionDate?: true
  }

  export type InsuranceClaimMaxAggregateInputType = {
    id?: true
    admissionId?: true
    providerName?: true
    policyNumber?: true
    claimAmount?: true
    approvedAmount?: true
    status?: true
    submissionDate?: true
  }

  export type InsuranceClaimCountAggregateInputType = {
    id?: true
    admissionId?: true
    providerName?: true
    policyNumber?: true
    claimAmount?: true
    approvedAmount?: true
    status?: true
    submissionDate?: true
    _all?: true
  }

  export type InsuranceClaimAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceClaim to aggregate.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsuranceClaims
    **/
    _count?: true | InsuranceClaimCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InsuranceClaimAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InsuranceClaimSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsuranceClaimMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsuranceClaimMaxAggregateInputType
  }

  export type GetInsuranceClaimAggregateType<T extends InsuranceClaimAggregateArgs> = {
        [P in keyof T & keyof AggregateInsuranceClaim]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsuranceClaim[P]>
      : GetScalarType<T[P], AggregateInsuranceClaim[P]>
  }




  export type InsuranceClaimGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsuranceClaimWhereInput
    orderBy?: InsuranceClaimOrderByWithAggregationInput | InsuranceClaimOrderByWithAggregationInput[]
    by: InsuranceClaimScalarFieldEnum[] | InsuranceClaimScalarFieldEnum
    having?: InsuranceClaimScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsuranceClaimCountAggregateInputType | true
    _avg?: InsuranceClaimAvgAggregateInputType
    _sum?: InsuranceClaimSumAggregateInputType
    _min?: InsuranceClaimMinAggregateInputType
    _max?: InsuranceClaimMaxAggregateInputType
  }

  export type InsuranceClaimGroupByOutputType = {
    id: string
    admissionId: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal
    approvedAmount: Decimal | null
    status: $Enums.ClaimStatus
    submissionDate: Date
    _count: InsuranceClaimCountAggregateOutputType | null
    _avg: InsuranceClaimAvgAggregateOutputType | null
    _sum: InsuranceClaimSumAggregateOutputType | null
    _min: InsuranceClaimMinAggregateOutputType | null
    _max: InsuranceClaimMaxAggregateOutputType | null
  }

  type GetInsuranceClaimGroupByPayload<T extends InsuranceClaimGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsuranceClaimGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsuranceClaimGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsuranceClaimGroupByOutputType[P]>
            : GetScalarType<T[P], InsuranceClaimGroupByOutputType[P]>
        }
      >
    >


  export type InsuranceClaimSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    providerName?: boolean
    policyNumber?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    status?: boolean
    submissionDate?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    providerName?: boolean
    policyNumber?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    status?: boolean
    submissionDate?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    admissionId?: boolean
    providerName?: boolean
    policyNumber?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    status?: boolean
    submissionDate?: boolean
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insuranceClaim"]>

  export type InsuranceClaimSelectScalar = {
    id?: boolean
    admissionId?: boolean
    providerName?: boolean
    policyNumber?: boolean
    claimAmount?: boolean
    approvedAmount?: boolean
    status?: boolean
    submissionDate?: boolean
  }

  export type InsuranceClaimOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "admissionId" | "providerName" | "policyNumber" | "claimAmount" | "approvedAmount" | "status" | "submissionDate", ExtArgs["result"]["insuranceClaim"]>
  export type InsuranceClaimInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }
  export type InsuranceClaimIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }
  export type InsuranceClaimIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admission?: boolean | AdmissionDefaultArgs<ExtArgs>
  }

  export type $InsuranceClaimPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsuranceClaim"
    objects: {
      admission: Prisma.$AdmissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      admissionId: string
      providerName: string
      policyNumber: string
      claimAmount: Prisma.Decimal
      approvedAmount: Prisma.Decimal | null
      status: $Enums.ClaimStatus
      submissionDate: Date
    }, ExtArgs["result"]["insuranceClaim"]>
    composites: {}
  }

  type InsuranceClaimGetPayload<S extends boolean | null | undefined | InsuranceClaimDefaultArgs> = $Result.GetResult<Prisma.$InsuranceClaimPayload, S>

  type InsuranceClaimCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InsuranceClaimFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InsuranceClaimCountAggregateInputType | true
    }

  export interface InsuranceClaimDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsuranceClaim'], meta: { name: 'InsuranceClaim' } }
    /**
     * Find zero or one InsuranceClaim that matches the filter.
     * @param {InsuranceClaimFindUniqueArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsuranceClaimFindUniqueArgs>(args: SelectSubset<T, InsuranceClaimFindUniqueArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InsuranceClaim that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InsuranceClaimFindUniqueOrThrowArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsuranceClaimFindUniqueOrThrowArgs>(args: SelectSubset<T, InsuranceClaimFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceClaim that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindFirstArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsuranceClaimFindFirstArgs>(args?: SelectSubset<T, InsuranceClaimFindFirstArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InsuranceClaim that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindFirstOrThrowArgs} args - Arguments to find a InsuranceClaim
     * @example
     * // Get one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsuranceClaimFindFirstOrThrowArgs>(args?: SelectSubset<T, InsuranceClaimFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InsuranceClaims that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsuranceClaims
     * const insuranceClaims = await prisma.insuranceClaim.findMany()
     * 
     * // Get first 10 InsuranceClaims
     * const insuranceClaims = await prisma.insuranceClaim.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsuranceClaimFindManyArgs>(args?: SelectSubset<T, InsuranceClaimFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InsuranceClaim.
     * @param {InsuranceClaimCreateArgs} args - Arguments to create a InsuranceClaim.
     * @example
     * // Create one InsuranceClaim
     * const InsuranceClaim = await prisma.insuranceClaim.create({
     *   data: {
     *     // ... data to create a InsuranceClaim
     *   }
     * })
     * 
     */
    create<T extends InsuranceClaimCreateArgs>(args: SelectSubset<T, InsuranceClaimCreateArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InsuranceClaims.
     * @param {InsuranceClaimCreateManyArgs} args - Arguments to create many InsuranceClaims.
     * @example
     * // Create many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsuranceClaimCreateManyArgs>(args?: SelectSubset<T, InsuranceClaimCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsuranceClaims and returns the data saved in the database.
     * @param {InsuranceClaimCreateManyAndReturnArgs} args - Arguments to create many InsuranceClaims.
     * @example
     * // Create many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsuranceClaims and only return the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsuranceClaimCreateManyAndReturnArgs>(args?: SelectSubset<T, InsuranceClaimCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InsuranceClaim.
     * @param {InsuranceClaimDeleteArgs} args - Arguments to delete one InsuranceClaim.
     * @example
     * // Delete one InsuranceClaim
     * const InsuranceClaim = await prisma.insuranceClaim.delete({
     *   where: {
     *     // ... filter to delete one InsuranceClaim
     *   }
     * })
     * 
     */
    delete<T extends InsuranceClaimDeleteArgs>(args: SelectSubset<T, InsuranceClaimDeleteArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InsuranceClaim.
     * @param {InsuranceClaimUpdateArgs} args - Arguments to update one InsuranceClaim.
     * @example
     * // Update one InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsuranceClaimUpdateArgs>(args: SelectSubset<T, InsuranceClaimUpdateArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InsuranceClaims.
     * @param {InsuranceClaimDeleteManyArgs} args - Arguments to filter InsuranceClaims to delete.
     * @example
     * // Delete a few InsuranceClaims
     * const { count } = await prisma.insuranceClaim.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsuranceClaimDeleteManyArgs>(args?: SelectSubset<T, InsuranceClaimDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsuranceClaimUpdateManyArgs>(args: SelectSubset<T, InsuranceClaimUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsuranceClaims and returns the data updated in the database.
     * @param {InsuranceClaimUpdateManyAndReturnArgs} args - Arguments to update many InsuranceClaims.
     * @example
     * // Update many InsuranceClaims
     * const insuranceClaim = await prisma.insuranceClaim.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InsuranceClaims and only return the `id`
     * const insuranceClaimWithIdOnly = await prisma.insuranceClaim.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InsuranceClaimUpdateManyAndReturnArgs>(args: SelectSubset<T, InsuranceClaimUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InsuranceClaim.
     * @param {InsuranceClaimUpsertArgs} args - Arguments to update or create a InsuranceClaim.
     * @example
     * // Update or create a InsuranceClaim
     * const insuranceClaim = await prisma.insuranceClaim.upsert({
     *   create: {
     *     // ... data to create a InsuranceClaim
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsuranceClaim we want to update
     *   }
     * })
     */
    upsert<T extends InsuranceClaimUpsertArgs>(args: SelectSubset<T, InsuranceClaimUpsertArgs<ExtArgs>>): Prisma__InsuranceClaimClient<$Result.GetResult<Prisma.$InsuranceClaimPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InsuranceClaims.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimCountArgs} args - Arguments to filter InsuranceClaims to count.
     * @example
     * // Count the number of InsuranceClaims
     * const count = await prisma.insuranceClaim.count({
     *   where: {
     *     // ... the filter for the InsuranceClaims we want to count
     *   }
     * })
    **/
    count<T extends InsuranceClaimCountArgs>(
      args?: Subset<T, InsuranceClaimCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsuranceClaimCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsuranceClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsuranceClaimAggregateArgs>(args: Subset<T, InsuranceClaimAggregateArgs>): Prisma.PrismaPromise<GetInsuranceClaimAggregateType<T>>

    /**
     * Group by InsuranceClaim.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsuranceClaimGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsuranceClaimGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsuranceClaimGroupByArgs['orderBy'] }
        : { orderBy?: InsuranceClaimGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsuranceClaimGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsuranceClaimGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsuranceClaim model
   */
  readonly fields: InsuranceClaimFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsuranceClaim.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsuranceClaimClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admission<T extends AdmissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdmissionDefaultArgs<ExtArgs>>): Prisma__AdmissionClient<$Result.GetResult<Prisma.$AdmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsuranceClaim model
   */
  interface InsuranceClaimFieldRefs {
    readonly id: FieldRef<"InsuranceClaim", 'String'>
    readonly admissionId: FieldRef<"InsuranceClaim", 'String'>
    readonly providerName: FieldRef<"InsuranceClaim", 'String'>
    readonly policyNumber: FieldRef<"InsuranceClaim", 'String'>
    readonly claimAmount: FieldRef<"InsuranceClaim", 'Decimal'>
    readonly approvedAmount: FieldRef<"InsuranceClaim", 'Decimal'>
    readonly status: FieldRef<"InsuranceClaim", 'ClaimStatus'>
    readonly submissionDate: FieldRef<"InsuranceClaim", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsuranceClaim findUnique
   */
  export type InsuranceClaimFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim findUniqueOrThrow
   */
  export type InsuranceClaimFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim findFirst
   */
  export type InsuranceClaimFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceClaims.
     */
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim findFirstOrThrow
   */
  export type InsuranceClaimFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaim to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsuranceClaims.
     */
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim findMany
   */
  export type InsuranceClaimFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter, which InsuranceClaims to fetch.
     */
    where?: InsuranceClaimWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsuranceClaims to fetch.
     */
    orderBy?: InsuranceClaimOrderByWithRelationInput | InsuranceClaimOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsuranceClaims.
     */
    cursor?: InsuranceClaimWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsuranceClaims from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsuranceClaims.
     */
    skip?: number
    distinct?: InsuranceClaimScalarFieldEnum | InsuranceClaimScalarFieldEnum[]
  }

  /**
   * InsuranceClaim create
   */
  export type InsuranceClaimCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The data needed to create a InsuranceClaim.
     */
    data: XOR<InsuranceClaimCreateInput, InsuranceClaimUncheckedCreateInput>
  }

  /**
   * InsuranceClaim createMany
   */
  export type InsuranceClaimCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsuranceClaims.
     */
    data: InsuranceClaimCreateManyInput | InsuranceClaimCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsuranceClaim createManyAndReturn
   */
  export type InsuranceClaimCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * The data used to create many InsuranceClaims.
     */
    data: InsuranceClaimCreateManyInput | InsuranceClaimCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsuranceClaim update
   */
  export type InsuranceClaimUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The data needed to update a InsuranceClaim.
     */
    data: XOR<InsuranceClaimUpdateInput, InsuranceClaimUncheckedUpdateInput>
    /**
     * Choose, which InsuranceClaim to update.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim updateMany
   */
  export type InsuranceClaimUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsuranceClaims.
     */
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceClaims to update
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to update.
     */
    limit?: number
  }

  /**
   * InsuranceClaim updateManyAndReturn
   */
  export type InsuranceClaimUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * The data used to update InsuranceClaims.
     */
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyInput>
    /**
     * Filter which InsuranceClaims to update
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsuranceClaim upsert
   */
  export type InsuranceClaimUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * The filter to search for the InsuranceClaim to update in case it exists.
     */
    where: InsuranceClaimWhereUniqueInput
    /**
     * In case the InsuranceClaim found by the `where` argument doesn't exist, create a new InsuranceClaim with this data.
     */
    create: XOR<InsuranceClaimCreateInput, InsuranceClaimUncheckedCreateInput>
    /**
     * In case the InsuranceClaim was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsuranceClaimUpdateInput, InsuranceClaimUncheckedUpdateInput>
  }

  /**
   * InsuranceClaim delete
   */
  export type InsuranceClaimDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
    /**
     * Filter which InsuranceClaim to delete.
     */
    where: InsuranceClaimWhereUniqueInput
  }

  /**
   * InsuranceClaim deleteMany
   */
  export type InsuranceClaimDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsuranceClaims to delete
     */
    where?: InsuranceClaimWhereInput
    /**
     * Limit how many InsuranceClaims to delete.
     */
    limit?: number
  }

  /**
   * InsuranceClaim without action
   */
  export type InsuranceClaimDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsuranceClaim
     */
    select?: InsuranceClaimSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InsuranceClaim
     */
    omit?: InsuranceClaimOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsuranceClaimInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const StaffProfileScalarFieldEnum: {
    id: 'id',
    departmentId: 'departmentId',
    fullName: 'fullName',
    qualification: 'qualification',
    registrationNumber: 'registrationNumber',
    contactNumber: 'contactNumber',
    shiftTiming: 'shiftTiming'
  };

  export type StaffProfileScalarFieldEnum = (typeof StaffProfileScalarFieldEnum)[keyof typeof StaffProfileScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    headDoctorId: 'headDoctorId',
    type: 'type'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    departmentId: 'departmentId',
    basePrice: 'basePrice',
    code: 'code',
    isActive: 'isActive'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const WardScalarFieldEnum: {
    id: 'id',
    name: 'name',
    departmentId: 'departmentId',
    floorNumber: 'floorNumber',
    type: 'type',
    basePricePerDay: 'basePricePerDay'
  };

  export type WardScalarFieldEnum = (typeof WardScalarFieldEnum)[keyof typeof WardScalarFieldEnum]


  export const BedScalarFieldEnum: {
    id: 'id',
    wardId: 'wardId',
    bedNumber: 'bedNumber',
    status: 'status'
  };

  export type BedScalarFieldEnum = (typeof BedScalarFieldEnum)[keyof typeof BedScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    uhid: 'uhid',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    dob: 'dob',
    gender: 'gender',
    maritalStatus: 'maritalStatus',
    nationality: 'nationality',
    phone: 'phone',
    email: 'email',
    preferredLanguage: 'preferredLanguage',
    permanentAddress: 'permanentAddress',
    currentAddress: 'currentAddress',
    city: 'city',
    state: 'state',
    pincode: 'pincode',
    idProofType: 'idProofType',
    idProofNumber: 'idProofNumber',
    abhaId: 'abhaId',
    emergencyContactName: 'emergencyContactName',
    emergencyContactPhone: 'emergencyContactPhone',
    emergencyContactRelation: 'emergencyContactRelation',
    defaultPayerType: 'defaultPayerType',
    insuranceProvider: 'insuranceProvider',
    policyNumber: 'policyNumber',
    isDeceased: 'isDeceased',
    registrationDate: 'registrationDate'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const MedicalHistoryScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    category: 'category',
    name: 'name',
    severity: 'severity',
    status: 'status',
    diagnosedDate: 'diagnosedDate',
    notes: 'notes'
  };

  export type MedicalHistoryScalarFieldEnum = (typeof MedicalHistoryScalarFieldEnum)[keyof typeof MedicalHistoryScalarFieldEnum]


  export const PatientDocumentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    visitId: 'visitId',
    admissionId: 'admissionId',
    category: 'category',
    fileUrl: 'fileUrl',
    uploadedBy: 'uploadedBy',
    uploadedAt: 'uploadedAt'
  };

  export type PatientDocumentScalarFieldEnum = (typeof PatientDocumentScalarFieldEnum)[keyof typeof PatientDocumentScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    departmentId: 'departmentId',
    appointmentDate: 'appointmentDate',
    tokenNumber: 'tokenNumber',
    status: 'status',
    type: 'type'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const OpdVisitScalarFieldEnum: {
    id: 'id',
    appointmentId: 'appointmentId',
    patientId: 'patientId',
    doctorId: 'doctorId',
    visitDate: 'visitDate',
    visitType: 'visitType',
    triageColor: 'triageColor',
    status: 'status',
    isMedicoLegal: 'isMedicoLegal'
  };

  export type OpdVisitScalarFieldEnum = (typeof OpdVisitScalarFieldEnum)[keyof typeof OpdVisitScalarFieldEnum]


  export const AdmissionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    admittingDoctorId: 'admittingDoctorId',
    departmentId: 'departmentId',
    visitId: 'visitId',
    currentBedId: 'currentBedId',
    admissionDate: 'admissionDate',
    dischargeDate: 'dischargeDate',
    reasonForAdmission: 'reasonForAdmission',
    admissionType: 'admissionType',
    status: 'status',
    dischargeType: 'dischargeType',
    mlc: 'mlc'
  };

  export type AdmissionScalarFieldEnum = (typeof AdmissionScalarFieldEnum)[keyof typeof AdmissionScalarFieldEnum]


  export const BedTransferScalarFieldEnum: {
    id: 'id',
    admissionId: 'admissionId',
    bedId: 'bedId',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason'
  };

  export type BedTransferScalarFieldEnum = (typeof BedTransferScalarFieldEnum)[keyof typeof BedTransferScalarFieldEnum]


  export const SurgeryScalarFieldEnum: {
    id: 'id',
    admissionId: 'admissionId',
    procedureName: 'procedureName',
    surgeonId: 'surgeonId',
    otRoomNumber: 'otRoomNumber',
    surgeryDate: 'surgeryDate',
    status: 'status',
    notes: 'notes'
  };

  export type SurgeryScalarFieldEnum = (typeof SurgeryScalarFieldEnum)[keyof typeof SurgeryScalarFieldEnum]


  export const SurgerySStaffScalarFieldEnum: {
    surgeryId: 'surgeryId',
    staffId: 'staffId',
    role: 'role'
  };

  export type SurgerySStaffScalarFieldEnum = (typeof SurgerySStaffScalarFieldEnum)[keyof typeof SurgerySStaffScalarFieldEnum]


  export const SurgicalChecklistScalarFieldEnum: {
    id: 'id',
    surgeryId: 'surgeryId',
    stage: 'stage',
    itemName: 'itemName',
    isChecked: 'isChecked',
    checkedBy: 'checkedBy',
    timestamp: 'timestamp'
  };

  export type SurgicalChecklistScalarFieldEnum = (typeof SurgicalChecklistScalarFieldEnum)[keyof typeof SurgicalChecklistScalarFieldEnum]


  export const ClinicalNoteScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    visitId: 'visitId',
    admissionId: 'admissionId',
    doctorId: 'doctorId',
    noteType: 'noteType',
    content: 'content',
    createdAt: 'createdAt',
    isFinalized: 'isFinalized'
  };

  export type ClinicalNoteScalarFieldEnum = (typeof ClinicalNoteScalarFieldEnum)[keyof typeof ClinicalNoteScalarFieldEnum]


  export const ServiceOrderScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    visitId: 'visitId',
    admissionId: 'admissionId',
    serviceId: 'serviceId',
    orderType: 'orderType',
    priority: 'priority',
    clinicalIndication: 'clinicalIndication',
    isPaid: 'isPaid',
    status: 'status',
    orderDate: 'orderDate'
  };

  export type ServiceOrderScalarFieldEnum = (typeof ServiceOrderScalarFieldEnum)[keyof typeof ServiceOrderScalarFieldEnum]


  export const LabResultScalarFieldEnum: {
    id: 'id',
    serviceOrderId: 'serviceOrderId',
    testName: 'testName',
    resultValue: 'resultValue',
    referenceRange: 'referenceRange',
    unit: 'unit',
    technicianId: 'technicianId',
    verifiedByDoctorId: 'verifiedByDoctorId',
    resultDate: 'resultDate'
  };

  export type LabResultScalarFieldEnum = (typeof LabResultScalarFieldEnum)[keyof typeof LabResultScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    doctorId: 'doctorId',
    visitId: 'visitId',
    admissionId: 'admissionId',
    isPaid: 'isPaid',
    date: 'date'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const PrescriptionItemScalarFieldEnum: {
    id: 'id',
    prescriptionId: 'prescriptionId',
    medicineId: 'medicineId',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    instruction: 'instruction'
  };

  export type PrescriptionItemScalarFieldEnum = (typeof PrescriptionItemScalarFieldEnum)[keyof typeof PrescriptionItemScalarFieldEnum]


  export const MedicineScalarFieldEnum: {
    id: 'id',
    name: 'name',
    genericName: 'genericName',
    batchNumber: 'batchNumber',
    expiryDate: 'expiryDate',
    stockQuantity: 'stockQuantity',
    reorderLevel: 'reorderLevel',
    unitPrice: 'unitPrice'
  };

  export type MedicineScalarFieldEnum = (typeof MedicineScalarFieldEnum)[keyof typeof MedicineScalarFieldEnum]


  export const PharmacySaleScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    prescriptionId: 'prescriptionId',
    saleDate: 'saleDate',
    totalAmount: 'totalAmount'
  };

  export type PharmacySaleScalarFieldEnum = (typeof PharmacySaleScalarFieldEnum)[keyof typeof PharmacySaleScalarFieldEnum]


  export const SaleItemScalarFieldEnum: {
    id: 'id',
    pharmacySaleId: 'pharmacySaleId',
    medicineId: 'medicineId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    totalPrice: 'totalPrice'
  };

  export type SaleItemScalarFieldEnum = (typeof SaleItemScalarFieldEnum)[keyof typeof SaleItemScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    admissionId: 'admissionId',
    visitId: 'visitId',
    invoiceDate: 'invoiceDate',
    totalAmount: 'totalAmount',
    taxAmount: 'taxAmount',
    discountAmount: 'discountAmount',
    netAmount: 'netAmount',
    status: 'status'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceItemScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    serviceId: 'serviceId',
    serviceOrderId: 'serviceOrderId',
    itemName: 'itemName',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total'
  };

  export type InvoiceItemScalarFieldEnum = (typeof InvoiceItemScalarFieldEnum)[keyof typeof InvoiceItemScalarFieldEnum]


  export const InsuranceClaimScalarFieldEnum: {
    id: 'id',
    admissionId: 'admissionId',
    providerName: 'providerName',
    policyNumber: 'policyNumber',
    claimAmount: 'claimAmount',
    approvedAmount: 'approvedAmount',
    status: 'status',
    submissionDate: 'submissionDate'
  };

  export type InsuranceClaimScalarFieldEnum = (typeof InsuranceClaimScalarFieldEnum)[keyof typeof InsuranceClaimScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'DepartmentType'
   */
  export type EnumDepartmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepartmentType'>
    


  /**
   * Reference to a field of type 'DepartmentType[]'
   */
  export type ListEnumDepartmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DepartmentType[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BedStatus'
   */
  export type EnumBedStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedStatus'>
    


  /**
   * Reference to a field of type 'BedStatus[]'
   */
  export type ListEnumBedStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BedStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'AppointmentType'
   */
  export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType'>
    


  /**
   * Reference to a field of type 'AppointmentType[]'
   */
  export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType[]'>
    


  /**
   * Reference to a field of type 'VisitType'
   */
  export type EnumVisitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitType'>
    


  /**
   * Reference to a field of type 'VisitType[]'
   */
  export type ListEnumVisitTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitType[]'>
    


  /**
   * Reference to a field of type 'TriageColor'
   */
  export type EnumTriageColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriageColor'>
    


  /**
   * Reference to a field of type 'TriageColor[]'
   */
  export type ListEnumTriageColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TriageColor[]'>
    


  /**
   * Reference to a field of type 'VisitStatus'
   */
  export type EnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus'>
    


  /**
   * Reference to a field of type 'VisitStatus[]'
   */
  export type ListEnumVisitStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VisitStatus[]'>
    


  /**
   * Reference to a field of type 'AdmissionType'
   */
  export type EnumAdmissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionType'>
    


  /**
   * Reference to a field of type 'AdmissionType[]'
   */
  export type ListEnumAdmissionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionType[]'>
    


  /**
   * Reference to a field of type 'AdmissionStatus'
   */
  export type EnumAdmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionStatus'>
    


  /**
   * Reference to a field of type 'AdmissionStatus[]'
   */
  export type ListEnumAdmissionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdmissionStatus[]'>
    


  /**
   * Reference to a field of type 'DischargeType'
   */
  export type EnumDischargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DischargeType'>
    


  /**
   * Reference to a field of type 'DischargeType[]'
   */
  export type ListEnumDischargeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DischargeType[]'>
    


  /**
   * Reference to a field of type 'SurgeryStatus'
   */
  export type EnumSurgeryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurgeryStatus'>
    


  /**
   * Reference to a field of type 'SurgeryStatus[]'
   */
  export type ListEnumSurgeryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurgeryStatus[]'>
    


  /**
   * Reference to a field of type 'ChecklistStage'
   */
  export type EnumChecklistStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistStage'>
    


  /**
   * Reference to a field of type 'ChecklistStage[]'
   */
  export type ListEnumChecklistStageFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistStage[]'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'NoteType[]'
   */
  export type ListEnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'OrderType'
   */
  export type EnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType'>
    


  /**
   * Reference to a field of type 'OrderType[]'
   */
  export type ListEnumOrderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderType[]'>
    


  /**
   * Reference to a field of type 'OrderPriority'
   */
  export type EnumOrderPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPriority'>
    


  /**
   * Reference to a field of type 'OrderPriority[]'
   */
  export type ListEnumOrderPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderPriority[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'ClaimStatus'
   */
  export type EnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus'>
    


  /**
   * Reference to a field of type 'ClaimStatus[]'
   */
  export type ListEnumClaimStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClaimStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    labResults?: LabResultListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    staffProfile?: StaffProfileOrderByWithRelationInput
    labResults?: LabResultOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    labResults?: LabResultListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type StaffProfileWhereInput = {
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    id?: StringFilter<"StaffProfile"> | string
    departmentId?: StringNullableFilter<"StaffProfile"> | string | null
    fullName?: StringFilter<"StaffProfile"> | string
    qualification?: StringNullableFilter<"StaffProfile"> | string | null
    registrationNumber?: StringNullableFilter<"StaffProfile"> | string | null
    contactNumber?: StringNullableFilter<"StaffProfile"> | string | null
    shiftTiming?: StringNullableFilter<"StaffProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    headOfDepartments?: DepartmentListRelationFilter
    appointments?: AppointmentListRelationFilter
    opdVisits?: OpdVisitListRelationFilter
    admissions?: AdmissionListRelationFilter
    surgeries?: SurgeryListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    verifiedResults?: LabResultListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    surgerySStaffs?: SurgerySStaffListRelationFilter
  }

  export type StaffProfileOrderByWithRelationInput = {
    id?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    qualification?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    shiftTiming?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    headOfDepartments?: DepartmentOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    opdVisits?: OpdVisitOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
    surgeries?: SurgeryOrderByRelationAggregateInput
    clinicalNotes?: ClinicalNoteOrderByRelationAggregateInput
    serviceOrders?: ServiceOrderOrderByRelationAggregateInput
    verifiedResults?: LabResultOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    surgerySStaffs?: SurgerySStaffOrderByRelationAggregateInput
  }

  export type StaffProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    departmentId?: StringNullableFilter<"StaffProfile"> | string | null
    fullName?: StringFilter<"StaffProfile"> | string
    qualification?: StringNullableFilter<"StaffProfile"> | string | null
    registrationNumber?: StringNullableFilter<"StaffProfile"> | string | null
    contactNumber?: StringNullableFilter<"StaffProfile"> | string | null
    shiftTiming?: StringNullableFilter<"StaffProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    headOfDepartments?: DepartmentListRelationFilter
    appointments?: AppointmentListRelationFilter
    opdVisits?: OpdVisitListRelationFilter
    admissions?: AdmissionListRelationFilter
    surgeries?: SurgeryListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    verifiedResults?: LabResultListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    surgerySStaffs?: SurgerySStaffListRelationFilter
  }, "id">

  export type StaffProfileOrderByWithAggregationInput = {
    id?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    fullName?: SortOrder
    qualification?: SortOrderInput | SortOrder
    registrationNumber?: SortOrderInput | SortOrder
    contactNumber?: SortOrderInput | SortOrder
    shiftTiming?: SortOrderInput | SortOrder
    _count?: StaffProfileCountOrderByAggregateInput
    _max?: StaffProfileMaxOrderByAggregateInput
    _min?: StaffProfileMinOrderByAggregateInput
  }

  export type StaffProfileScalarWhereWithAggregatesInput = {
    AND?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    OR?: StaffProfileScalarWhereWithAggregatesInput[]
    NOT?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffProfile"> | string
    departmentId?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    fullName?: StringWithAggregatesFilter<"StaffProfile"> | string
    qualification?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    registrationNumber?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    contactNumber?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    shiftTiming?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    headDoctorId?: StringNullableFilter<"Department"> | string | null
    type?: EnumDepartmentTypeFilter<"Department"> | $Enums.DepartmentType
    headDoctor?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    staff?: StaffProfileListRelationFilter
    services?: ServiceListRelationFilter
    wards?: WardListRelationFilter
    appointments?: AppointmentListRelationFilter
    admissions?: AdmissionListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    headDoctorId?: SortOrderInput | SortOrder
    type?: SortOrder
    headDoctor?: StaffProfileOrderByWithRelationInput
    staff?: StaffProfileOrderByRelationAggregateInput
    services?: ServiceOrderByRelationAggregateInput
    wards?: WardOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    headDoctorId?: StringNullableFilter<"Department"> | string | null
    type?: EnumDepartmentTypeFilter<"Department"> | $Enums.DepartmentType
    headDoctor?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    staff?: StaffProfileListRelationFilter
    services?: ServiceListRelationFilter
    wards?: WardListRelationFilter
    appointments?: AppointmentListRelationFilter
    admissions?: AdmissionListRelationFilter
  }, "id" | "code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    headDoctorId?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringWithAggregatesFilter<"Department"> | string
    headDoctorId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    type?: EnumDepartmentTypeWithAggregatesFilter<"Department"> | $Enums.DepartmentType
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: StringFilter<"Service"> | string
    basePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    code?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    serviceOrders?: ServiceOrderListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    basePrice?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    serviceOrders?: ServiceOrderOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: StringFilter<"Service"> | string
    basePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    code?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    serviceOrders?: ServiceOrderListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    basePrice?: SortOrder
    code?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    name?: StringWithAggregatesFilter<"Service"> | string
    category?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: StringWithAggregatesFilter<"Service"> | string
    basePrice?: DecimalWithAggregatesFilter<"Service"> | Decimal | DecimalJsLike | number | string
    code?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
  }

  export type WardWhereInput = {
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    id?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    departmentId?: StringFilter<"Ward"> | string
    floorNumber?: IntFilter<"Ward"> | number
    type?: StringFilter<"Ward"> | string
    basePricePerDay?: DecimalFilter<"Ward"> | Decimal | DecimalJsLike | number | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    beds?: BedListRelationFilter
  }

  export type WardOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    floorNumber?: SortOrder
    type?: SortOrder
    basePricePerDay?: SortOrder
    department?: DepartmentOrderByWithRelationInput
    beds?: BedOrderByRelationAggregateInput
  }

  export type WardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WardWhereInput | WardWhereInput[]
    OR?: WardWhereInput[]
    NOT?: WardWhereInput | WardWhereInput[]
    name?: StringFilter<"Ward"> | string
    departmentId?: StringFilter<"Ward"> | string
    floorNumber?: IntFilter<"Ward"> | number
    type?: StringFilter<"Ward"> | string
    basePricePerDay?: DecimalFilter<"Ward"> | Decimal | DecimalJsLike | number | string
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    beds?: BedListRelationFilter
  }, "id">

  export type WardOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    floorNumber?: SortOrder
    type?: SortOrder
    basePricePerDay?: SortOrder
    _count?: WardCountOrderByAggregateInput
    _avg?: WardAvgOrderByAggregateInput
    _max?: WardMaxOrderByAggregateInput
    _min?: WardMinOrderByAggregateInput
    _sum?: WardSumOrderByAggregateInput
  }

  export type WardScalarWhereWithAggregatesInput = {
    AND?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    OR?: WardScalarWhereWithAggregatesInput[]
    NOT?: WardScalarWhereWithAggregatesInput | WardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ward"> | string
    name?: StringWithAggregatesFilter<"Ward"> | string
    departmentId?: StringWithAggregatesFilter<"Ward"> | string
    floorNumber?: IntWithAggregatesFilter<"Ward"> | number
    type?: StringWithAggregatesFilter<"Ward"> | string
    basePricePerDay?: DecimalWithAggregatesFilter<"Ward"> | Decimal | DecimalJsLike | number | string
  }

  export type BedWhereInput = {
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    id?: StringFilter<"Bed"> | string
    wardId?: StringFilter<"Bed"> | string
    bedNumber?: StringFilter<"Bed"> | string
    status?: EnumBedStatusFilter<"Bed"> | $Enums.BedStatus
    ward?: XOR<WardScalarRelationFilter, WardWhereInput>
    transfers?: BedTransferListRelationFilter
    activeAdmissions?: AdmissionListRelationFilter
  }

  export type BedOrderByWithRelationInput = {
    id?: SortOrder
    wardId?: SortOrder
    bedNumber?: SortOrder
    status?: SortOrder
    ward?: WardOrderByWithRelationInput
    transfers?: BedTransferOrderByRelationAggregateInput
    activeAdmissions?: AdmissionOrderByRelationAggregateInput
  }

  export type BedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BedWhereInput | BedWhereInput[]
    OR?: BedWhereInput[]
    NOT?: BedWhereInput | BedWhereInput[]
    wardId?: StringFilter<"Bed"> | string
    bedNumber?: StringFilter<"Bed"> | string
    status?: EnumBedStatusFilter<"Bed"> | $Enums.BedStatus
    ward?: XOR<WardScalarRelationFilter, WardWhereInput>
    transfers?: BedTransferListRelationFilter
    activeAdmissions?: AdmissionListRelationFilter
  }, "id">

  export type BedOrderByWithAggregationInput = {
    id?: SortOrder
    wardId?: SortOrder
    bedNumber?: SortOrder
    status?: SortOrder
    _count?: BedCountOrderByAggregateInput
    _max?: BedMaxOrderByAggregateInput
    _min?: BedMinOrderByAggregateInput
  }

  export type BedScalarWhereWithAggregatesInput = {
    AND?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    OR?: BedScalarWhereWithAggregatesInput[]
    NOT?: BedScalarWhereWithAggregatesInput | BedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bed"> | string
    wardId?: StringWithAggregatesFilter<"Bed"> | string
    bedNumber?: StringWithAggregatesFilter<"Bed"> | string
    status?: EnumBedStatusWithAggregatesFilter<"Bed"> | $Enums.BedStatus
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    uhid?: StringFilter<"Patient"> | string
    firstName?: StringFilter<"Patient"> | string
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringNullableFilter<"Patient"> | string | null
    maritalStatus?: StringNullableFilter<"Patient"> | string | null
    nationality?: StringNullableFilter<"Patient"> | string | null
    phone?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    preferredLanguage?: StringNullableFilter<"Patient"> | string | null
    permanentAddress?: StringNullableFilter<"Patient"> | string | null
    currentAddress?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    pincode?: StringNullableFilter<"Patient"> | string | null
    idProofType?: StringNullableFilter<"Patient"> | string | null
    idProofNumber?: StringNullableFilter<"Patient"> | string | null
    abhaId?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    emergencyContactRelation?: StringNullableFilter<"Patient"> | string | null
    defaultPayerType?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    policyNumber?: StringNullableFilter<"Patient"> | string | null
    isDeceased?: BoolFilter<"Patient"> | boolean
    registrationDate?: DateTimeFilter<"Patient"> | Date | string
    medicalHistory?: MedicalHistoryListRelationFilter
    documents?: PatientDocumentListRelationFilter
    appointments?: AppointmentListRelationFilter
    opdVisits?: OpdVisitListRelationFilter
    admissions?: AdmissionListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    pharmacySales?: PharmacySaleListRelationFilter
    invoices?: InvoiceListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    uhid?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    currentAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    idProofType?: SortOrderInput | SortOrder
    idProofNumber?: SortOrderInput | SortOrder
    abhaId?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    defaultPayerType?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    policyNumber?: SortOrderInput | SortOrder
    isDeceased?: SortOrder
    registrationDate?: SortOrder
    medicalHistory?: MedicalHistoryOrderByRelationAggregateInput
    documents?: PatientDocumentOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    opdVisits?: OpdVisitOrderByRelationAggregateInput
    admissions?: AdmissionOrderByRelationAggregateInput
    clinicalNotes?: ClinicalNoteOrderByRelationAggregateInput
    serviceOrders?: ServiceOrderOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    pharmacySales?: PharmacySaleOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    uhid?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    firstName?: StringFilter<"Patient"> | string
    middleName?: StringNullableFilter<"Patient"> | string | null
    lastName?: StringFilter<"Patient"> | string
    dob?: DateTimeFilter<"Patient"> | Date | string
    gender?: StringNullableFilter<"Patient"> | string | null
    maritalStatus?: StringNullableFilter<"Patient"> | string | null
    nationality?: StringNullableFilter<"Patient"> | string | null
    phone?: StringFilter<"Patient"> | string
    email?: StringNullableFilter<"Patient"> | string | null
    preferredLanguage?: StringNullableFilter<"Patient"> | string | null
    permanentAddress?: StringNullableFilter<"Patient"> | string | null
    currentAddress?: StringNullableFilter<"Patient"> | string | null
    city?: StringNullableFilter<"Patient"> | string | null
    state?: StringNullableFilter<"Patient"> | string | null
    pincode?: StringNullableFilter<"Patient"> | string | null
    idProofType?: StringNullableFilter<"Patient"> | string | null
    idProofNumber?: StringNullableFilter<"Patient"> | string | null
    abhaId?: StringNullableFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableFilter<"Patient"> | string | null
    emergencyContactRelation?: StringNullableFilter<"Patient"> | string | null
    defaultPayerType?: StringNullableFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableFilter<"Patient"> | string | null
    policyNumber?: StringNullableFilter<"Patient"> | string | null
    isDeceased?: BoolFilter<"Patient"> | boolean
    registrationDate?: DateTimeFilter<"Patient"> | Date | string
    medicalHistory?: MedicalHistoryListRelationFilter
    documents?: PatientDocumentListRelationFilter
    appointments?: AppointmentListRelationFilter
    opdVisits?: OpdVisitListRelationFilter
    admissions?: AdmissionListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    pharmacySales?: PharmacySaleListRelationFilter
    invoices?: InvoiceListRelationFilter
  }, "id" | "uhid">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    uhid?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrderInput | SortOrder
    maritalStatus?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    permanentAddress?: SortOrderInput | SortOrder
    currentAddress?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    pincode?: SortOrderInput | SortOrder
    idProofType?: SortOrderInput | SortOrder
    idProofNumber?: SortOrderInput | SortOrder
    abhaId?: SortOrderInput | SortOrder
    emergencyContactName?: SortOrderInput | SortOrder
    emergencyContactPhone?: SortOrderInput | SortOrder
    emergencyContactRelation?: SortOrderInput | SortOrder
    defaultPayerType?: SortOrderInput | SortOrder
    insuranceProvider?: SortOrderInput | SortOrder
    policyNumber?: SortOrderInput | SortOrder
    isDeceased?: SortOrder
    registrationDate?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    uhid?: StringWithAggregatesFilter<"Patient"> | string
    firstName?: StringWithAggregatesFilter<"Patient"> | string
    middleName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    lastName?: StringWithAggregatesFilter<"Patient"> | string
    dob?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    gender?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    maritalStatus?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringWithAggregatesFilter<"Patient"> | string
    email?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    preferredLanguage?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    permanentAddress?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    currentAddress?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    city?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    state?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    pincode?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    idProofType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    idProofNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    abhaId?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactName?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactPhone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    emergencyContactRelation?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    defaultPayerType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    insuranceProvider?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    policyNumber?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    isDeceased?: BoolWithAggregatesFilter<"Patient"> | boolean
    registrationDate?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type MedicalHistoryWhereInput = {
    AND?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    OR?: MedicalHistoryWhereInput[]
    NOT?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    id?: StringFilter<"MedicalHistory"> | string
    patientId?: StringFilter<"MedicalHistory"> | string
    category?: StringFilter<"MedicalHistory"> | string
    name?: StringFilter<"MedicalHistory"> | string
    severity?: StringNullableFilter<"MedicalHistory"> | string | null
    status?: StringNullableFilter<"MedicalHistory"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"MedicalHistory"> | Date | string | null
    notes?: StringNullableFilter<"MedicalHistory"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }

  export type MedicalHistoryOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    category?: SortOrder
    name?: SortOrder
    severity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type MedicalHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    OR?: MedicalHistoryWhereInput[]
    NOT?: MedicalHistoryWhereInput | MedicalHistoryWhereInput[]
    patientId?: StringFilter<"MedicalHistory"> | string
    category?: StringFilter<"MedicalHistory"> | string
    name?: StringFilter<"MedicalHistory"> | string
    severity?: StringNullableFilter<"MedicalHistory"> | string | null
    status?: StringNullableFilter<"MedicalHistory"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"MedicalHistory"> | Date | string | null
    notes?: StringNullableFilter<"MedicalHistory"> | string | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
  }, "id">

  export type MedicalHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    category?: SortOrder
    name?: SortOrder
    severity?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    diagnosedDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: MedicalHistoryCountOrderByAggregateInput
    _max?: MedicalHistoryMaxOrderByAggregateInput
    _min?: MedicalHistoryMinOrderByAggregateInput
  }

  export type MedicalHistoryScalarWhereWithAggregatesInput = {
    AND?: MedicalHistoryScalarWhereWithAggregatesInput | MedicalHistoryScalarWhereWithAggregatesInput[]
    OR?: MedicalHistoryScalarWhereWithAggregatesInput[]
    NOT?: MedicalHistoryScalarWhereWithAggregatesInput | MedicalHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalHistory"> | string
    patientId?: StringWithAggregatesFilter<"MedicalHistory"> | string
    category?: StringWithAggregatesFilter<"MedicalHistory"> | string
    name?: StringWithAggregatesFilter<"MedicalHistory"> | string
    severity?: StringNullableWithAggregatesFilter<"MedicalHistory"> | string | null
    status?: StringNullableWithAggregatesFilter<"MedicalHistory"> | string | null
    diagnosedDate?: DateTimeNullableWithAggregatesFilter<"MedicalHistory"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"MedicalHistory"> | string | null
  }

  export type PatientDocumentWhereInput = {
    AND?: PatientDocumentWhereInput | PatientDocumentWhereInput[]
    OR?: PatientDocumentWhereInput[]
    NOT?: PatientDocumentWhereInput | PatientDocumentWhereInput[]
    id?: StringFilter<"PatientDocument"> | string
    patientId?: StringFilter<"PatientDocument"> | string
    visitId?: StringNullableFilter<"PatientDocument"> | string | null
    admissionId?: StringNullableFilter<"PatientDocument"> | string | null
    category?: StringFilter<"PatientDocument"> | string
    fileUrl?: StringFilter<"PatientDocument"> | string
    uploadedBy?: StringNullableFilter<"PatientDocument"> | string | null
    uploadedAt?: DateTimeFilter<"PatientDocument"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
  }

  export type PatientDocumentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    admission?: AdmissionOrderByWithRelationInput
  }

  export type PatientDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientDocumentWhereInput | PatientDocumentWhereInput[]
    OR?: PatientDocumentWhereInput[]
    NOT?: PatientDocumentWhereInput | PatientDocumentWhereInput[]
    patientId?: StringFilter<"PatientDocument"> | string
    visitId?: StringNullableFilter<"PatientDocument"> | string | null
    admissionId?: StringNullableFilter<"PatientDocument"> | string | null
    category?: StringFilter<"PatientDocument"> | string
    fileUrl?: StringFilter<"PatientDocument"> | string
    uploadedBy?: StringNullableFilter<"PatientDocument"> | string | null
    uploadedAt?: DateTimeFilter<"PatientDocument"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
  }, "id">

  export type PatientDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    _count?: PatientDocumentCountOrderByAggregateInput
    _max?: PatientDocumentMaxOrderByAggregateInput
    _min?: PatientDocumentMinOrderByAggregateInput
  }

  export type PatientDocumentScalarWhereWithAggregatesInput = {
    AND?: PatientDocumentScalarWhereWithAggregatesInput | PatientDocumentScalarWhereWithAggregatesInput[]
    OR?: PatientDocumentScalarWhereWithAggregatesInput[]
    NOT?: PatientDocumentScalarWhereWithAggregatesInput | PatientDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientDocument"> | string
    patientId?: StringWithAggregatesFilter<"PatientDocument"> | string
    visitId?: StringNullableWithAggregatesFilter<"PatientDocument"> | string | null
    admissionId?: StringNullableWithAggregatesFilter<"PatientDocument"> | string | null
    category?: StringWithAggregatesFilter<"PatientDocument"> | string
    fileUrl?: StringWithAggregatesFilter<"PatientDocument"> | string
    uploadedBy?: StringNullableWithAggregatesFilter<"PatientDocument"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"PatientDocument"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    tokenNumber?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    opdVisit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    appointmentDate?: SortOrder
    tokenNumber?: SortOrder
    status?: SortOrder
    type?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: StaffProfileOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    opdVisit?: OpdVisitOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    tokenNumber?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    opdVisit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    appointmentDate?: SortOrder
    tokenNumber?: SortOrder
    status?: SortOrder
    type?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    doctorId?: StringWithAggregatesFilter<"Appointment"> | string
    departmentId?: StringWithAggregatesFilter<"Appointment"> | string
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    tokenNumber?: IntWithAggregatesFilter<"Appointment"> | number
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeWithAggregatesFilter<"Appointment"> | $Enums.AppointmentType
  }

  export type OpdVisitWhereInput = {
    AND?: OpdVisitWhereInput | OpdVisitWhereInput[]
    OR?: OpdVisitWhereInput[]
    NOT?: OpdVisitWhereInput | OpdVisitWhereInput[]
    id?: StringFilter<"OpdVisit"> | string
    appointmentId?: StringNullableFilter<"OpdVisit"> | string | null
    patientId?: StringFilter<"OpdVisit"> | string
    doctorId?: StringFilter<"OpdVisit"> | string
    visitDate?: DateTimeFilter<"OpdVisit"> | Date | string
    visitType?: EnumVisitTypeFilter<"OpdVisit"> | $Enums.VisitType
    triageColor?: EnumTriageColorNullableFilter<"OpdVisit"> | $Enums.TriageColor | null
    status?: EnumVisitStatusFilter<"OpdVisit"> | $Enums.VisitStatus
    isMedicoLegal?: BoolFilter<"OpdVisit"> | boolean
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    documents?: PatientDocumentListRelationFilter
    invoices?: InvoiceListRelationFilter
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
  }

  export type OpdVisitOrderByWithRelationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    triageColor?: SortOrderInput | SortOrder
    status?: SortOrder
    isMedicoLegal?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    doctor?: StaffProfileOrderByWithRelationInput
    clinicalNotes?: ClinicalNoteOrderByRelationAggregateInput
    serviceOrders?: ServiceOrderOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    documents?: PatientDocumentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    admission?: AdmissionOrderByWithRelationInput
  }

  export type OpdVisitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    appointmentId?: string
    AND?: OpdVisitWhereInput | OpdVisitWhereInput[]
    OR?: OpdVisitWhereInput[]
    NOT?: OpdVisitWhereInput | OpdVisitWhereInput[]
    patientId?: StringFilter<"OpdVisit"> | string
    doctorId?: StringFilter<"OpdVisit"> | string
    visitDate?: DateTimeFilter<"OpdVisit"> | Date | string
    visitType?: EnumVisitTypeFilter<"OpdVisit"> | $Enums.VisitType
    triageColor?: EnumTriageColorNullableFilter<"OpdVisit"> | $Enums.TriageColor | null
    status?: EnumVisitStatusFilter<"OpdVisit"> | $Enums.VisitStatus
    isMedicoLegal?: BoolFilter<"OpdVisit"> | boolean
    appointment?: XOR<AppointmentNullableScalarRelationFilter, AppointmentWhereInput> | null
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    documents?: PatientDocumentListRelationFilter
    invoices?: InvoiceListRelationFilter
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
  }, "id" | "appointmentId">

  export type OpdVisitOrderByWithAggregationInput = {
    id?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    triageColor?: SortOrderInput | SortOrder
    status?: SortOrder
    isMedicoLegal?: SortOrder
    _count?: OpdVisitCountOrderByAggregateInput
    _max?: OpdVisitMaxOrderByAggregateInput
    _min?: OpdVisitMinOrderByAggregateInput
  }

  export type OpdVisitScalarWhereWithAggregatesInput = {
    AND?: OpdVisitScalarWhereWithAggregatesInput | OpdVisitScalarWhereWithAggregatesInput[]
    OR?: OpdVisitScalarWhereWithAggregatesInput[]
    NOT?: OpdVisitScalarWhereWithAggregatesInput | OpdVisitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OpdVisit"> | string
    appointmentId?: StringNullableWithAggregatesFilter<"OpdVisit"> | string | null
    patientId?: StringWithAggregatesFilter<"OpdVisit"> | string
    doctorId?: StringWithAggregatesFilter<"OpdVisit"> | string
    visitDate?: DateTimeWithAggregatesFilter<"OpdVisit"> | Date | string
    visitType?: EnumVisitTypeWithAggregatesFilter<"OpdVisit"> | $Enums.VisitType
    triageColor?: EnumTriageColorNullableWithAggregatesFilter<"OpdVisit"> | $Enums.TriageColor | null
    status?: EnumVisitStatusWithAggregatesFilter<"OpdVisit"> | $Enums.VisitStatus
    isMedicoLegal?: BoolWithAggregatesFilter<"OpdVisit"> | boolean
  }

  export type AdmissionWhereInput = {
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    id?: StringFilter<"Admission"> | string
    patientId?: StringFilter<"Admission"> | string
    admittingDoctorId?: StringFilter<"Admission"> | string
    departmentId?: StringFilter<"Admission"> | string
    visitId?: StringNullableFilter<"Admission"> | string | null
    currentBedId?: StringNullableFilter<"Admission"> | string | null
    admissionDate?: DateTimeFilter<"Admission"> | Date | string
    dischargeDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    reasonForAdmission?: StringNullableFilter<"Admission"> | string | null
    admissionType?: EnumAdmissionTypeFilter<"Admission"> | $Enums.AdmissionType
    status?: EnumAdmissionStatusFilter<"Admission"> | $Enums.AdmissionStatus
    dischargeType?: EnumDischargeTypeNullableFilter<"Admission"> | $Enums.DischargeType | null
    mlc?: BoolFilter<"Admission"> | boolean
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    admittingDoctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    currentBed?: XOR<BedNullableScalarRelationFilter, BedWhereInput> | null
    bedTransfers?: BedTransferListRelationFilter
    surgeries?: SurgeryListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    documents?: PatientDocumentListRelationFilter
    invoices?: InvoiceListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
  }

  export type AdmissionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    admittingDoctorId?: SortOrder
    departmentId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    currentBedId?: SortOrderInput | SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    reasonForAdmission?: SortOrderInput | SortOrder
    admissionType?: SortOrder
    status?: SortOrder
    dischargeType?: SortOrderInput | SortOrder
    mlc?: SortOrder
    patient?: PatientOrderByWithRelationInput
    admittingDoctor?: StaffProfileOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    currentBed?: BedOrderByWithRelationInput
    bedTransfers?: BedTransferOrderByRelationAggregateInput
    surgeries?: SurgeryOrderByRelationAggregateInput
    clinicalNotes?: ClinicalNoteOrderByRelationAggregateInput
    serviceOrders?: ServiceOrderOrderByRelationAggregateInput
    prescriptions?: PrescriptionOrderByRelationAggregateInput
    documents?: PatientDocumentOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    insuranceClaims?: InsuranceClaimOrderByRelationAggregateInput
  }

  export type AdmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    visitId?: string
    AND?: AdmissionWhereInput | AdmissionWhereInput[]
    OR?: AdmissionWhereInput[]
    NOT?: AdmissionWhereInput | AdmissionWhereInput[]
    patientId?: StringFilter<"Admission"> | string
    admittingDoctorId?: StringFilter<"Admission"> | string
    departmentId?: StringFilter<"Admission"> | string
    currentBedId?: StringNullableFilter<"Admission"> | string | null
    admissionDate?: DateTimeFilter<"Admission"> | Date | string
    dischargeDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    reasonForAdmission?: StringNullableFilter<"Admission"> | string | null
    admissionType?: EnumAdmissionTypeFilter<"Admission"> | $Enums.AdmissionType
    status?: EnumAdmissionStatusFilter<"Admission"> | $Enums.AdmissionStatus
    dischargeType?: EnumDischargeTypeNullableFilter<"Admission"> | $Enums.DischargeType | null
    mlc?: BoolFilter<"Admission"> | boolean
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    admittingDoctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    currentBed?: XOR<BedNullableScalarRelationFilter, BedWhereInput> | null
    bedTransfers?: BedTransferListRelationFilter
    surgeries?: SurgeryListRelationFilter
    clinicalNotes?: ClinicalNoteListRelationFilter
    serviceOrders?: ServiceOrderListRelationFilter
    prescriptions?: PrescriptionListRelationFilter
    documents?: PatientDocumentListRelationFilter
    invoices?: InvoiceListRelationFilter
    insuranceClaims?: InsuranceClaimListRelationFilter
  }, "id" | "visitId">

  export type AdmissionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    admittingDoctorId?: SortOrder
    departmentId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    currentBedId?: SortOrderInput | SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrderInput | SortOrder
    reasonForAdmission?: SortOrderInput | SortOrder
    admissionType?: SortOrder
    status?: SortOrder
    dischargeType?: SortOrderInput | SortOrder
    mlc?: SortOrder
    _count?: AdmissionCountOrderByAggregateInput
    _max?: AdmissionMaxOrderByAggregateInput
    _min?: AdmissionMinOrderByAggregateInput
  }

  export type AdmissionScalarWhereWithAggregatesInput = {
    AND?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    OR?: AdmissionScalarWhereWithAggregatesInput[]
    NOT?: AdmissionScalarWhereWithAggregatesInput | AdmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admission"> | string
    patientId?: StringWithAggregatesFilter<"Admission"> | string
    admittingDoctorId?: StringWithAggregatesFilter<"Admission"> | string
    departmentId?: StringWithAggregatesFilter<"Admission"> | string
    visitId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    currentBedId?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admissionDate?: DateTimeWithAggregatesFilter<"Admission"> | Date | string
    dischargeDate?: DateTimeNullableWithAggregatesFilter<"Admission"> | Date | string | null
    reasonForAdmission?: StringNullableWithAggregatesFilter<"Admission"> | string | null
    admissionType?: EnumAdmissionTypeWithAggregatesFilter<"Admission"> | $Enums.AdmissionType
    status?: EnumAdmissionStatusWithAggregatesFilter<"Admission"> | $Enums.AdmissionStatus
    dischargeType?: EnumDischargeTypeNullableWithAggregatesFilter<"Admission"> | $Enums.DischargeType | null
    mlc?: BoolWithAggregatesFilter<"Admission"> | boolean
  }

  export type BedTransferWhereInput = {
    AND?: BedTransferWhereInput | BedTransferWhereInput[]
    OR?: BedTransferWhereInput[]
    NOT?: BedTransferWhereInput | BedTransferWhereInput[]
    id?: StringFilter<"BedTransfer"> | string
    admissionId?: StringFilter<"BedTransfer"> | string
    bedId?: StringFilter<"BedTransfer"> | string
    startDate?: DateTimeFilter<"BedTransfer"> | Date | string
    endDate?: DateTimeNullableFilter<"BedTransfer"> | Date | string | null
    reason?: StringNullableFilter<"BedTransfer"> | string | null
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
    bed?: XOR<BedScalarRelationFilter, BedWhereInput>
  }

  export type BedTransferOrderByWithRelationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    bedId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    admission?: AdmissionOrderByWithRelationInput
    bed?: BedOrderByWithRelationInput
  }

  export type BedTransferWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BedTransferWhereInput | BedTransferWhereInput[]
    OR?: BedTransferWhereInput[]
    NOT?: BedTransferWhereInput | BedTransferWhereInput[]
    admissionId?: StringFilter<"BedTransfer"> | string
    bedId?: StringFilter<"BedTransfer"> | string
    startDate?: DateTimeFilter<"BedTransfer"> | Date | string
    endDate?: DateTimeNullableFilter<"BedTransfer"> | Date | string | null
    reason?: StringNullableFilter<"BedTransfer"> | string | null
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
    bed?: XOR<BedScalarRelationFilter, BedWhereInput>
  }, "id">

  export type BedTransferOrderByWithAggregationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    bedId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    _count?: BedTransferCountOrderByAggregateInput
    _max?: BedTransferMaxOrderByAggregateInput
    _min?: BedTransferMinOrderByAggregateInput
  }

  export type BedTransferScalarWhereWithAggregatesInput = {
    AND?: BedTransferScalarWhereWithAggregatesInput | BedTransferScalarWhereWithAggregatesInput[]
    OR?: BedTransferScalarWhereWithAggregatesInput[]
    NOT?: BedTransferScalarWhereWithAggregatesInput | BedTransferScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BedTransfer"> | string
    admissionId?: StringWithAggregatesFilter<"BedTransfer"> | string
    bedId?: StringWithAggregatesFilter<"BedTransfer"> | string
    startDate?: DateTimeWithAggregatesFilter<"BedTransfer"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"BedTransfer"> | Date | string | null
    reason?: StringNullableWithAggregatesFilter<"BedTransfer"> | string | null
  }

  export type SurgeryWhereInput = {
    AND?: SurgeryWhereInput | SurgeryWhereInput[]
    OR?: SurgeryWhereInput[]
    NOT?: SurgeryWhereInput | SurgeryWhereInput[]
    id?: StringFilter<"Surgery"> | string
    admissionId?: StringFilter<"Surgery"> | string
    procedureName?: StringFilter<"Surgery"> | string
    surgeonId?: StringFilter<"Surgery"> | string
    otRoomNumber?: StringNullableFilter<"Surgery"> | string | null
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    status?: EnumSurgeryStatusFilter<"Surgery"> | $Enums.SurgeryStatus
    notes?: StringNullableFilter<"Surgery"> | string | null
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
    surgeon?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    checklists?: SurgicalChecklistListRelationFilter
    surgerySStaffs?: SurgerySStaffListRelationFilter
  }

  export type SurgeryOrderByWithRelationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    procedureName?: SortOrder
    surgeonId?: SortOrder
    otRoomNumber?: SortOrderInput | SortOrder
    surgeryDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    admission?: AdmissionOrderByWithRelationInput
    surgeon?: StaffProfileOrderByWithRelationInput
    checklists?: SurgicalChecklistOrderByRelationAggregateInput
    surgerySStaffs?: SurgerySStaffOrderByRelationAggregateInput
  }

  export type SurgeryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurgeryWhereInput | SurgeryWhereInput[]
    OR?: SurgeryWhereInput[]
    NOT?: SurgeryWhereInput | SurgeryWhereInput[]
    admissionId?: StringFilter<"Surgery"> | string
    procedureName?: StringFilter<"Surgery"> | string
    surgeonId?: StringFilter<"Surgery"> | string
    otRoomNumber?: StringNullableFilter<"Surgery"> | string | null
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    status?: EnumSurgeryStatusFilter<"Surgery"> | $Enums.SurgeryStatus
    notes?: StringNullableFilter<"Surgery"> | string | null
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
    surgeon?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    checklists?: SurgicalChecklistListRelationFilter
    surgerySStaffs?: SurgerySStaffListRelationFilter
  }, "id">

  export type SurgeryOrderByWithAggregationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    procedureName?: SortOrder
    surgeonId?: SortOrder
    otRoomNumber?: SortOrderInput | SortOrder
    surgeryDate?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: SurgeryCountOrderByAggregateInput
    _max?: SurgeryMaxOrderByAggregateInput
    _min?: SurgeryMinOrderByAggregateInput
  }

  export type SurgeryScalarWhereWithAggregatesInput = {
    AND?: SurgeryScalarWhereWithAggregatesInput | SurgeryScalarWhereWithAggregatesInput[]
    OR?: SurgeryScalarWhereWithAggregatesInput[]
    NOT?: SurgeryScalarWhereWithAggregatesInput | SurgeryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Surgery"> | string
    admissionId?: StringWithAggregatesFilter<"Surgery"> | string
    procedureName?: StringWithAggregatesFilter<"Surgery"> | string
    surgeonId?: StringWithAggregatesFilter<"Surgery"> | string
    otRoomNumber?: StringNullableWithAggregatesFilter<"Surgery"> | string | null
    surgeryDate?: DateTimeWithAggregatesFilter<"Surgery"> | Date | string
    status?: EnumSurgeryStatusWithAggregatesFilter<"Surgery"> | $Enums.SurgeryStatus
    notes?: StringNullableWithAggregatesFilter<"Surgery"> | string | null
  }

  export type SurgerySStaffWhereInput = {
    AND?: SurgerySStaffWhereInput | SurgerySStaffWhereInput[]
    OR?: SurgerySStaffWhereInput[]
    NOT?: SurgerySStaffWhereInput | SurgerySStaffWhereInput[]
    surgeryId?: StringFilter<"SurgerySStaff"> | string
    staffId?: StringFilter<"SurgerySStaff"> | string
    role?: StringFilter<"SurgerySStaff"> | string
    surgery?: XOR<SurgeryScalarRelationFilter, SurgeryWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type SurgerySStaffOrderByWithRelationInput = {
    surgeryId?: SortOrder
    staffId?: SortOrder
    role?: SortOrder
    surgery?: SurgeryOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type SurgerySStaffWhereUniqueInput = Prisma.AtLeast<{
    surgeryId?: string
    AND?: SurgerySStaffWhereInput | SurgerySStaffWhereInput[]
    OR?: SurgerySStaffWhereInput[]
    NOT?: SurgerySStaffWhereInput | SurgerySStaffWhereInput[]
    staffId?: StringFilter<"SurgerySStaff"> | string
    role?: StringFilter<"SurgerySStaff"> | string
    surgery?: XOR<SurgeryScalarRelationFilter, SurgeryWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "surgeryId">

  export type SurgerySStaffOrderByWithAggregationInput = {
    surgeryId?: SortOrder
    staffId?: SortOrder
    role?: SortOrder
    _count?: SurgerySStaffCountOrderByAggregateInput
    _max?: SurgerySStaffMaxOrderByAggregateInput
    _min?: SurgerySStaffMinOrderByAggregateInput
  }

  export type SurgerySStaffScalarWhereWithAggregatesInput = {
    AND?: SurgerySStaffScalarWhereWithAggregatesInput | SurgerySStaffScalarWhereWithAggregatesInput[]
    OR?: SurgerySStaffScalarWhereWithAggregatesInput[]
    NOT?: SurgerySStaffScalarWhereWithAggregatesInput | SurgerySStaffScalarWhereWithAggregatesInput[]
    surgeryId?: StringWithAggregatesFilter<"SurgerySStaff"> | string
    staffId?: StringWithAggregatesFilter<"SurgerySStaff"> | string
    role?: StringWithAggregatesFilter<"SurgerySStaff"> | string
  }

  export type SurgicalChecklistWhereInput = {
    AND?: SurgicalChecklistWhereInput | SurgicalChecklistWhereInput[]
    OR?: SurgicalChecklistWhereInput[]
    NOT?: SurgicalChecklistWhereInput | SurgicalChecklistWhereInput[]
    id?: StringFilter<"SurgicalChecklist"> | string
    surgeryId?: StringFilter<"SurgicalChecklist"> | string
    stage?: EnumChecklistStageFilter<"SurgicalChecklist"> | $Enums.ChecklistStage
    itemName?: StringFilter<"SurgicalChecklist"> | string
    isChecked?: BoolFilter<"SurgicalChecklist"> | boolean
    checkedBy?: StringNullableFilter<"SurgicalChecklist"> | string | null
    timestamp?: DateTimeFilter<"SurgicalChecklist"> | Date | string
    surgery?: XOR<SurgeryScalarRelationFilter, SurgeryWhereInput>
  }

  export type SurgicalChecklistOrderByWithRelationInput = {
    id?: SortOrder
    surgeryId?: SortOrder
    stage?: SortOrder
    itemName?: SortOrder
    isChecked?: SortOrder
    checkedBy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    surgery?: SurgeryOrderByWithRelationInput
  }

  export type SurgicalChecklistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SurgicalChecklistWhereInput | SurgicalChecklistWhereInput[]
    OR?: SurgicalChecklistWhereInput[]
    NOT?: SurgicalChecklistWhereInput | SurgicalChecklistWhereInput[]
    surgeryId?: StringFilter<"SurgicalChecklist"> | string
    stage?: EnumChecklistStageFilter<"SurgicalChecklist"> | $Enums.ChecklistStage
    itemName?: StringFilter<"SurgicalChecklist"> | string
    isChecked?: BoolFilter<"SurgicalChecklist"> | boolean
    checkedBy?: StringNullableFilter<"SurgicalChecklist"> | string | null
    timestamp?: DateTimeFilter<"SurgicalChecklist"> | Date | string
    surgery?: XOR<SurgeryScalarRelationFilter, SurgeryWhereInput>
  }, "id">

  export type SurgicalChecklistOrderByWithAggregationInput = {
    id?: SortOrder
    surgeryId?: SortOrder
    stage?: SortOrder
    itemName?: SortOrder
    isChecked?: SortOrder
    checkedBy?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: SurgicalChecklistCountOrderByAggregateInput
    _max?: SurgicalChecklistMaxOrderByAggregateInput
    _min?: SurgicalChecklistMinOrderByAggregateInput
  }

  export type SurgicalChecklistScalarWhereWithAggregatesInput = {
    AND?: SurgicalChecklistScalarWhereWithAggregatesInput | SurgicalChecklistScalarWhereWithAggregatesInput[]
    OR?: SurgicalChecklistScalarWhereWithAggregatesInput[]
    NOT?: SurgicalChecklistScalarWhereWithAggregatesInput | SurgicalChecklistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SurgicalChecklist"> | string
    surgeryId?: StringWithAggregatesFilter<"SurgicalChecklist"> | string
    stage?: EnumChecklistStageWithAggregatesFilter<"SurgicalChecklist"> | $Enums.ChecklistStage
    itemName?: StringWithAggregatesFilter<"SurgicalChecklist"> | string
    isChecked?: BoolWithAggregatesFilter<"SurgicalChecklist"> | boolean
    checkedBy?: StringNullableWithAggregatesFilter<"SurgicalChecklist"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"SurgicalChecklist"> | Date | string
  }

  export type ClinicalNoteWhereInput = {
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    patientId?: StringFilter<"ClinicalNote"> | string
    visitId?: StringNullableFilter<"ClinicalNote"> | string | null
    admissionId?: StringNullableFilter<"ClinicalNote"> | string | null
    doctorId?: StringFilter<"ClinicalNote"> | string
    noteType?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    content?: JsonFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    isFinalized?: BoolFilter<"ClinicalNote"> | boolean
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type ClinicalNoteOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    doctorId?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isFinalized?: SortOrder
    patient?: PatientOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    admission?: AdmissionOrderByWithRelationInput
    doctor?: StaffProfileOrderByWithRelationInput
  }

  export type ClinicalNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    OR?: ClinicalNoteWhereInput[]
    NOT?: ClinicalNoteWhereInput | ClinicalNoteWhereInput[]
    patientId?: StringFilter<"ClinicalNote"> | string
    visitId?: StringNullableFilter<"ClinicalNote"> | string | null
    admissionId?: StringNullableFilter<"ClinicalNote"> | string | null
    doctorId?: StringFilter<"ClinicalNote"> | string
    noteType?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    content?: JsonFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    isFinalized?: BoolFilter<"ClinicalNote"> | boolean
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id">

  export type ClinicalNoteOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    doctorId?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isFinalized?: SortOrder
    _count?: ClinicalNoteCountOrderByAggregateInput
    _max?: ClinicalNoteMaxOrderByAggregateInput
    _min?: ClinicalNoteMinOrderByAggregateInput
  }

  export type ClinicalNoteScalarWhereWithAggregatesInput = {
    AND?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    OR?: ClinicalNoteScalarWhereWithAggregatesInput[]
    NOT?: ClinicalNoteScalarWhereWithAggregatesInput | ClinicalNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicalNote"> | string
    patientId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    visitId?: StringNullableWithAggregatesFilter<"ClinicalNote"> | string | null
    admissionId?: StringNullableWithAggregatesFilter<"ClinicalNote"> | string | null
    doctorId?: StringWithAggregatesFilter<"ClinicalNote"> | string
    noteType?: EnumNoteTypeWithAggregatesFilter<"ClinicalNote"> | $Enums.NoteType
    content?: JsonWithAggregatesFilter<"ClinicalNote">
    createdAt?: DateTimeWithAggregatesFilter<"ClinicalNote"> | Date | string
    isFinalized?: BoolWithAggregatesFilter<"ClinicalNote"> | boolean
  }

  export type ServiceOrderWhereInput = {
    AND?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    OR?: ServiceOrderWhereInput[]
    NOT?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    id?: StringFilter<"ServiceOrder"> | string
    patientId?: StringFilter<"ServiceOrder"> | string
    doctorId?: StringFilter<"ServiceOrder"> | string
    visitId?: StringNullableFilter<"ServiceOrder"> | string | null
    admissionId?: StringNullableFilter<"ServiceOrder"> | string | null
    serviceId?: StringFilter<"ServiceOrder"> | string
    orderType?: EnumOrderTypeFilter<"ServiceOrder"> | $Enums.OrderType
    priority?: EnumOrderPriorityFilter<"ServiceOrder"> | $Enums.OrderPriority
    clinicalIndication?: StringNullableFilter<"ServiceOrder"> | string | null
    isPaid?: BoolFilter<"ServiceOrder"> | boolean
    status?: EnumOrderStatusFilter<"ServiceOrder"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"ServiceOrder"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    labResults?: LabResultListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }

  export type ServiceOrderOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    orderType?: SortOrder
    priority?: SortOrder
    clinicalIndication?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: StaffProfileOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    admission?: AdmissionOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    labResults?: LabResultOrderByRelationAggregateInput
    invoiceItems?: InvoiceItemOrderByRelationAggregateInput
  }

  export type ServiceOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    OR?: ServiceOrderWhereInput[]
    NOT?: ServiceOrderWhereInput | ServiceOrderWhereInput[]
    patientId?: StringFilter<"ServiceOrder"> | string
    doctorId?: StringFilter<"ServiceOrder"> | string
    visitId?: StringNullableFilter<"ServiceOrder"> | string | null
    admissionId?: StringNullableFilter<"ServiceOrder"> | string | null
    serviceId?: StringFilter<"ServiceOrder"> | string
    orderType?: EnumOrderTypeFilter<"ServiceOrder"> | $Enums.OrderType
    priority?: EnumOrderPriorityFilter<"ServiceOrder"> | $Enums.OrderPriority
    clinicalIndication?: StringNullableFilter<"ServiceOrder"> | string | null
    isPaid?: BoolFilter<"ServiceOrder"> | boolean
    status?: EnumOrderStatusFilter<"ServiceOrder"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"ServiceOrder"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    labResults?: LabResultListRelationFilter
    invoiceItems?: InvoiceItemListRelationFilter
  }, "id">

  export type ServiceOrderOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    orderType?: SortOrder
    priority?: SortOrder
    clinicalIndication?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    _count?: ServiceOrderCountOrderByAggregateInput
    _max?: ServiceOrderMaxOrderByAggregateInput
    _min?: ServiceOrderMinOrderByAggregateInput
  }

  export type ServiceOrderScalarWhereWithAggregatesInput = {
    AND?: ServiceOrderScalarWhereWithAggregatesInput | ServiceOrderScalarWhereWithAggregatesInput[]
    OR?: ServiceOrderScalarWhereWithAggregatesInput[]
    NOT?: ServiceOrderScalarWhereWithAggregatesInput | ServiceOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceOrder"> | string
    patientId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    doctorId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    visitId?: StringNullableWithAggregatesFilter<"ServiceOrder"> | string | null
    admissionId?: StringNullableWithAggregatesFilter<"ServiceOrder"> | string | null
    serviceId?: StringWithAggregatesFilter<"ServiceOrder"> | string
    orderType?: EnumOrderTypeWithAggregatesFilter<"ServiceOrder"> | $Enums.OrderType
    priority?: EnumOrderPriorityWithAggregatesFilter<"ServiceOrder"> | $Enums.OrderPriority
    clinicalIndication?: StringNullableWithAggregatesFilter<"ServiceOrder"> | string | null
    isPaid?: BoolWithAggregatesFilter<"ServiceOrder"> | boolean
    status?: EnumOrderStatusWithAggregatesFilter<"ServiceOrder"> | $Enums.OrderStatus
    orderDate?: DateTimeWithAggregatesFilter<"ServiceOrder"> | Date | string
  }

  export type LabResultWhereInput = {
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    id?: StringFilter<"LabResult"> | string
    serviceOrderId?: StringFilter<"LabResult"> | string
    testName?: StringFilter<"LabResult"> | string
    resultValue?: StringFilter<"LabResult"> | string
    referenceRange?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    technicianId?: StringNullableFilter<"LabResult"> | string | null
    verifiedByDoctorId?: StringNullableFilter<"LabResult"> | string | null
    resultDate?: DateTimeFilter<"LabResult"> | Date | string
    serviceOrder?: XOR<ServiceOrderScalarRelationFilter, ServiceOrderWhereInput>
    technician?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    verifiedBy?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }

  export type LabResultOrderByWithRelationInput = {
    id?: SortOrder
    serviceOrderId?: SortOrder
    testName?: SortOrder
    resultValue?: SortOrder
    referenceRange?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    technicianId?: SortOrderInput | SortOrder
    verifiedByDoctorId?: SortOrderInput | SortOrder
    resultDate?: SortOrder
    serviceOrder?: ServiceOrderOrderByWithRelationInput
    technician?: UserOrderByWithRelationInput
    verifiedBy?: StaffProfileOrderByWithRelationInput
  }

  export type LabResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabResultWhereInput | LabResultWhereInput[]
    OR?: LabResultWhereInput[]
    NOT?: LabResultWhereInput | LabResultWhereInput[]
    serviceOrderId?: StringFilter<"LabResult"> | string
    testName?: StringFilter<"LabResult"> | string
    resultValue?: StringFilter<"LabResult"> | string
    referenceRange?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    technicianId?: StringNullableFilter<"LabResult"> | string | null
    verifiedByDoctorId?: StringNullableFilter<"LabResult"> | string | null
    resultDate?: DateTimeFilter<"LabResult"> | Date | string
    serviceOrder?: XOR<ServiceOrderScalarRelationFilter, ServiceOrderWhereInput>
    technician?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    verifiedBy?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }, "id">

  export type LabResultOrderByWithAggregationInput = {
    id?: SortOrder
    serviceOrderId?: SortOrder
    testName?: SortOrder
    resultValue?: SortOrder
    referenceRange?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    technicianId?: SortOrderInput | SortOrder
    verifiedByDoctorId?: SortOrderInput | SortOrder
    resultDate?: SortOrder
    _count?: LabResultCountOrderByAggregateInput
    _max?: LabResultMaxOrderByAggregateInput
    _min?: LabResultMinOrderByAggregateInput
  }

  export type LabResultScalarWhereWithAggregatesInput = {
    AND?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    OR?: LabResultScalarWhereWithAggregatesInput[]
    NOT?: LabResultScalarWhereWithAggregatesInput | LabResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabResult"> | string
    serviceOrderId?: StringWithAggregatesFilter<"LabResult"> | string
    testName?: StringWithAggregatesFilter<"LabResult"> | string
    resultValue?: StringWithAggregatesFilter<"LabResult"> | string
    referenceRange?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    unit?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    technicianId?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    verifiedByDoctorId?: StringNullableWithAggregatesFilter<"LabResult"> | string | null
    resultDate?: DateTimeWithAggregatesFilter<"LabResult"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    visitId?: StringNullableFilter<"Prescription"> | string | null
    admissionId?: StringNullableFilter<"Prescription"> | string | null
    isPaid?: BoolFilter<"Prescription"> | boolean
    date?: DateTimeFilter<"Prescription"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    items?: PrescriptionItemListRelationFilter
    sales?: PharmacySaleListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    date?: SortOrder
    patient?: PatientOrderByWithRelationInput
    doctor?: StaffProfileOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    admission?: AdmissionOrderByWithRelationInput
    items?: PrescriptionItemOrderByRelationAggregateInput
    sales?: PharmacySaleOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    visitId?: StringNullableFilter<"Prescription"> | string | null
    admissionId?: StringNullableFilter<"Prescription"> | string | null
    isPaid?: BoolFilter<"Prescription"> | boolean
    date?: DateTimeFilter<"Prescription"> | Date | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    doctor?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    items?: PrescriptionItemListRelationFilter
    sales?: PharmacySaleListRelationFilter
  }, "id">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrderInput | SortOrder
    admissionId?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    date?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prescription"> | string
    patientId?: StringWithAggregatesFilter<"Prescription"> | string
    doctorId?: StringWithAggregatesFilter<"Prescription"> | string
    visitId?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    admissionId?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    isPaid?: BoolWithAggregatesFilter<"Prescription"> | boolean
    date?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type PrescriptionItemWhereInput = {
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicineId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instruction?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type PrescriptionItemOrderByWithRelationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instruction?: SortOrderInput | SortOrder
    prescription?: PrescriptionOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
  }

  export type PrescriptionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    OR?: PrescriptionItemWhereInput[]
    NOT?: PrescriptionItemWhereInput | PrescriptionItemWhereInput[]
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicineId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instruction?: StringNullableFilter<"PrescriptionItem"> | string | null
    prescription?: XOR<PrescriptionScalarRelationFilter, PrescriptionWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id">

  export type PrescriptionItemOrderByWithAggregationInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instruction?: SortOrderInput | SortOrder
    _count?: PrescriptionItemCountOrderByAggregateInput
    _max?: PrescriptionItemMaxOrderByAggregateInput
    _min?: PrescriptionItemMinOrderByAggregateInput
  }

  export type PrescriptionItemScalarWhereWithAggregatesInput = {
    AND?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    OR?: PrescriptionItemScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionItemScalarWhereWithAggregatesInput | PrescriptionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    prescriptionId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    medicineId?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    dosage?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    frequency?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    duration?: StringWithAggregatesFilter<"PrescriptionItem"> | string
    instruction?: StringNullableWithAggregatesFilter<"PrescriptionItem"> | string | null
  }

  export type MedicineWhereInput = {
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    id?: StringFilter<"Medicine"> | string
    name?: StringFilter<"Medicine"> | string
    genericName?: StringFilter<"Medicine"> | string
    batchNumber?: StringFilter<"Medicine"> | string
    expiryDate?: DateTimeFilter<"Medicine"> | Date | string
    stockQuantity?: IntFilter<"Medicine"> | number
    reorderLevel?: IntFilter<"Medicine"> | number
    unitPrice?: DecimalFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
  }

  export type MedicineOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
    prescriptionItems?: PrescriptionItemOrderByRelationAggregateInput
    saleItems?: SaleItemOrderByRelationAggregateInput
  }

  export type MedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    name?: StringFilter<"Medicine"> | string
    genericName?: StringFilter<"Medicine"> | string
    batchNumber?: StringFilter<"Medicine"> | string
    expiryDate?: DateTimeFilter<"Medicine"> | Date | string
    stockQuantity?: IntFilter<"Medicine"> | number
    reorderLevel?: IntFilter<"Medicine"> | number
    unitPrice?: DecimalFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemListRelationFilter
    saleItems?: SaleItemListRelationFilter
  }, "id">

  export type MedicineOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
    _count?: MedicineCountOrderByAggregateInput
    _avg?: MedicineAvgOrderByAggregateInput
    _max?: MedicineMaxOrderByAggregateInput
    _min?: MedicineMinOrderByAggregateInput
    _sum?: MedicineSumOrderByAggregateInput
  }

  export type MedicineScalarWhereWithAggregatesInput = {
    AND?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    OR?: MedicineScalarWhereWithAggregatesInput[]
    NOT?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medicine"> | string
    name?: StringWithAggregatesFilter<"Medicine"> | string
    genericName?: StringWithAggregatesFilter<"Medicine"> | string
    batchNumber?: StringWithAggregatesFilter<"Medicine"> | string
    expiryDate?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
    stockQuantity?: IntWithAggregatesFilter<"Medicine"> | number
    reorderLevel?: IntWithAggregatesFilter<"Medicine"> | number
    unitPrice?: DecimalWithAggregatesFilter<"Medicine"> | Decimal | DecimalJsLike | number | string
  }

  export type PharmacySaleWhereInput = {
    AND?: PharmacySaleWhereInput | PharmacySaleWhereInput[]
    OR?: PharmacySaleWhereInput[]
    NOT?: PharmacySaleWhereInput | PharmacySaleWhereInput[]
    id?: StringFilter<"PharmacySale"> | string
    patientId?: StringFilter<"PharmacySale"> | string
    prescriptionId?: StringNullableFilter<"PharmacySale"> | string | null
    saleDate?: DateTimeFilter<"PharmacySale"> | Date | string
    totalAmount?: DecimalFilter<"PharmacySale"> | Decimal | DecimalJsLike | number | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
    items?: SaleItemListRelationFilter
  }

  export type PharmacySaleOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    patient?: PatientOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    items?: SaleItemOrderByRelationAggregateInput
  }

  export type PharmacySaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PharmacySaleWhereInput | PharmacySaleWhereInput[]
    OR?: PharmacySaleWhereInput[]
    NOT?: PharmacySaleWhereInput | PharmacySaleWhereInput[]
    patientId?: StringFilter<"PharmacySale"> | string
    prescriptionId?: StringNullableFilter<"PharmacySale"> | string | null
    saleDate?: DateTimeFilter<"PharmacySale"> | Date | string
    totalAmount?: DecimalFilter<"PharmacySale"> | Decimal | DecimalJsLike | number | string
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    prescription?: XOR<PrescriptionNullableScalarRelationFilter, PrescriptionWhereInput> | null
    items?: SaleItemListRelationFilter
  }, "id">

  export type PharmacySaleOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
    _count?: PharmacySaleCountOrderByAggregateInput
    _avg?: PharmacySaleAvgOrderByAggregateInput
    _max?: PharmacySaleMaxOrderByAggregateInput
    _min?: PharmacySaleMinOrderByAggregateInput
    _sum?: PharmacySaleSumOrderByAggregateInput
  }

  export type PharmacySaleScalarWhereWithAggregatesInput = {
    AND?: PharmacySaleScalarWhereWithAggregatesInput | PharmacySaleScalarWhereWithAggregatesInput[]
    OR?: PharmacySaleScalarWhereWithAggregatesInput[]
    NOT?: PharmacySaleScalarWhereWithAggregatesInput | PharmacySaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PharmacySale"> | string
    patientId?: StringWithAggregatesFilter<"PharmacySale"> | string
    prescriptionId?: StringNullableWithAggregatesFilter<"PharmacySale"> | string | null
    saleDate?: DateTimeWithAggregatesFilter<"PharmacySale"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"PharmacySale"> | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemWhereInput = {
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    pharmacySaleId?: StringFilter<"SaleItem"> | string
    medicineId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    pharmacySale?: XOR<PharmacySaleScalarRelationFilter, PharmacySaleWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }

  export type SaleItemOrderByWithRelationInput = {
    id?: SortOrder
    pharmacySaleId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    pharmacySale?: PharmacySaleOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
  }

  export type SaleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleItemWhereInput | SaleItemWhereInput[]
    OR?: SaleItemWhereInput[]
    NOT?: SaleItemWhereInput | SaleItemWhereInput[]
    pharmacySaleId?: StringFilter<"SaleItem"> | string
    medicineId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    pharmacySale?: XOR<PharmacySaleScalarRelationFilter, PharmacySaleWhereInput>
    medicine?: XOR<MedicineScalarRelationFilter, MedicineWhereInput>
  }, "id">

  export type SaleItemOrderByWithAggregationInput = {
    id?: SortOrder
    pharmacySaleId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
    _count?: SaleItemCountOrderByAggregateInput
    _avg?: SaleItemAvgOrderByAggregateInput
    _max?: SaleItemMaxOrderByAggregateInput
    _min?: SaleItemMinOrderByAggregateInput
    _sum?: SaleItemSumOrderByAggregateInput
  }

  export type SaleItemScalarWhereWithAggregatesInput = {
    AND?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    OR?: SaleItemScalarWhereWithAggregatesInput[]
    NOT?: SaleItemScalarWhereWithAggregatesInput | SaleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SaleItem"> | string
    pharmacySaleId?: StringWithAggregatesFilter<"SaleItem"> | string
    medicineId?: StringWithAggregatesFilter<"SaleItem"> | string
    quantity?: IntWithAggregatesFilter<"SaleItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalWithAggregatesFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    admissionId?: StringNullableFilter<"Invoice"> | string | null
    visitId?: StringNullableFilter<"Invoice"> | string | null
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    items?: InvoiceItemListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionId?: SortOrderInput | SortOrder
    visitId?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    patient?: PatientOrderByWithRelationInput
    admission?: AdmissionOrderByWithRelationInput
    visit?: OpdVisitOrderByWithRelationInput
    items?: InvoiceItemOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    patientId?: StringFilter<"Invoice"> | string
    admissionId?: StringNullableFilter<"Invoice"> | string | null
    visitId?: StringNullableFilter<"Invoice"> | string | null
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    patient?: XOR<PatientScalarRelationFilter, PatientWhereInput>
    admission?: XOR<AdmissionNullableScalarRelationFilter, AdmissionWhereInput> | null
    visit?: XOR<OpdVisitNullableScalarRelationFilter, OpdVisitWhereInput> | null
    items?: InvoiceItemListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionId?: SortOrderInput | SortOrder
    visitId?: SortOrderInput | SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    patientId?: StringWithAggregatesFilter<"Invoice"> | string
    admissionId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    visitId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    totalAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
  }

  export type InvoiceItemWhereInput = {
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    serviceId?: StringFilter<"InvoiceItem"> | string
    serviceOrderId?: StringNullableFilter<"InvoiceItem"> | string | null
    itemName?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    serviceOrder?: XOR<ServiceOrderNullableScalarRelationFilter, ServiceOrderWhereInput> | null
  }

  export type InvoiceItemOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    serviceOrderId?: SortOrderInput | SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    serviceOrder?: ServiceOrderOrderByWithRelationInput
  }

  export type InvoiceItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    OR?: InvoiceItemWhereInput[]
    NOT?: InvoiceItemWhereInput | InvoiceItemWhereInput[]
    invoiceId?: StringFilter<"InvoiceItem"> | string
    serviceId?: StringFilter<"InvoiceItem"> | string
    serviceOrderId?: StringNullableFilter<"InvoiceItem"> | string | null
    itemName?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    serviceOrder?: XOR<ServiceOrderNullableScalarRelationFilter, ServiceOrderWhereInput> | null
  }, "id">

  export type InvoiceItemOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    serviceOrderId?: SortOrderInput | SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    _count?: InvoiceItemCountOrderByAggregateInput
    _avg?: InvoiceItemAvgOrderByAggregateInput
    _max?: InvoiceItemMaxOrderByAggregateInput
    _min?: InvoiceItemMinOrderByAggregateInput
    _sum?: InvoiceItemSumOrderByAggregateInput
  }

  export type InvoiceItemScalarWhereWithAggregatesInput = {
    AND?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    OR?: InvoiceItemScalarWhereWithAggregatesInput[]
    NOT?: InvoiceItemScalarWhereWithAggregatesInput | InvoiceItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceItem"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    serviceId?: StringWithAggregatesFilter<"InvoiceItem"> | string
    serviceOrderId?: StringNullableWithAggregatesFilter<"InvoiceItem"> | string | null
    itemName?: StringWithAggregatesFilter<"InvoiceItem"> | string
    quantity?: IntWithAggregatesFilter<"InvoiceItem"> | number
    unitPrice?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalWithAggregatesFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type InsuranceClaimWhereInput = {
    AND?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    OR?: InsuranceClaimWhereInput[]
    NOT?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    id?: StringFilter<"InsuranceClaim"> | string
    admissionId?: StringFilter<"InsuranceClaim"> | string
    providerName?: StringFilter<"InsuranceClaim"> | string
    policyNumber?: StringFilter<"InsuranceClaim"> | string
    claimAmount?: DecimalFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFilter<"InsuranceClaim"> | $Enums.ClaimStatus
    submissionDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
  }

  export type InsuranceClaimOrderByWithRelationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    providerName?: SortOrder
    policyNumber?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    submissionDate?: SortOrder
    admission?: AdmissionOrderByWithRelationInput
  }

  export type InsuranceClaimWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    OR?: InsuranceClaimWhereInput[]
    NOT?: InsuranceClaimWhereInput | InsuranceClaimWhereInput[]
    admissionId?: StringFilter<"InsuranceClaim"> | string
    providerName?: StringFilter<"InsuranceClaim"> | string
    policyNumber?: StringFilter<"InsuranceClaim"> | string
    claimAmount?: DecimalFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFilter<"InsuranceClaim"> | $Enums.ClaimStatus
    submissionDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
    admission?: XOR<AdmissionScalarRelationFilter, AdmissionWhereInput>
  }, "id">

  export type InsuranceClaimOrderByWithAggregationInput = {
    id?: SortOrder
    admissionId?: SortOrder
    providerName?: SortOrder
    policyNumber?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrderInput | SortOrder
    status?: SortOrder
    submissionDate?: SortOrder
    _count?: InsuranceClaimCountOrderByAggregateInput
    _avg?: InsuranceClaimAvgOrderByAggregateInput
    _max?: InsuranceClaimMaxOrderByAggregateInput
    _min?: InsuranceClaimMinOrderByAggregateInput
    _sum?: InsuranceClaimSumOrderByAggregateInput
  }

  export type InsuranceClaimScalarWhereWithAggregatesInput = {
    AND?: InsuranceClaimScalarWhereWithAggregatesInput | InsuranceClaimScalarWhereWithAggregatesInput[]
    OR?: InsuranceClaimScalarWhereWithAggregatesInput[]
    NOT?: InsuranceClaimScalarWhereWithAggregatesInput | InsuranceClaimScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    admissionId?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    providerName?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    policyNumber?: StringWithAggregatesFilter<"InsuranceClaim"> | string
    claimAmount?: DecimalWithAggregatesFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableWithAggregatesFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusWithAggregatesFilter<"InsuranceClaim"> | $Enums.ClaimStatus
    submissionDate?: DateTimeWithAggregatesFilter<"InsuranceClaim"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
    labResults?: LabResultCreateNestedManyWithoutTechnicianInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
    labResults?: LabResultUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
    labResults?: LabResultUpdateManyWithoutTechnicianNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
    labResults?: LabResultUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffProfileCreateInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileCreateManyInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
  }

  export type StaffProfileUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StaffProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    department: DepartmentCreateNestedOneWithoutServicesInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    departmentId: string
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: StringFieldUpdateOperationsInput | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    departmentId: string
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: StringFieldUpdateOperationsInput | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardCreateInput = {
    id?: string
    name: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
    department: DepartmentCreateNestedOneWithoutWardsInput
    beds?: BedCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateInput = {
    id?: string
    name: string
    departmentId: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
    beds?: BedUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    department?: DepartmentUpdateOneRequiredWithoutWardsNestedInput
    beds?: BedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beds?: BedUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardCreateManyInput = {
    id?: string
    name: string
    departmentId: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
  }

  export type WardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type WardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BedCreateInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
    ward: WardCreateNestedOneWithoutBedsInput
    transfers?: BedTransferCreateNestedManyWithoutBedInput
    activeAdmissions?: AdmissionCreateNestedManyWithoutCurrentBedInput
  }

  export type BedUncheckedCreateInput = {
    id?: string
    wardId: string
    bedNumber: string
    status: $Enums.BedStatus
    transfers?: BedTransferUncheckedCreateNestedManyWithoutBedInput
    activeAdmissions?: AdmissionUncheckedCreateNestedManyWithoutCurrentBedInput
  }

  export type BedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    transfers?: BedTransferUpdateManyWithoutBedNestedInput
    activeAdmissions?: AdmissionUpdateManyWithoutCurrentBedNestedInput
  }

  export type BedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    transfers?: BedTransferUncheckedUpdateManyWithoutBedNestedInput
    activeAdmissions?: AdmissionUncheckedUpdateManyWithoutCurrentBedNestedInput
  }

  export type BedCreateManyInput = {
    id?: string
    wardId: string
    bedNumber: string
    status: $Enums.BedStatus
  }

  export type BedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
  }

  export type BedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
  }

  export type PatientCreateInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalHistoryCreateInput = {
    id?: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
    patient: PatientCreateNestedOneWithoutMedicalHistoryInput
  }

  export type MedicalHistoryUncheckedCreateInput = {
    id?: string
    patientId: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
  }

  export type MedicalHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutMedicalHistoryNestedInput
  }

  export type MedicalHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalHistoryCreateManyInput = {
    id?: string
    patientId: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
  }

  export type MedicalHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientDocumentCreateInput = {
    id?: string
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    visit?: OpdVisitCreateNestedOneWithoutDocumentsInput
    admission?: AdmissionCreateNestedOneWithoutDocumentsInput
  }

  export type PatientDocumentUncheckedCreateInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type PatientDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    visit?: OpdVisitUpdateOneWithoutDocumentsNestedInput
    admission?: AdmissionUpdateOneWithoutDocumentsNestedInput
  }

  export type PatientDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentCreateManyInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type PatientDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: StaffProfileCreateNestedOneWithoutAppointmentsInput
    department: DepartmentCreateNestedOneWithoutAppointmentsInput
    opdVisit?: OpdVisitCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAppointmentsNestedInput
    opdVisit?: OpdVisitUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type OpdVisitCreateInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitCreateManyInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
  }

  export type OpdVisitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpdVisitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdmissionCreateInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionCreateManyInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
  }

  export type AdmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BedTransferCreateInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
    admission: AdmissionCreateNestedOneWithoutBedTransfersInput
    bed: BedCreateNestedOneWithoutTransfersInput
  }

  export type BedTransferUncheckedCreateInput = {
    id?: string
    admissionId: string
    bedId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type BedTransferUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutBedTransfersNestedInput
    bed?: BedUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type BedTransferUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    bedId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedTransferCreateManyInput = {
    id?: string
    admissionId: string
    bedId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type BedTransferUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedTransferUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    bedId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurgeryCreateInput = {
    id?: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    admission: AdmissionCreateNestedOneWithoutSurgeriesInput
    surgeon: StaffProfileCreateNestedOneWithoutSurgeriesInput
    checklists?: SurgicalChecklistCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUncheckedCreateInput = {
    id?: string
    admissionId: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    checklists?: SurgicalChecklistUncheckedCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutSurgeriesNestedInput
    surgeon?: StaffProfileUpdateOneRequiredWithoutSurgeriesNestedInput
    checklists?: SurgicalChecklistUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checklists?: SurgicalChecklistUncheckedUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryCreateManyInput = {
    id?: string
    admissionId: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
  }

  export type SurgeryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurgeryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurgerySStaffCreateInput = {
    role: string
    surgery: SurgeryCreateNestedOneWithoutSurgerySStaffsInput
    staff: StaffProfileCreateNestedOneWithoutSurgerySStaffsInput
  }

  export type SurgerySStaffUncheckedCreateInput = {
    surgeryId: string
    staffId: string
    role: string
  }

  export type SurgerySStaffUpdateInput = {
    role?: StringFieldUpdateOperationsInput | string
    surgery?: SurgeryUpdateOneRequiredWithoutSurgerySStaffsNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutSurgerySStaffsNestedInput
  }

  export type SurgerySStaffUncheckedUpdateInput = {
    surgeryId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SurgerySStaffCreateManyInput = {
    surgeryId: string
    staffId: string
    role: string
  }

  export type SurgerySStaffUpdateManyMutationInput = {
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SurgerySStaffUncheckedUpdateManyInput = {
    surgeryId?: StringFieldUpdateOperationsInput | string
    staffId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SurgicalChecklistCreateInput = {
    id?: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
    surgery: SurgeryCreateNestedOneWithoutChecklistsInput
  }

  export type SurgicalChecklistUncheckedCreateInput = {
    id?: string
    surgeryId: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
  }

  export type SurgicalChecklistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    surgery?: SurgeryUpdateOneRequiredWithoutChecklistsNestedInput
  }

  export type SurgicalChecklistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surgeryId?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgicalChecklistCreateManyInput = {
    id?: string
    surgeryId: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
  }

  export type SurgicalChecklistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgicalChecklistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    surgeryId?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicalNoteCreateInput = {
    id?: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
    patient: PatientCreateNestedOneWithoutClinicalNotesInput
    visit?: OpdVisitCreateNestedOneWithoutClinicalNotesInput
    admission?: AdmissionCreateNestedOneWithoutClinicalNotesInput
    doctor: StaffProfileCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutClinicalNotesNestedInput
    visit?: OpdVisitUpdateOneWithoutClinicalNotesNestedInput
    admission?: AdmissionUpdateOneWithoutClinicalNotesNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteCreateManyInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderCreateInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type ServiceOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultCreateInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    resultDate?: Date | string
    serviceOrder: ServiceOrderCreateNestedOneWithoutLabResultsInput
    technician?: UserCreateNestedOneWithoutLabResultsInput
    verifiedBy?: StaffProfileCreateNestedOneWithoutVerifiedResultsInput
  }

  export type LabResultUncheckedCreateInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type LabResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceOrder?: ServiceOrderUpdateOneRequiredWithoutLabResultsNestedInput
    technician?: UserUpdateOneWithoutLabResultsNestedInput
    verifiedBy?: StaffProfileUpdateOneWithoutVerifiedResultsNestedInput
  }

  export type LabResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultCreateManyInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type LabResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionItemCreateInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
    prescription: PrescriptionCreateNestedOneWithoutItemsInput
    medicine: MedicineCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateInput = {
    id?: string
    prescriptionId: string
    medicineId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type PrescriptionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUpdateOneRequiredWithoutItemsNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemCreateManyInput = {
    id?: string
    prescriptionId: string
    medicineId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type PrescriptionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicineCreateInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutMedicineInput
    saleItems?: SaleItemCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutMedicineInput
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUpdateManyWithoutMedicineNestedInput
    saleItems?: SaleItemUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutMedicineNestedInput
    saleItems?: SaleItemUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineCreateManyInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
  }

  export type MedicineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MedicineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PharmacySaleCreateInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    patient: PatientCreateNestedOneWithoutPharmacySalesInput
    prescription?: PrescriptionCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleUncheckedCreateInput = {
    id?: string
    patientId: string
    prescriptionId?: string | null
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneRequiredWithoutPharmacySalesNestedInput
    prescription?: PrescriptionUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleCreateManyInput = {
    id?: string
    patientId: string
    prescriptionId?: string | null
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
  }

  export type PharmacySaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PharmacySaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pharmacySale: PharmacySaleCreateNestedOneWithoutItemsInput
    medicine: MedicineCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateInput = {
    id?: string
    pharmacySaleId: string
    medicineId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pharmacySale?: PharmacySaleUpdateOneRequiredWithoutItemsNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pharmacySaleId?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateManyInput = {
    id?: string
    pharmacySaleId: string
    medicineId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pharmacySaleId?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    patient: PatientCreateNestedOneWithoutInvoicesInput
    admission?: AdmissionCreateNestedOneWithoutInvoicesInput
    visit?: OpdVisitCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    admission?: AdmissionUpdateOneWithoutInvoicesNestedInput
    visit?: OpdVisitUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type InvoiceItemCreateInput = {
    id?: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service: ServiceCreateNestedOneWithoutInvoiceItemsInput
    serviceOrder?: ServiceOrderCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateInput = {
    id?: string
    invoiceId: string
    serviceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
    serviceOrder?: ServiceOrderUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateManyInput = {
    id?: string
    invoiceId: string
    serviceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InsuranceClaimCreateInput = {
    id?: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
    admission: AdmissionCreateNestedOneWithoutInsuranceClaimsInput
  }

  export type InsuranceClaimUncheckedCreateInput = {
    id?: string
    admissionId: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
  }

  export type InsuranceClaimUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    admission?: AdmissionUpdateOneRequiredWithoutInsuranceClaimsNestedInput
  }

  export type InsuranceClaimUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimCreateManyInput = {
    id?: string
    admissionId: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
  }

  export type InsuranceClaimUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StaffProfileNullableScalarRelationFilter = {
    is?: StaffProfileWhereInput | null
    isNot?: StaffProfileWhereInput | null
  }

  export type LabResultListRelationFilter = {
    every?: LabResultWhereInput
    some?: LabResultWhereInput
    none?: LabResultWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type LabResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type OpdVisitListRelationFilter = {
    every?: OpdVisitWhereInput
    some?: OpdVisitWhereInput
    none?: OpdVisitWhereInput
  }

  export type AdmissionListRelationFilter = {
    every?: AdmissionWhereInput
    some?: AdmissionWhereInput
    none?: AdmissionWhereInput
  }

  export type SurgeryListRelationFilter = {
    every?: SurgeryWhereInput
    some?: SurgeryWhereInput
    none?: SurgeryWhereInput
  }

  export type ClinicalNoteListRelationFilter = {
    every?: ClinicalNoteWhereInput
    some?: ClinicalNoteWhereInput
    none?: ClinicalNoteWhereInput
  }

  export type ServiceOrderListRelationFilter = {
    every?: ServiceOrderWhereInput
    some?: ServiceOrderWhereInput
    none?: ServiceOrderWhereInput
  }

  export type PrescriptionListRelationFilter = {
    every?: PrescriptionWhereInput
    some?: PrescriptionWhereInput
    none?: PrescriptionWhereInput
  }

  export type SurgerySStaffListRelationFilter = {
    every?: SurgerySStaffWhereInput
    some?: SurgerySStaffWhereInput
    none?: SurgerySStaffWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpdVisitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurgeryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicalNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurgerySStaffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffProfileCountOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    fullName?: SortOrder
    qualification?: SortOrder
    registrationNumber?: SortOrder
    contactNumber?: SortOrder
    shiftTiming?: SortOrder
  }

  export type StaffProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    fullName?: SortOrder
    qualification?: SortOrder
    registrationNumber?: SortOrder
    contactNumber?: SortOrder
    shiftTiming?: SortOrder
  }

  export type StaffProfileMinOrderByAggregateInput = {
    id?: SortOrder
    departmentId?: SortOrder
    fullName?: SortOrder
    qualification?: SortOrder
    registrationNumber?: SortOrder
    contactNumber?: SortOrder
    shiftTiming?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumDepartmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DepartmentType | EnumDepartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentTypeFilter<$PrismaModel> | $Enums.DepartmentType
  }

  export type StaffProfileListRelationFilter = {
    every?: StaffProfileWhereInput
    some?: StaffProfileWhereInput
    none?: StaffProfileWhereInput
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type WardListRelationFilter = {
    every?: WardWhereInput
    some?: WardWhereInput
    none?: WardWhereInput
  }

  export type StaffProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    headDoctorId?: SortOrder
    type?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    headDoctorId?: SortOrder
    type?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    headDoctorId?: SortOrder
    type?: SortOrder
  }

  export type EnumDepartmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepartmentType | EnumDepartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DepartmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepartmentTypeFilter<$PrismaModel>
    _max?: NestedEnumDepartmentTypeFilter<$PrismaModel>
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type InvoiceItemListRelationFilter = {
    every?: InvoiceItemWhereInput
    some?: InvoiceItemWhereInput
    none?: InvoiceItemWhereInput
  }

  export type InvoiceItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    basePrice?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    basePrice?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    departmentId?: SortOrder
    basePrice?: SortOrder
    code?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    basePrice?: SortOrder
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BedListRelationFilter = {
    every?: BedWhereInput
    some?: BedWhereInput
    none?: BedWhereInput
  }

  export type BedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WardCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    floorNumber?: SortOrder
    type?: SortOrder
    basePricePerDay?: SortOrder
  }

  export type WardAvgOrderByAggregateInput = {
    floorNumber?: SortOrder
    basePricePerDay?: SortOrder
  }

  export type WardMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    floorNumber?: SortOrder
    type?: SortOrder
    basePricePerDay?: SortOrder
  }

  export type WardMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    departmentId?: SortOrder
    floorNumber?: SortOrder
    type?: SortOrder
    basePricePerDay?: SortOrder
  }

  export type WardSumOrderByAggregateInput = {
    floorNumber?: SortOrder
    basePricePerDay?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumBedStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BedStatus | EnumBedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStatusFilter<$PrismaModel> | $Enums.BedStatus
  }

  export type WardScalarRelationFilter = {
    is?: WardWhereInput
    isNot?: WardWhereInput
  }

  export type BedTransferListRelationFilter = {
    every?: BedTransferWhereInput
    some?: BedTransferWhereInput
    none?: BedTransferWhereInput
  }

  export type BedTransferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BedCountOrderByAggregateInput = {
    id?: SortOrder
    wardId?: SortOrder
    bedNumber?: SortOrder
    status?: SortOrder
  }

  export type BedMaxOrderByAggregateInput = {
    id?: SortOrder
    wardId?: SortOrder
    bedNumber?: SortOrder
    status?: SortOrder
  }

  export type BedMinOrderByAggregateInput = {
    id?: SortOrder
    wardId?: SortOrder
    bedNumber?: SortOrder
    status?: SortOrder
  }

  export type EnumBedStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedStatus | EnumBedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStatusWithAggregatesFilter<$PrismaModel> | $Enums.BedStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStatusFilter<$PrismaModel>
    _max?: NestedEnumBedStatusFilter<$PrismaModel>
  }

  export type MedicalHistoryListRelationFilter = {
    every?: MedicalHistoryWhereInput
    some?: MedicalHistoryWhereInput
    none?: MedicalHistoryWhereInput
  }

  export type PatientDocumentListRelationFilter = {
    every?: PatientDocumentWhereInput
    some?: PatientDocumentWhereInput
    none?: PatientDocumentWhereInput
  }

  export type PharmacySaleListRelationFilter = {
    every?: PharmacySaleWhereInput
    some?: PharmacySaleWhereInput
    none?: PharmacySaleWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type MedicalHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PharmacySaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    uhid?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    preferredLanguage?: SortOrder
    permanentAddress?: SortOrder
    currentAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    abhaId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    defaultPayerType?: SortOrder
    insuranceProvider?: SortOrder
    policyNumber?: SortOrder
    isDeceased?: SortOrder
    registrationDate?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    uhid?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    preferredLanguage?: SortOrder
    permanentAddress?: SortOrder
    currentAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    abhaId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    defaultPayerType?: SortOrder
    insuranceProvider?: SortOrder
    policyNumber?: SortOrder
    isDeceased?: SortOrder
    registrationDate?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    uhid?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    dob?: SortOrder
    gender?: SortOrder
    maritalStatus?: SortOrder
    nationality?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    preferredLanguage?: SortOrder
    permanentAddress?: SortOrder
    currentAddress?: SortOrder
    city?: SortOrder
    state?: SortOrder
    pincode?: SortOrder
    idProofType?: SortOrder
    idProofNumber?: SortOrder
    abhaId?: SortOrder
    emergencyContactName?: SortOrder
    emergencyContactPhone?: SortOrder
    emergencyContactRelation?: SortOrder
    defaultPayerType?: SortOrder
    insuranceProvider?: SortOrder
    policyNumber?: SortOrder
    isDeceased?: SortOrder
    registrationDate?: SortOrder
  }

  export type PatientScalarRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type MedicalHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    category?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    notes?: SortOrder
  }

  export type MedicalHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    category?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    notes?: SortOrder
  }

  export type MedicalHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    category?: SortOrder
    name?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    diagnosedDate?: SortOrder
    notes?: SortOrder
  }

  export type OpdVisitNullableScalarRelationFilter = {
    is?: OpdVisitWhereInput | null
    isNot?: OpdVisitWhereInput | null
  }

  export type AdmissionNullableScalarRelationFilter = {
    is?: AdmissionWhereInput | null
    isNot?: AdmissionWhereInput | null
  }

  export type PatientDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type PatientDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type PatientDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    category?: SortOrder
    fileUrl?: SortOrder
    uploadedBy?: SortOrder
    uploadedAt?: SortOrder
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type EnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type StaffProfileScalarRelationFilter = {
    is?: StaffProfileWhereInput
    isNot?: StaffProfileWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    appointmentDate?: SortOrder
    tokenNumber?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    tokenNumber?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    appointmentDate?: SortOrder
    tokenNumber?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    departmentId?: SortOrder
    appointmentDate?: SortOrder
    tokenNumber?: SortOrder
    status?: SortOrder
    type?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    tokenNumber?: SortOrder
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type EnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type EnumVisitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeFilter<$PrismaModel> | $Enums.VisitType
  }

  export type EnumTriageColorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriageColor | EnumTriageColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriageColorNullableFilter<$PrismaModel> | $Enums.TriageColor | null
  }

  export type EnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type AppointmentNullableScalarRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type OpdVisitCountOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    triageColor?: SortOrder
    status?: SortOrder
    isMedicoLegal?: SortOrder
  }

  export type OpdVisitMaxOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    triageColor?: SortOrder
    status?: SortOrder
    isMedicoLegal?: SortOrder
  }

  export type OpdVisitMinOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitDate?: SortOrder
    visitType?: SortOrder
    triageColor?: SortOrder
    status?: SortOrder
    isMedicoLegal?: SortOrder
  }

  export type EnumVisitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitTypeFilter<$PrismaModel>
  }

  export type EnumTriageColorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriageColor | EnumTriageColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriageColorNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriageColor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriageColorNullableFilter<$PrismaModel>
    _max?: NestedEnumTriageColorNullableFilter<$PrismaModel>
  }

  export type EnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type EnumAdmissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionType | EnumAdmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionTypeFilter<$PrismaModel> | $Enums.AdmissionType
  }

  export type EnumAdmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusFilter<$PrismaModel> | $Enums.AdmissionStatus
  }

  export type EnumDischargeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DischargeType | EnumDischargeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDischargeTypeNullableFilter<$PrismaModel> | $Enums.DischargeType | null
  }

  export type BedNullableScalarRelationFilter = {
    is?: BedWhereInput | null
    isNot?: BedWhereInput | null
  }

  export type InsuranceClaimListRelationFilter = {
    every?: InsuranceClaimWhereInput
    some?: InsuranceClaimWhereInput
    none?: InsuranceClaimWhereInput
  }

  export type InsuranceClaimOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdmissionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admittingDoctorId?: SortOrder
    departmentId?: SortOrder
    visitId?: SortOrder
    currentBedId?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    reasonForAdmission?: SortOrder
    admissionType?: SortOrder
    status?: SortOrder
    dischargeType?: SortOrder
    mlc?: SortOrder
  }

  export type AdmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admittingDoctorId?: SortOrder
    departmentId?: SortOrder
    visitId?: SortOrder
    currentBedId?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    reasonForAdmission?: SortOrder
    admissionType?: SortOrder
    status?: SortOrder
    dischargeType?: SortOrder
    mlc?: SortOrder
  }

  export type AdmissionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admittingDoctorId?: SortOrder
    departmentId?: SortOrder
    visitId?: SortOrder
    currentBedId?: SortOrder
    admissionDate?: SortOrder
    dischargeDate?: SortOrder
    reasonForAdmission?: SortOrder
    admissionType?: SortOrder
    status?: SortOrder
    dischargeType?: SortOrder
    mlc?: SortOrder
  }

  export type EnumAdmissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionType | EnumAdmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdmissionTypeFilter<$PrismaModel>
  }

  export type EnumAdmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmissionStatusFilter<$PrismaModel>
  }

  export type EnumDischargeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DischargeType | EnumDischargeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDischargeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DischargeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDischargeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDischargeTypeNullableFilter<$PrismaModel>
  }

  export type AdmissionScalarRelationFilter = {
    is?: AdmissionWhereInput
    isNot?: AdmissionWhereInput
  }

  export type BedScalarRelationFilter = {
    is?: BedWhereInput
    isNot?: BedWhereInput
  }

  export type BedTransferCountOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    bedId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
  }

  export type BedTransferMaxOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    bedId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
  }

  export type BedTransferMinOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    bedId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
  }

  export type EnumSurgeryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SurgeryStatus | EnumSurgeryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurgeryStatusFilter<$PrismaModel> | $Enums.SurgeryStatus
  }

  export type SurgicalChecklistListRelationFilter = {
    every?: SurgicalChecklistWhereInput
    some?: SurgicalChecklistWhereInput
    none?: SurgicalChecklistWhereInput
  }

  export type SurgicalChecklistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SurgeryCountOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    procedureName?: SortOrder
    surgeonId?: SortOrder
    otRoomNumber?: SortOrder
    surgeryDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type SurgeryMaxOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    procedureName?: SortOrder
    surgeonId?: SortOrder
    otRoomNumber?: SortOrder
    surgeryDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type SurgeryMinOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    procedureName?: SortOrder
    surgeonId?: SortOrder
    otRoomNumber?: SortOrder
    surgeryDate?: SortOrder
    status?: SortOrder
    notes?: SortOrder
  }

  export type EnumSurgeryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurgeryStatus | EnumSurgeryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurgeryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SurgeryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurgeryStatusFilter<$PrismaModel>
    _max?: NestedEnumSurgeryStatusFilter<$PrismaModel>
  }

  export type SurgeryScalarRelationFilter = {
    is?: SurgeryWhereInput
    isNot?: SurgeryWhereInput
  }

  export type SurgerySStaffCountOrderByAggregateInput = {
    surgeryId?: SortOrder
    staffId?: SortOrder
    role?: SortOrder
  }

  export type SurgerySStaffMaxOrderByAggregateInput = {
    surgeryId?: SortOrder
    staffId?: SortOrder
    role?: SortOrder
  }

  export type SurgerySStaffMinOrderByAggregateInput = {
    surgeryId?: SortOrder
    staffId?: SortOrder
    role?: SortOrder
  }

  export type EnumChecklistStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistStage | EnumChecklistStageFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistStageFilter<$PrismaModel> | $Enums.ChecklistStage
  }

  export type SurgicalChecklistCountOrderByAggregateInput = {
    id?: SortOrder
    surgeryId?: SortOrder
    stage?: SortOrder
    itemName?: SortOrder
    isChecked?: SortOrder
    checkedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type SurgicalChecklistMaxOrderByAggregateInput = {
    id?: SortOrder
    surgeryId?: SortOrder
    stage?: SortOrder
    itemName?: SortOrder
    isChecked?: SortOrder
    checkedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type SurgicalChecklistMinOrderByAggregateInput = {
    id?: SortOrder
    surgeryId?: SortOrder
    stage?: SortOrder
    itemName?: SortOrder
    isChecked?: SortOrder
    checkedBy?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumChecklistStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistStage | EnumChecklistStageFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistStageWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistStageFilter<$PrismaModel>
    _max?: NestedEnumChecklistStageFilter<$PrismaModel>
  }

  export type EnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ClinicalNoteCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    doctorId?: SortOrder
    noteType?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    isFinalized?: SortOrder
  }

  export type ClinicalNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    doctorId?: SortOrder
    noteType?: SortOrder
    createdAt?: SortOrder
    isFinalized?: SortOrder
  }

  export type ClinicalNoteMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    doctorId?: SortOrder
    noteType?: SortOrder
    createdAt?: SortOrder
    isFinalized?: SortOrder
  }

  export type EnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type EnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type ServiceOrderCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    serviceId?: SortOrder
    orderType?: SortOrder
    priority?: SortOrder
    clinicalIndication?: SortOrder
    isPaid?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
  }

  export type ServiceOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    serviceId?: SortOrder
    orderType?: SortOrder
    priority?: SortOrder
    clinicalIndication?: SortOrder
    isPaid?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
  }

  export type ServiceOrderMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    serviceId?: SortOrder
    orderType?: SortOrder
    priority?: SortOrder
    clinicalIndication?: SortOrder
    isPaid?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
  }

  export type EnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type EnumOrderPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel> | $Enums.OrderPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type ServiceOrderScalarRelationFilter = {
    is?: ServiceOrderWhereInput
    isNot?: ServiceOrderWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LabResultCountOrderByAggregateInput = {
    id?: SortOrder
    serviceOrderId?: SortOrder
    testName?: SortOrder
    resultValue?: SortOrder
    referenceRange?: SortOrder
    unit?: SortOrder
    technicianId?: SortOrder
    verifiedByDoctorId?: SortOrder
    resultDate?: SortOrder
  }

  export type LabResultMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceOrderId?: SortOrder
    testName?: SortOrder
    resultValue?: SortOrder
    referenceRange?: SortOrder
    unit?: SortOrder
    technicianId?: SortOrder
    verifiedByDoctorId?: SortOrder
    resultDate?: SortOrder
  }

  export type LabResultMinOrderByAggregateInput = {
    id?: SortOrder
    serviceOrderId?: SortOrder
    testName?: SortOrder
    resultValue?: SortOrder
    referenceRange?: SortOrder
    unit?: SortOrder
    technicianId?: SortOrder
    verifiedByDoctorId?: SortOrder
    resultDate?: SortOrder
  }

  export type PrescriptionItemListRelationFilter = {
    every?: PrescriptionItemWhereInput
    some?: PrescriptionItemWhereInput
    none?: PrescriptionItemWhereInput
  }

  export type PrescriptionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    isPaid?: SortOrder
    date?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    isPaid?: SortOrder
    date?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    doctorId?: SortOrder
    visitId?: SortOrder
    admissionId?: SortOrder
    isPaid?: SortOrder
    date?: SortOrder
  }

  export type PrescriptionScalarRelationFilter = {
    is?: PrescriptionWhereInput
    isNot?: PrescriptionWhereInput
  }

  export type MedicineScalarRelationFilter = {
    is?: MedicineWhereInput
    isNot?: MedicineWhereInput
  }

  export type PrescriptionItemCountOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instruction?: SortOrder
  }

  export type PrescriptionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instruction?: SortOrder
  }

  export type PrescriptionItemMinOrderByAggregateInput = {
    id?: SortOrder
    prescriptionId?: SortOrder
    medicineId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instruction?: SortOrder
  }

  export type SaleItemListRelationFilter = {
    every?: SaleItemWhereInput
    some?: SaleItemWhereInput
    none?: SaleItemWhereInput
  }

  export type SaleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type MedicineAvgOrderByAggregateInput = {
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type MedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type MedicineMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    genericName?: SortOrder
    batchNumber?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type MedicineSumOrderByAggregateInput = {
    stockQuantity?: SortOrder
    reorderLevel?: SortOrder
    unitPrice?: SortOrder
  }

  export type PrescriptionNullableScalarRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type PharmacySaleCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescriptionId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
  }

  export type PharmacySaleAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PharmacySaleMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescriptionId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
  }

  export type PharmacySaleMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    prescriptionId?: SortOrder
    saleDate?: SortOrder
    totalAmount?: SortOrder
  }

  export type PharmacySaleSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type PharmacySaleScalarRelationFilter = {
    is?: PharmacySaleWhereInput
    isNot?: PharmacySaleWhereInput
  }

  export type SaleItemCountOrderByAggregateInput = {
    id?: SortOrder
    pharmacySaleId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    pharmacySaleId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemMinOrderByAggregateInput = {
    id?: SortOrder
    pharmacySaleId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type SaleItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    totalPrice?: SortOrder
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionId?: SortOrder
    visitId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionId?: SortOrder
    visitId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    admissionId?: SortOrder
    visitId?: SortOrder
    invoiceDate?: SortOrder
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    taxAmount?: SortOrder
    discountAmount?: SortOrder
    netAmount?: SortOrder
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type ServiceOrderNullableScalarRelationFilter = {
    is?: ServiceOrderWhereInput | null
    isNot?: ServiceOrderWhereInput | null
  }

  export type InvoiceItemCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    serviceOrderId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    serviceOrderId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    serviceId?: SortOrder
    serviceOrderId?: SortOrder
    itemName?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type InvoiceItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type InsuranceClaimCountOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    providerName?: SortOrder
    policyNumber?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    status?: SortOrder
    submissionDate?: SortOrder
  }

  export type InsuranceClaimAvgOrderByAggregateInput = {
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type InsuranceClaimMaxOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    providerName?: SortOrder
    policyNumber?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    status?: SortOrder
    submissionDate?: SortOrder
  }

  export type InsuranceClaimMinOrderByAggregateInput = {
    id?: SortOrder
    admissionId?: SortOrder
    providerName?: SortOrder
    policyNumber?: SortOrder
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
    status?: SortOrder
    submissionDate?: SortOrder
  }

  export type InsuranceClaimSumOrderByAggregateInput = {
    claimAmount?: SortOrder
    approvedAmount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type StaffProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type LabResultCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput> | LabResultCreateWithoutTechnicianInput[] | LabResultUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutTechnicianInput | LabResultCreateOrConnectWithoutTechnicianInput[]
    createMany?: LabResultCreateManyTechnicianInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type StaffProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type LabResultUncheckedCreateNestedManyWithoutTechnicianInput = {
    create?: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput> | LabResultCreateWithoutTechnicianInput[] | LabResultUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutTechnicianInput | LabResultCreateOrConnectWithoutTechnicianInput[]
    createMany?: LabResultCreateManyTechnicianInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StaffProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type LabResultUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput> | LabResultCreateWithoutTechnicianInput[] | LabResultUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutTechnicianInput | LabResultCreateOrConnectWithoutTechnicianInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutTechnicianInput | LabResultUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: LabResultCreateManyTechnicianInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutTechnicianInput | LabResultUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutTechnicianInput | LabResultUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type StaffProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type LabResultUncheckedUpdateManyWithoutTechnicianNestedInput = {
    create?: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput> | LabResultCreateWithoutTechnicianInput[] | LabResultUncheckedCreateWithoutTechnicianInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutTechnicianInput | LabResultCreateOrConnectWithoutTechnicianInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutTechnicianInput | LabResultUpsertWithWhereUniqueWithoutTechnicianInput[]
    createMany?: LabResultCreateManyTechnicianInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutTechnicianInput | LabResultUpdateWithWhereUniqueWithoutTechnicianInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutTechnicianInput | LabResultUpdateManyWithWhereWithoutTechnicianInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStaffProfileInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutStaffInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutHeadDoctorInput = {
    create?: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput> | DepartmentCreateWithoutHeadDoctorInput[] | DepartmentUncheckedCreateWithoutHeadDoctorInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadDoctorInput | DepartmentCreateOrConnectWithoutHeadDoctorInput[]
    createMany?: DepartmentCreateManyHeadDoctorInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OpdVisitCreateNestedManyWithoutDoctorInput = {
    create?: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput> | OpdVisitCreateWithoutDoctorInput[] | OpdVisitUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDoctorInput | OpdVisitCreateOrConnectWithoutDoctorInput[]
    createMany?: OpdVisitCreateManyDoctorInputEnvelope
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutAdmittingDoctorInput = {
    create?: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput> | AdmissionCreateWithoutAdmittingDoctorInput[] | AdmissionUncheckedCreateWithoutAdmittingDoctorInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutAdmittingDoctorInput | AdmissionCreateOrConnectWithoutAdmittingDoctorInput[]
    createMany?: AdmissionCreateManyAdmittingDoctorInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type SurgeryCreateNestedManyWithoutSurgeonInput = {
    create?: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput> | SurgeryCreateWithoutSurgeonInput[] | SurgeryUncheckedCreateWithoutSurgeonInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgeonInput | SurgeryCreateOrConnectWithoutSurgeonInput[]
    createMany?: SurgeryCreateManySurgeonInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput> | ClinicalNoteCreateWithoutDoctorInput[] | ClinicalNoteUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutDoctorInput | ClinicalNoteCreateOrConnectWithoutDoctorInput[]
    createMany?: ClinicalNoteCreateManyDoctorInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput> | ServiceOrderCreateWithoutDoctorInput[] | ServiceOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutDoctorInput | ServiceOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: ServiceOrderCreateManyDoctorInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type LabResultCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput> | LabResultCreateWithoutVerifiedByInput[] | LabResultUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutVerifiedByInput | LabResultCreateOrConnectWithoutVerifiedByInput[]
    createMany?: LabResultCreateManyVerifiedByInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type SurgerySStaffCreateNestedManyWithoutStaffInput = {
    create?: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput> | SurgerySStaffCreateWithoutStaffInput[] | SurgerySStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutStaffInput | SurgerySStaffCreateOrConnectWithoutStaffInput[]
    createMany?: SurgerySStaffCreateManyStaffInputEnvelope
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput = {
    create?: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput> | DepartmentCreateWithoutHeadDoctorInput[] | DepartmentUncheckedCreateWithoutHeadDoctorInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadDoctorInput | DepartmentCreateOrConnectWithoutHeadDoctorInput[]
    createMany?: DepartmentCreateManyHeadDoctorInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OpdVisitUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput> | OpdVisitCreateWithoutDoctorInput[] | OpdVisitUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDoctorInput | OpdVisitCreateOrConnectWithoutDoctorInput[]
    createMany?: OpdVisitCreateManyDoctorInputEnvelope
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput = {
    create?: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput> | AdmissionCreateWithoutAdmittingDoctorInput[] | AdmissionUncheckedCreateWithoutAdmittingDoctorInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutAdmittingDoctorInput | AdmissionCreateOrConnectWithoutAdmittingDoctorInput[]
    createMany?: AdmissionCreateManyAdmittingDoctorInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type SurgeryUncheckedCreateNestedManyWithoutSurgeonInput = {
    create?: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput> | SurgeryCreateWithoutSurgeonInput[] | SurgeryUncheckedCreateWithoutSurgeonInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgeonInput | SurgeryCreateOrConnectWithoutSurgeonInput[]
    createMany?: SurgeryCreateManySurgeonInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput> | ClinicalNoteCreateWithoutDoctorInput[] | ClinicalNoteUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutDoctorInput | ClinicalNoteCreateOrConnectWithoutDoctorInput[]
    createMany?: ClinicalNoteCreateManyDoctorInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput> | ServiceOrderCreateWithoutDoctorInput[] | ServiceOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutDoctorInput | ServiceOrderCreateOrConnectWithoutDoctorInput[]
    createMany?: ServiceOrderCreateManyDoctorInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type LabResultUncheckedCreateNestedManyWithoutVerifiedByInput = {
    create?: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput> | LabResultCreateWithoutVerifiedByInput[] | LabResultUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutVerifiedByInput | LabResultCreateOrConnectWithoutVerifiedByInput[]
    createMany?: LabResultCreateManyVerifiedByInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput> | SurgerySStaffCreateWithoutStaffInput[] | SurgerySStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutStaffInput | SurgerySStaffCreateOrConnectWithoutStaffInput[]
    createMany?: SurgerySStaffCreateManyStaffInputEnvelope
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutStaffProfileNestedInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    upsert?: UserUpsertWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffProfileInput, UserUpdateWithoutStaffProfileInput>, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type DepartmentUpdateOneWithoutStaffNestedInput = {
    create?: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutStaffInput
    upsert?: DepartmentUpsertWithoutStaffInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutStaffInput, DepartmentUpdateWithoutStaffInput>, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateManyWithoutHeadDoctorNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput> | DepartmentCreateWithoutHeadDoctorInput[] | DepartmentUncheckedCreateWithoutHeadDoctorInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadDoctorInput | DepartmentCreateOrConnectWithoutHeadDoctorInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadDoctorInput | DepartmentUpsertWithWhereUniqueWithoutHeadDoctorInput[]
    createMany?: DepartmentCreateManyHeadDoctorInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadDoctorInput | DepartmentUpdateWithWhereUniqueWithoutHeadDoctorInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadDoctorInput | DepartmentUpdateManyWithWhereWithoutHeadDoctorInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OpdVisitUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput> | OpdVisitCreateWithoutDoctorInput[] | OpdVisitUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDoctorInput | OpdVisitCreateOrConnectWithoutDoctorInput[]
    upsert?: OpdVisitUpsertWithWhereUniqueWithoutDoctorInput | OpdVisitUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: OpdVisitCreateManyDoctorInputEnvelope
    set?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    disconnect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    delete?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    update?: OpdVisitUpdateWithWhereUniqueWithoutDoctorInput | OpdVisitUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: OpdVisitUpdateManyWithWhereWithoutDoctorInput | OpdVisitUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutAdmittingDoctorNestedInput = {
    create?: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput> | AdmissionCreateWithoutAdmittingDoctorInput[] | AdmissionUncheckedCreateWithoutAdmittingDoctorInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutAdmittingDoctorInput | AdmissionCreateOrConnectWithoutAdmittingDoctorInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutAdmittingDoctorInput | AdmissionUpsertWithWhereUniqueWithoutAdmittingDoctorInput[]
    createMany?: AdmissionCreateManyAdmittingDoctorInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutAdmittingDoctorInput | AdmissionUpdateWithWhereUniqueWithoutAdmittingDoctorInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutAdmittingDoctorInput | AdmissionUpdateManyWithWhereWithoutAdmittingDoctorInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type SurgeryUpdateManyWithoutSurgeonNestedInput = {
    create?: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput> | SurgeryCreateWithoutSurgeonInput[] | SurgeryUncheckedCreateWithoutSurgeonInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgeonInput | SurgeryCreateOrConnectWithoutSurgeonInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutSurgeonInput | SurgeryUpsertWithWhereUniqueWithoutSurgeonInput[]
    createMany?: SurgeryCreateManySurgeonInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutSurgeonInput | SurgeryUpdateWithWhereUniqueWithoutSurgeonInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutSurgeonInput | SurgeryUpdateManyWithWhereWithoutSurgeonInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput> | ClinicalNoteCreateWithoutDoctorInput[] | ClinicalNoteUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutDoctorInput | ClinicalNoteCreateOrConnectWithoutDoctorInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutDoctorInput | ClinicalNoteUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ClinicalNoteCreateManyDoctorInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutDoctorInput | ClinicalNoteUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutDoctorInput | ClinicalNoteUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput> | ServiceOrderCreateWithoutDoctorInput[] | ServiceOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutDoctorInput | ServiceOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutDoctorInput | ServiceOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ServiceOrderCreateManyDoctorInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutDoctorInput | ServiceOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutDoctorInput | ServiceOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type LabResultUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput> | LabResultCreateWithoutVerifiedByInput[] | LabResultUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutVerifiedByInput | LabResultCreateOrConnectWithoutVerifiedByInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutVerifiedByInput | LabResultUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: LabResultCreateManyVerifiedByInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutVerifiedByInput | LabResultUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutVerifiedByInput | LabResultUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type SurgerySStaffUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput> | SurgerySStaffCreateWithoutStaffInput[] | SurgerySStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutStaffInput | SurgerySStaffCreateOrConnectWithoutStaffInput[]
    upsert?: SurgerySStaffUpsertWithWhereUniqueWithoutStaffInput | SurgerySStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SurgerySStaffCreateManyStaffInputEnvelope
    set?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    disconnect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    delete?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    update?: SurgerySStaffUpdateWithWhereUniqueWithoutStaffInput | SurgerySStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SurgerySStaffUpdateManyWithWhereWithoutStaffInput | SurgerySStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput = {
    create?: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput> | DepartmentCreateWithoutHeadDoctorInput[] | DepartmentUncheckedCreateWithoutHeadDoctorInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutHeadDoctorInput | DepartmentCreateOrConnectWithoutHeadDoctorInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutHeadDoctorInput | DepartmentUpsertWithWhereUniqueWithoutHeadDoctorInput[]
    createMany?: DepartmentCreateManyHeadDoctorInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutHeadDoctorInput | DepartmentUpdateWithWhereUniqueWithoutHeadDoctorInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutHeadDoctorInput | DepartmentUpdateManyWithWhereWithoutHeadDoctorInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput> | OpdVisitCreateWithoutDoctorInput[] | OpdVisitUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDoctorInput | OpdVisitCreateOrConnectWithoutDoctorInput[]
    upsert?: OpdVisitUpsertWithWhereUniqueWithoutDoctorInput | OpdVisitUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: OpdVisitCreateManyDoctorInputEnvelope
    set?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    disconnect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    delete?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    update?: OpdVisitUpdateWithWhereUniqueWithoutDoctorInput | OpdVisitUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: OpdVisitUpdateManyWithWhereWithoutDoctorInput | OpdVisitUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput = {
    create?: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput> | AdmissionCreateWithoutAdmittingDoctorInput[] | AdmissionUncheckedCreateWithoutAdmittingDoctorInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutAdmittingDoctorInput | AdmissionCreateOrConnectWithoutAdmittingDoctorInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutAdmittingDoctorInput | AdmissionUpsertWithWhereUniqueWithoutAdmittingDoctorInput[]
    createMany?: AdmissionCreateManyAdmittingDoctorInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutAdmittingDoctorInput | AdmissionUpdateWithWhereUniqueWithoutAdmittingDoctorInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutAdmittingDoctorInput | AdmissionUpdateManyWithWhereWithoutAdmittingDoctorInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput = {
    create?: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput> | SurgeryCreateWithoutSurgeonInput[] | SurgeryUncheckedCreateWithoutSurgeonInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgeonInput | SurgeryCreateOrConnectWithoutSurgeonInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutSurgeonInput | SurgeryUpsertWithWhereUniqueWithoutSurgeonInput[]
    createMany?: SurgeryCreateManySurgeonInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutSurgeonInput | SurgeryUpdateWithWhereUniqueWithoutSurgeonInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutSurgeonInput | SurgeryUpdateManyWithWhereWithoutSurgeonInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput> | ClinicalNoteCreateWithoutDoctorInput[] | ClinicalNoteUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutDoctorInput | ClinicalNoteCreateOrConnectWithoutDoctorInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutDoctorInput | ClinicalNoteUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ClinicalNoteCreateManyDoctorInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutDoctorInput | ClinicalNoteUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutDoctorInput | ClinicalNoteUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput> | ServiceOrderCreateWithoutDoctorInput[] | ServiceOrderUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutDoctorInput | ServiceOrderCreateOrConnectWithoutDoctorInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutDoctorInput | ServiceOrderUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: ServiceOrderCreateManyDoctorInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutDoctorInput | ServiceOrderUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutDoctorInput | ServiceOrderUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput = {
    create?: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput> | LabResultCreateWithoutVerifiedByInput[] | LabResultUncheckedCreateWithoutVerifiedByInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutVerifiedByInput | LabResultCreateOrConnectWithoutVerifiedByInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutVerifiedByInput | LabResultUpsertWithWhereUniqueWithoutVerifiedByInput[]
    createMany?: LabResultCreateManyVerifiedByInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutVerifiedByInput | LabResultUpdateWithWhereUniqueWithoutVerifiedByInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutVerifiedByInput | LabResultUpdateManyWithWhereWithoutVerifiedByInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput> | PrescriptionCreateWithoutDoctorInput[] | PrescriptionUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutDoctorInput | PrescriptionCreateOrConnectWithoutDoctorInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutDoctorInput | PrescriptionUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: PrescriptionCreateManyDoctorInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutDoctorInput | PrescriptionUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutDoctorInput | PrescriptionUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput> | SurgerySStaffCreateWithoutStaffInput[] | SurgerySStaffUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutStaffInput | SurgerySStaffCreateOrConnectWithoutStaffInput[]
    upsert?: SurgerySStaffUpsertWithWhereUniqueWithoutStaffInput | SurgerySStaffUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: SurgerySStaffCreateManyStaffInputEnvelope
    set?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    disconnect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    delete?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    update?: SurgerySStaffUpdateWithWhereUniqueWithoutStaffInput | SurgerySStaffUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: SurgerySStaffUpdateManyWithWhereWithoutStaffInput | SurgerySStaffUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
  }

  export type StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput = {
    create?: XOR<StaffProfileCreateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedCreateWithoutHeadOfDepartmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutHeadOfDepartmentsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type StaffProfileCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput> | StaffProfileCreateWithoutDepartmentInput[] | StaffProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutDepartmentInput | StaffProfileCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffProfileCreateManyDepartmentInputEnvelope
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
  }

  export type ServiceCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type WardCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput> | WardCreateWithoutDepartmentInput[] | WardUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WardCreateOrConnectWithoutDepartmentInput | WardCreateOrConnectWithoutDepartmentInput[]
    createMany?: WardCreateManyDepartmentInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput> | StaffProfileCreateWithoutDepartmentInput[] | StaffProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutDepartmentInput | StaffProfileCreateOrConnectWithoutDepartmentInput[]
    createMany?: StaffProfileCreateManyDepartmentInputEnvelope
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type WardUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput> | WardCreateWithoutDepartmentInput[] | WardUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WardCreateOrConnectWithoutDepartmentInput | WardCreateOrConnectWithoutDepartmentInput[]
    createMany?: WardCreateManyDepartmentInputEnvelope
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumDepartmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DepartmentType
  }

  export type StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedCreateWithoutHeadOfDepartmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutHeadOfDepartmentsInput
    upsert?: StaffProfileUpsertWithoutHeadOfDepartmentsInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutHeadOfDepartmentsInput, StaffProfileUpdateWithoutHeadOfDepartmentsInput>, StaffProfileUncheckedUpdateWithoutHeadOfDepartmentsInput>
  }

  export type StaffProfileUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput> | StaffProfileCreateWithoutDepartmentInput[] | StaffProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutDepartmentInput | StaffProfileCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffProfileUpsertWithWhereUniqueWithoutDepartmentInput | StaffProfileUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffProfileCreateManyDepartmentInputEnvelope
    set?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    disconnect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    delete?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    update?: StaffProfileUpdateWithWhereUniqueWithoutDepartmentInput | StaffProfileUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffProfileUpdateManyWithWhereWithoutDepartmentInput | StaffProfileUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
  }

  export type ServiceUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type WardUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput> | WardCreateWithoutDepartmentInput[] | WardUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WardCreateOrConnectWithoutDepartmentInput | WardCreateOrConnectWithoutDepartmentInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutDepartmentInput | WardUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: WardCreateManyDepartmentInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutDepartmentInput | WardUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: WardUpdateManyWithWhereWithoutDepartmentInput | WardUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDepartmentInput | AppointmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDepartmentInput | AppointmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDepartmentInput | AppointmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutDepartmentInput | AdmissionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutDepartmentInput | AdmissionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutDepartmentInput | AdmissionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput> | StaffProfileCreateWithoutDepartmentInput[] | StaffProfileUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: StaffProfileCreateOrConnectWithoutDepartmentInput | StaffProfileCreateOrConnectWithoutDepartmentInput[]
    upsert?: StaffProfileUpsertWithWhereUniqueWithoutDepartmentInput | StaffProfileUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: StaffProfileCreateManyDepartmentInputEnvelope
    set?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    disconnect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    delete?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    connect?: StaffProfileWhereUniqueInput | StaffProfileWhereUniqueInput[]
    update?: StaffProfileUpdateWithWhereUniqueWithoutDepartmentInput | StaffProfileUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: StaffProfileUpdateManyWithWhereWithoutDepartmentInput | StaffProfileUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput> | ServiceCreateWithoutDepartmentInput[] | ServiceUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutDepartmentInput | ServiceCreateOrConnectWithoutDepartmentInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutDepartmentInput | ServiceUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: ServiceCreateManyDepartmentInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutDepartmentInput | ServiceUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutDepartmentInput | ServiceUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type WardUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput> | WardCreateWithoutDepartmentInput[] | WardUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: WardCreateOrConnectWithoutDepartmentInput | WardCreateOrConnectWithoutDepartmentInput[]
    upsert?: WardUpsertWithWhereUniqueWithoutDepartmentInput | WardUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: WardCreateManyDepartmentInputEnvelope
    set?: WardWhereUniqueInput | WardWhereUniqueInput[]
    disconnect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    delete?: WardWhereUniqueInput | WardWhereUniqueInput[]
    connect?: WardWhereUniqueInput | WardWhereUniqueInput[]
    update?: WardUpdateWithWhereUniqueWithoutDepartmentInput | WardUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: WardUpdateManyWithWhereWithoutDepartmentInput | WardUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: WardScalarWhereInput | WardScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput> | AppointmentCreateWithoutDepartmentInput[] | AppointmentUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDepartmentInput | AppointmentCreateOrConnectWithoutDepartmentInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDepartmentInput | AppointmentUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AppointmentCreateManyDepartmentInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDepartmentInput | AppointmentUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDepartmentInput | AppointmentUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput> | AdmissionCreateWithoutDepartmentInput[] | AdmissionUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutDepartmentInput | AdmissionCreateOrConnectWithoutDepartmentInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutDepartmentInput | AdmissionUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: AdmissionCreateManyDepartmentInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutDepartmentInput | AdmissionUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutDepartmentInput | AdmissionUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutServicesInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type ServiceOrderCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DepartmentUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutServicesInput
    upsert?: DepartmentUpsertWithoutServicesInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutServicesInput, DepartmentUpdateWithoutServicesInput>, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type ServiceOrderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutServiceInput | ServiceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutServiceInput | ServiceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutServiceInput | ServiceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput> | ServiceOrderCreateWithoutServiceInput[] | ServiceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutServiceInput | ServiceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutServiceInput | ServiceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceOrderCreateManyServiceInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutServiceInput | ServiceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutServiceInput | ServiceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput> | InvoiceItemCreateWithoutServiceInput[] | InvoiceItemUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceInput | InvoiceItemCreateOrConnectWithoutServiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: InvoiceItemCreateManyServiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceInput | InvoiceItemUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type DepartmentCreateNestedOneWithoutWardsInput = {
    create?: XOR<DepartmentCreateWithoutWardsInput, DepartmentUncheckedCreateWithoutWardsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutWardsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type BedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type BedUncheckedCreateNestedManyWithoutWardInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DepartmentUpdateOneRequiredWithoutWardsNestedInput = {
    create?: XOR<DepartmentCreateWithoutWardsInput, DepartmentUncheckedCreateWithoutWardsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutWardsInput
    upsert?: DepartmentUpsertWithoutWardsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutWardsInput, DepartmentUpdateWithoutWardsInput>, DepartmentUncheckedUpdateWithoutWardsInput>
  }

  export type BedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type BedUncheckedUpdateManyWithoutWardNestedInput = {
    create?: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput> | BedCreateWithoutWardInput[] | BedUncheckedCreateWithoutWardInput[]
    connectOrCreate?: BedCreateOrConnectWithoutWardInput | BedCreateOrConnectWithoutWardInput[]
    upsert?: BedUpsertWithWhereUniqueWithoutWardInput | BedUpsertWithWhereUniqueWithoutWardInput[]
    createMany?: BedCreateManyWardInputEnvelope
    set?: BedWhereUniqueInput | BedWhereUniqueInput[]
    disconnect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    delete?: BedWhereUniqueInput | BedWhereUniqueInput[]
    connect?: BedWhereUniqueInput | BedWhereUniqueInput[]
    update?: BedUpdateWithWhereUniqueWithoutWardInput | BedUpdateWithWhereUniqueWithoutWardInput[]
    updateMany?: BedUpdateManyWithWhereWithoutWardInput | BedUpdateManyWithWhereWithoutWardInput[]
    deleteMany?: BedScalarWhereInput | BedScalarWhereInput[]
  }

  export type WardCreateNestedOneWithoutBedsInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    connect?: WardWhereUniqueInput
  }

  export type BedTransferCreateNestedManyWithoutBedInput = {
    create?: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput> | BedTransferCreateWithoutBedInput[] | BedTransferUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutBedInput | BedTransferCreateOrConnectWithoutBedInput[]
    createMany?: BedTransferCreateManyBedInputEnvelope
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutCurrentBedInput = {
    create?: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput> | AdmissionCreateWithoutCurrentBedInput[] | AdmissionUncheckedCreateWithoutCurrentBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutCurrentBedInput | AdmissionCreateOrConnectWithoutCurrentBedInput[]
    createMany?: AdmissionCreateManyCurrentBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type BedTransferUncheckedCreateNestedManyWithoutBedInput = {
    create?: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput> | BedTransferCreateWithoutBedInput[] | BedTransferUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutBedInput | BedTransferCreateOrConnectWithoutBedInput[]
    createMany?: BedTransferCreateManyBedInputEnvelope
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutCurrentBedInput = {
    create?: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput> | AdmissionCreateWithoutCurrentBedInput[] | AdmissionUncheckedCreateWithoutCurrentBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutCurrentBedInput | AdmissionCreateOrConnectWithoutCurrentBedInput[]
    createMany?: AdmissionCreateManyCurrentBedInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type EnumBedStatusFieldUpdateOperationsInput = {
    set?: $Enums.BedStatus
  }

  export type WardUpdateOneRequiredWithoutBedsNestedInput = {
    create?: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    connectOrCreate?: WardCreateOrConnectWithoutBedsInput
    upsert?: WardUpsertWithoutBedsInput
    connect?: WardWhereUniqueInput
    update?: XOR<XOR<WardUpdateToOneWithWhereWithoutBedsInput, WardUpdateWithoutBedsInput>, WardUncheckedUpdateWithoutBedsInput>
  }

  export type BedTransferUpdateManyWithoutBedNestedInput = {
    create?: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput> | BedTransferCreateWithoutBedInput[] | BedTransferUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutBedInput | BedTransferCreateOrConnectWithoutBedInput[]
    upsert?: BedTransferUpsertWithWhereUniqueWithoutBedInput | BedTransferUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: BedTransferCreateManyBedInputEnvelope
    set?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    disconnect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    delete?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    update?: BedTransferUpdateWithWhereUniqueWithoutBedInput | BedTransferUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: BedTransferUpdateManyWithWhereWithoutBedInput | BedTransferUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutCurrentBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput> | AdmissionCreateWithoutCurrentBedInput[] | AdmissionUncheckedCreateWithoutCurrentBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutCurrentBedInput | AdmissionCreateOrConnectWithoutCurrentBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutCurrentBedInput | AdmissionUpsertWithWhereUniqueWithoutCurrentBedInput[]
    createMany?: AdmissionCreateManyCurrentBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutCurrentBedInput | AdmissionUpdateWithWhereUniqueWithoutCurrentBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutCurrentBedInput | AdmissionUpdateManyWithWhereWithoutCurrentBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type BedTransferUncheckedUpdateManyWithoutBedNestedInput = {
    create?: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput> | BedTransferCreateWithoutBedInput[] | BedTransferUncheckedCreateWithoutBedInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutBedInput | BedTransferCreateOrConnectWithoutBedInput[]
    upsert?: BedTransferUpsertWithWhereUniqueWithoutBedInput | BedTransferUpsertWithWhereUniqueWithoutBedInput[]
    createMany?: BedTransferCreateManyBedInputEnvelope
    set?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    disconnect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    delete?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    update?: BedTransferUpdateWithWhereUniqueWithoutBedInput | BedTransferUpdateWithWhereUniqueWithoutBedInput[]
    updateMany?: BedTransferUpdateManyWithWhereWithoutBedInput | BedTransferUpdateManyWithWhereWithoutBedInput[]
    deleteMany?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutCurrentBedNestedInput = {
    create?: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput> | AdmissionCreateWithoutCurrentBedInput[] | AdmissionUncheckedCreateWithoutCurrentBedInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutCurrentBedInput | AdmissionCreateOrConnectWithoutCurrentBedInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutCurrentBedInput | AdmissionUpsertWithWhereUniqueWithoutCurrentBedInput[]
    createMany?: AdmissionCreateManyCurrentBedInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutCurrentBedInput | AdmissionUpdateWithWhereUniqueWithoutCurrentBedInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutCurrentBedInput | AdmissionUpdateManyWithWhereWithoutCurrentBedInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type MedicalHistoryCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
  }

  export type PatientDocumentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput> | PatientDocumentCreateWithoutPatientInput[] | PatientDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutPatientInput | PatientDocumentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientDocumentCreateManyPatientInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OpdVisitCreateNestedManyWithoutPatientInput = {
    create?: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput> | OpdVisitCreateWithoutPatientInput[] | OpdVisitUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPatientInput | OpdVisitCreateOrConnectWithoutPatientInput[]
    createMany?: OpdVisitCreateManyPatientInputEnvelope
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
  }

  export type AdmissionCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutPatientInput = {
    create?: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput> | ServiceOrderCreateWithoutPatientInput[] | ServiceOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutPatientInput | ServiceOrderCreateOrConnectWithoutPatientInput[]
    createMany?: ServiceOrderCreateManyPatientInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PharmacySaleCreateNestedManyWithoutPatientInput = {
    create?: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput> | PharmacySaleCreateWithoutPatientInput[] | PharmacySaleUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPatientInput | PharmacySaleCreateOrConnectWithoutPatientInput[]
    createMany?: PharmacySaleCreateManyPatientInputEnvelope
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
  }

  export type PatientDocumentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput> | PatientDocumentCreateWithoutPatientInput[] | PatientDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutPatientInput | PatientDocumentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientDocumentCreateManyPatientInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type OpdVisitUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput> | OpdVisitCreateWithoutPatientInput[] | OpdVisitUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPatientInput | OpdVisitCreateOrConnectWithoutPatientInput[]
    createMany?: OpdVisitCreateManyPatientInputEnvelope
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput> | ServiceOrderCreateWithoutPatientInput[] | ServiceOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutPatientInput | ServiceOrderCreateOrConnectWithoutPatientInput[]
    createMany?: ServiceOrderCreateManyPatientInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PharmacySaleUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput> | PharmacySaleCreateWithoutPatientInput[] | PharmacySaleUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPatientInput | PharmacySaleCreateOrConnectWithoutPatientInput[]
    createMany?: PharmacySaleCreateManyPatientInputEnvelope
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type MedicalHistoryUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput | MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    set?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    disconnect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    delete?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    update?: MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput | MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalHistoryUpdateManyWithWhereWithoutPatientInput | MedicalHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
  }

  export type PatientDocumentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput> | PatientDocumentCreateWithoutPatientInput[] | PatientDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutPatientInput | PatientDocumentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutPatientInput | PatientDocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientDocumentCreateManyPatientInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutPatientInput | PatientDocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutPatientInput | PatientDocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OpdVisitUpdateManyWithoutPatientNestedInput = {
    create?: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput> | OpdVisitCreateWithoutPatientInput[] | OpdVisitUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPatientInput | OpdVisitCreateOrConnectWithoutPatientInput[]
    upsert?: OpdVisitUpsertWithWhereUniqueWithoutPatientInput | OpdVisitUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: OpdVisitCreateManyPatientInputEnvelope
    set?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    disconnect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    delete?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    update?: OpdVisitUpdateWithWhereUniqueWithoutPatientInput | OpdVisitUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: OpdVisitUpdateManyWithWhereWithoutPatientInput | OpdVisitUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
  }

  export type AdmissionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput> | ServiceOrderCreateWithoutPatientInput[] | ServiceOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutPatientInput | ServiceOrderCreateOrConnectWithoutPatientInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutPatientInput | ServiceOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ServiceOrderCreateManyPatientInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutPatientInput | ServiceOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutPatientInput | ServiceOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PharmacySaleUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput> | PharmacySaleCreateWithoutPatientInput[] | PharmacySaleUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPatientInput | PharmacySaleCreateOrConnectWithoutPatientInput[]
    upsert?: PharmacySaleUpsertWithWhereUniqueWithoutPatientInput | PharmacySaleUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PharmacySaleCreateManyPatientInputEnvelope
    set?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    disconnect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    delete?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    update?: PharmacySaleUpdateWithWhereUniqueWithoutPatientInput | PharmacySaleUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PharmacySaleUpdateManyWithWhereWithoutPatientInput | PharmacySaleUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput> | MedicalHistoryCreateWithoutPatientInput[] | MedicalHistoryUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicalHistoryCreateOrConnectWithoutPatientInput | MedicalHistoryCreateOrConnectWithoutPatientInput[]
    upsert?: MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput | MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicalHistoryCreateManyPatientInputEnvelope
    set?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    disconnect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    delete?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    connect?: MedicalHistoryWhereUniqueInput | MedicalHistoryWhereUniqueInput[]
    update?: MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput | MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicalHistoryUpdateManyWithWhereWithoutPatientInput | MedicalHistoryUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
  }

  export type PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput> | PatientDocumentCreateWithoutPatientInput[] | PatientDocumentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutPatientInput | PatientDocumentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutPatientInput | PatientDocumentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientDocumentCreateManyPatientInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutPatientInput | PatientDocumentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutPatientInput | PatientDocumentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type OpdVisitUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput> | OpdVisitCreateWithoutPatientInput[] | OpdVisitUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPatientInput | OpdVisitCreateOrConnectWithoutPatientInput[]
    upsert?: OpdVisitUpsertWithWhereUniqueWithoutPatientInput | OpdVisitUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: OpdVisitCreateManyPatientInputEnvelope
    set?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    disconnect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    delete?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    connect?: OpdVisitWhereUniqueInput | OpdVisitWhereUniqueInput[]
    update?: OpdVisitUpdateWithWhereUniqueWithoutPatientInput | OpdVisitUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: OpdVisitUpdateManyWithWhereWithoutPatientInput | OpdVisitUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput> | AdmissionCreateWithoutPatientInput[] | AdmissionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AdmissionCreateOrConnectWithoutPatientInput | AdmissionCreateOrConnectWithoutPatientInput[]
    upsert?: AdmissionUpsertWithWhereUniqueWithoutPatientInput | AdmissionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AdmissionCreateManyPatientInputEnvelope
    set?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    disconnect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    delete?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    connect?: AdmissionWhereUniqueInput | AdmissionWhereUniqueInput[]
    update?: AdmissionUpdateWithWhereUniqueWithoutPatientInput | AdmissionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AdmissionUpdateManyWithWhereWithoutPatientInput | AdmissionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput> | ClinicalNoteCreateWithoutPatientInput[] | ClinicalNoteUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutPatientInput | ClinicalNoteCreateOrConnectWithoutPatientInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput | ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ClinicalNoteCreateManyPatientInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput | ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutPatientInput | ClinicalNoteUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput> | ServiceOrderCreateWithoutPatientInput[] | ServiceOrderUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutPatientInput | ServiceOrderCreateOrConnectWithoutPatientInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutPatientInput | ServiceOrderUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ServiceOrderCreateManyPatientInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutPatientInput | ServiceOrderUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutPatientInput | ServiceOrderUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput> | PrescriptionCreateWithoutPatientInput[] | PrescriptionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutPatientInput | PrescriptionCreateOrConnectWithoutPatientInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutPatientInput | PrescriptionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PrescriptionCreateManyPatientInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutPatientInput | PrescriptionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutPatientInput | PrescriptionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput> | PharmacySaleCreateWithoutPatientInput[] | PharmacySaleUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPatientInput | PharmacySaleCreateOrConnectWithoutPatientInput[]
    upsert?: PharmacySaleUpsertWithWhereUniqueWithoutPatientInput | PharmacySaleUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PharmacySaleCreateManyPatientInputEnvelope
    set?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    disconnect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    delete?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    update?: PharmacySaleUpdateWithWhereUniqueWithoutPatientInput | PharmacySaleUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PharmacySaleUpdateManyWithWhereWithoutPatientInput | PharmacySaleUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput> | InvoiceCreateWithoutPatientInput[] | InvoiceUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutPatientInput | InvoiceCreateOrConnectWithoutPatientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutPatientInput | InvoiceUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: InvoiceCreateManyPatientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutPatientInput | InvoiceUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutPatientInput | InvoiceUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutMedicalHistoryInput = {
    create?: XOR<PatientCreateWithoutMedicalHistoryInput, PatientUncheckedCreateWithoutMedicalHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalHistoryInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicalHistoryNestedInput = {
    create?: XOR<PatientCreateWithoutMedicalHistoryInput, PatientUncheckedCreateWithoutMedicalHistoryInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicalHistoryInput
    upsert?: PatientUpsertWithoutMedicalHistoryInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicalHistoryInput, PatientUpdateWithoutMedicalHistoryInput>, PatientUncheckedUpdateWithoutMedicalHistoryInput>
  }

  export type PatientCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsInput
    connect?: PatientWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<OpdVisitCreateWithoutDocumentsInput, OpdVisitUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDocumentsInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type AdmissionCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutDocumentsInput
    connect?: AdmissionWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutDocumentsInput
    upsert?: PatientUpsertWithoutDocumentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutDocumentsInput, PatientUpdateWithoutDocumentsInput>, PatientUncheckedUpdateWithoutDocumentsInput>
  }

  export type OpdVisitUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<OpdVisitCreateWithoutDocumentsInput, OpdVisitUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutDocumentsInput
    upsert?: OpdVisitUpsertWithoutDocumentsInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutDocumentsInput, OpdVisitUpdateWithoutDocumentsInput>, OpdVisitUncheckedUpdateWithoutDocumentsInput>
  }

  export type AdmissionUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutDocumentsInput
    upsert?: AdmissionUpsertWithoutDocumentsInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutDocumentsInput, AdmissionUpdateWithoutDocumentsInput>, AdmissionUncheckedUpdateWithoutDocumentsInput>
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<StaffProfileCreateWithoutAppointmentsInput, StaffProfileUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAppointmentsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAppointmentsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAppointmentInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type OpdVisitUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAppointmentInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type EnumAppointmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentType
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutAppointmentsInput, StaffProfileUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAppointmentsInput
    upsert?: StaffProfileUpsertWithoutAppointmentsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutAppointmentsInput, StaffProfileUpdateWithoutAppointmentsInput>, StaffProfileUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAppointmentsInput
    upsert?: DepartmentUpsertWithoutAppointmentsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAppointmentsInput, DepartmentUpdateWithoutAppointmentsInput>, DepartmentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type OpdVisitUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAppointmentInput
    upsert?: OpdVisitUpsertWithoutAppointmentInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutAppointmentInput, OpdVisitUpdateWithoutAppointmentInput>, OpdVisitUncheckedUpdateWithoutAppointmentInput>
  }

  export type OpdVisitUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAppointmentInput
    upsert?: OpdVisitUpsertWithoutAppointmentInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutAppointmentInput, OpdVisitUpdateWithoutAppointmentInput>, OpdVisitUncheckedUpdateWithoutAppointmentInput>
  }

  export type AppointmentCreateNestedOneWithoutOpdVisitInput = {
    create?: XOR<AppointmentCreateWithoutOpdVisitInput, AppointmentUncheckedCreateWithoutOpdVisitInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutOpdVisitInput
    connect?: AppointmentWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutOpdVisitsInput = {
    create?: XOR<PatientCreateWithoutOpdVisitsInput, PatientUncheckedCreateWithoutOpdVisitsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOpdVisitsInput
    connect?: PatientWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutOpdVisitsInput = {
    create?: XOR<StaffProfileCreateWithoutOpdVisitsInput, StaffProfileUncheckedCreateWithoutOpdVisitsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutOpdVisitsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ClinicalNoteCreateNestedManyWithoutVisitInput = {
    create?: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput> | ClinicalNoteCreateWithoutVisitInput[] | ClinicalNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutVisitInput | ClinicalNoteCreateOrConnectWithoutVisitInput[]
    createMany?: ClinicalNoteCreateManyVisitInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutVisitInput = {
    create?: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput> | ServiceOrderCreateWithoutVisitInput[] | ServiceOrderUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutVisitInput | ServiceOrderCreateOrConnectWithoutVisitInput[]
    createMany?: ServiceOrderCreateManyVisitInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutVisitInput = {
    create?: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput> | PrescriptionCreateWithoutVisitInput[] | PrescriptionUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutVisitInput | PrescriptionCreateOrConnectWithoutVisitInput[]
    createMany?: PrescriptionCreateManyVisitInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PatientDocumentCreateNestedManyWithoutVisitInput = {
    create?: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput> | PatientDocumentCreateWithoutVisitInput[] | PatientDocumentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutVisitInput | PatientDocumentCreateOrConnectWithoutVisitInput[]
    createMany?: PatientDocumentCreateManyVisitInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutVisitInput = {
    create?: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput> | InvoiceCreateWithoutVisitInput[] | InvoiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutVisitInput | InvoiceCreateOrConnectWithoutVisitInput[]
    createMany?: InvoiceCreateManyVisitInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AdmissionCreateNestedOneWithoutVisitInput = {
    create?: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutVisitInput
    connect?: AdmissionWhereUniqueInput
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput> | ClinicalNoteCreateWithoutVisitInput[] | ClinicalNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutVisitInput | ClinicalNoteCreateOrConnectWithoutVisitInput[]
    createMany?: ClinicalNoteCreateManyVisitInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput> | ServiceOrderCreateWithoutVisitInput[] | ServiceOrderUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutVisitInput | ServiceOrderCreateOrConnectWithoutVisitInput[]
    createMany?: ServiceOrderCreateManyVisitInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput> | PrescriptionCreateWithoutVisitInput[] | PrescriptionUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutVisitInput | PrescriptionCreateOrConnectWithoutVisitInput[]
    createMany?: PrescriptionCreateManyVisitInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PatientDocumentUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput> | PatientDocumentCreateWithoutVisitInput[] | PatientDocumentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutVisitInput | PatientDocumentCreateOrConnectWithoutVisitInput[]
    createMany?: PatientDocumentCreateManyVisitInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutVisitInput = {
    create?: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput> | InvoiceCreateWithoutVisitInput[] | InvoiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutVisitInput | InvoiceCreateOrConnectWithoutVisitInput[]
    createMany?: InvoiceCreateManyVisitInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type AdmissionUncheckedCreateNestedOneWithoutVisitInput = {
    create?: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutVisitInput
    connect?: AdmissionWhereUniqueInput
  }

  export type EnumVisitTypeFieldUpdateOperationsInput = {
    set?: $Enums.VisitType
  }

  export type NullableEnumTriageColorFieldUpdateOperationsInput = {
    set?: $Enums.TriageColor | null
  }

  export type EnumVisitStatusFieldUpdateOperationsInput = {
    set?: $Enums.VisitStatus
  }

  export type AppointmentUpdateOneWithoutOpdVisitNestedInput = {
    create?: XOR<AppointmentCreateWithoutOpdVisitInput, AppointmentUncheckedCreateWithoutOpdVisitInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutOpdVisitInput
    upsert?: AppointmentUpsertWithoutOpdVisitInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutOpdVisitInput, AppointmentUpdateWithoutOpdVisitInput>, AppointmentUncheckedUpdateWithoutOpdVisitInput>
  }

  export type PatientUpdateOneRequiredWithoutOpdVisitsNestedInput = {
    create?: XOR<PatientCreateWithoutOpdVisitsInput, PatientUncheckedCreateWithoutOpdVisitsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutOpdVisitsInput
    upsert?: PatientUpsertWithoutOpdVisitsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutOpdVisitsInput, PatientUpdateWithoutOpdVisitsInput>, PatientUncheckedUpdateWithoutOpdVisitsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutOpdVisitsInput, StaffProfileUncheckedCreateWithoutOpdVisitsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutOpdVisitsInput
    upsert?: StaffProfileUpsertWithoutOpdVisitsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutOpdVisitsInput, StaffProfileUpdateWithoutOpdVisitsInput>, StaffProfileUncheckedUpdateWithoutOpdVisitsInput>
  }

  export type ClinicalNoteUpdateManyWithoutVisitNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput> | ClinicalNoteCreateWithoutVisitInput[] | ClinicalNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutVisitInput | ClinicalNoteCreateOrConnectWithoutVisitInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutVisitInput | ClinicalNoteUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: ClinicalNoteCreateManyVisitInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutVisitInput | ClinicalNoteUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutVisitInput | ClinicalNoteUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutVisitNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput> | ServiceOrderCreateWithoutVisitInput[] | ServiceOrderUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutVisitInput | ServiceOrderCreateOrConnectWithoutVisitInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutVisitInput | ServiceOrderUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: ServiceOrderCreateManyVisitInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutVisitInput | ServiceOrderUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutVisitInput | ServiceOrderUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutVisitNestedInput = {
    create?: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput> | PrescriptionCreateWithoutVisitInput[] | PrescriptionUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutVisitInput | PrescriptionCreateOrConnectWithoutVisitInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutVisitInput | PrescriptionUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: PrescriptionCreateManyVisitInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutVisitInput | PrescriptionUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutVisitInput | PrescriptionUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PatientDocumentUpdateManyWithoutVisitNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput> | PatientDocumentCreateWithoutVisitInput[] | PatientDocumentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutVisitInput | PatientDocumentCreateOrConnectWithoutVisitInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutVisitInput | PatientDocumentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: PatientDocumentCreateManyVisitInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutVisitInput | PatientDocumentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutVisitInput | PatientDocumentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutVisitNestedInput = {
    create?: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput> | InvoiceCreateWithoutVisitInput[] | InvoiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutVisitInput | InvoiceCreateOrConnectWithoutVisitInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutVisitInput | InvoiceUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: InvoiceCreateManyVisitInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutVisitInput | InvoiceUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutVisitInput | InvoiceUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AdmissionUpdateOneWithoutVisitNestedInput = {
    create?: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutVisitInput
    upsert?: AdmissionUpsertWithoutVisitInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutVisitInput, AdmissionUpdateWithoutVisitInput>, AdmissionUncheckedUpdateWithoutVisitInput>
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput> | ClinicalNoteCreateWithoutVisitInput[] | ClinicalNoteUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutVisitInput | ClinicalNoteCreateOrConnectWithoutVisitInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutVisitInput | ClinicalNoteUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: ClinicalNoteCreateManyVisitInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutVisitInput | ClinicalNoteUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutVisitInput | ClinicalNoteUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput> | ServiceOrderCreateWithoutVisitInput[] | ServiceOrderUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutVisitInput | ServiceOrderCreateOrConnectWithoutVisitInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutVisitInput | ServiceOrderUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: ServiceOrderCreateManyVisitInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutVisitInput | ServiceOrderUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutVisitInput | ServiceOrderUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput> | PrescriptionCreateWithoutVisitInput[] | PrescriptionUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutVisitInput | PrescriptionCreateOrConnectWithoutVisitInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutVisitInput | PrescriptionUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: PrescriptionCreateManyVisitInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutVisitInput | PrescriptionUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutVisitInput | PrescriptionUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput> | PatientDocumentCreateWithoutVisitInput[] | PatientDocumentUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutVisitInput | PatientDocumentCreateOrConnectWithoutVisitInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutVisitInput | PatientDocumentUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: PatientDocumentCreateManyVisitInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutVisitInput | PatientDocumentUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutVisitInput | PatientDocumentUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutVisitNestedInput = {
    create?: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput> | InvoiceCreateWithoutVisitInput[] | InvoiceUncheckedCreateWithoutVisitInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutVisitInput | InvoiceCreateOrConnectWithoutVisitInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutVisitInput | InvoiceUpsertWithWhereUniqueWithoutVisitInput[]
    createMany?: InvoiceCreateManyVisitInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutVisitInput | InvoiceUpdateWithWhereUniqueWithoutVisitInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutVisitInput | InvoiceUpdateManyWithWhereWithoutVisitInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type AdmissionUncheckedUpdateOneWithoutVisitNestedInput = {
    create?: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutVisitInput
    upsert?: AdmissionUpsertWithoutVisitInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutVisitInput, AdmissionUpdateWithoutVisitInput>, AdmissionUncheckedUpdateWithoutVisitInput>
  }

  export type PatientCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionsInput
    connect?: PatientWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<StaffProfileCreateWithoutAdmissionsInput, StaffProfileUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAdmissionsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutAdmissionsInput = {
    create?: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAdmissionsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutAdmissionInput = {
    create?: XOR<OpdVisitCreateWithoutAdmissionInput, OpdVisitUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAdmissionInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type BedCreateNestedOneWithoutActiveAdmissionsInput = {
    create?: XOR<BedCreateWithoutActiveAdmissionsInput, BedUncheckedCreateWithoutActiveAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutActiveAdmissionsInput
    connect?: BedWhereUniqueInput
  }

  export type BedTransferCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput> | BedTransferCreateWithoutAdmissionInput[] | BedTransferUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutAdmissionInput | BedTransferCreateOrConnectWithoutAdmissionInput[]
    createMany?: BedTransferCreateManyAdmissionInputEnvelope
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
  }

  export type SurgeryCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput> | SurgeryCreateWithoutAdmissionInput[] | SurgeryUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutAdmissionInput | SurgeryCreateOrConnectWithoutAdmissionInput[]
    createMany?: SurgeryCreateManyAdmissionInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type ClinicalNoteCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput> | ClinicalNoteCreateWithoutAdmissionInput[] | ClinicalNoteUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAdmissionInput | ClinicalNoteCreateOrConnectWithoutAdmissionInput[]
    createMany?: ClinicalNoteCreateManyAdmissionInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput> | ServiceOrderCreateWithoutAdmissionInput[] | ServiceOrderUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutAdmissionInput | ServiceOrderCreateOrConnectWithoutAdmissionInput[]
    createMany?: ServiceOrderCreateManyAdmissionInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput> | PrescriptionCreateWithoutAdmissionInput[] | PrescriptionUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAdmissionInput | PrescriptionCreateOrConnectWithoutAdmissionInput[]
    createMany?: PrescriptionCreateManyAdmissionInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PatientDocumentCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput> | PatientDocumentCreateWithoutAdmissionInput[] | PatientDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutAdmissionInput | PatientDocumentCreateOrConnectWithoutAdmissionInput[]
    createMany?: PatientDocumentCreateManyAdmissionInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput> | InvoiceCreateWithoutAdmissionInput[] | InvoiceUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAdmissionInput | InvoiceCreateOrConnectWithoutAdmissionInput[]
    createMany?: InvoiceCreateManyAdmissionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InsuranceClaimCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput> | InsuranceClaimCreateWithoutAdmissionInput[] | InsuranceClaimUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutAdmissionInput | InsuranceClaimCreateOrConnectWithoutAdmissionInput[]
    createMany?: InsuranceClaimCreateManyAdmissionInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type BedTransferUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput> | BedTransferCreateWithoutAdmissionInput[] | BedTransferUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutAdmissionInput | BedTransferCreateOrConnectWithoutAdmissionInput[]
    createMany?: BedTransferCreateManyAdmissionInputEnvelope
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
  }

  export type SurgeryUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput> | SurgeryCreateWithoutAdmissionInput[] | SurgeryUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutAdmissionInput | SurgeryCreateOrConnectWithoutAdmissionInput[]
    createMany?: SurgeryCreateManyAdmissionInputEnvelope
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
  }

  export type ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput> | ClinicalNoteCreateWithoutAdmissionInput[] | ClinicalNoteUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAdmissionInput | ClinicalNoteCreateOrConnectWithoutAdmissionInput[]
    createMany?: ClinicalNoteCreateManyAdmissionInputEnvelope
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
  }

  export type ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput> | ServiceOrderCreateWithoutAdmissionInput[] | ServiceOrderUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutAdmissionInput | ServiceOrderCreateOrConnectWithoutAdmissionInput[]
    createMany?: ServiceOrderCreateManyAdmissionInputEnvelope
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
  }

  export type PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput> | PrescriptionCreateWithoutAdmissionInput[] | PrescriptionUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAdmissionInput | PrescriptionCreateOrConnectWithoutAdmissionInput[]
    createMany?: PrescriptionCreateManyAdmissionInputEnvelope
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
  }

  export type PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput> | PatientDocumentCreateWithoutAdmissionInput[] | PatientDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutAdmissionInput | PatientDocumentCreateOrConnectWithoutAdmissionInput[]
    createMany?: PatientDocumentCreateManyAdmissionInputEnvelope
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput> | InvoiceCreateWithoutAdmissionInput[] | InvoiceUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAdmissionInput | InvoiceCreateOrConnectWithoutAdmissionInput[]
    createMany?: InvoiceCreateManyAdmissionInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput = {
    create?: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput> | InsuranceClaimCreateWithoutAdmissionInput[] | InsuranceClaimUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutAdmissionInput | InsuranceClaimCreateOrConnectWithoutAdmissionInput[]
    createMany?: InsuranceClaimCreateManyAdmissionInputEnvelope
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
  }

  export type EnumAdmissionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdmissionType
  }

  export type EnumAdmissionStatusFieldUpdateOperationsInput = {
    set?: $Enums.AdmissionStatus
  }

  export type NullableEnumDischargeTypeFieldUpdateOperationsInput = {
    set?: $Enums.DischargeType | null
  }

  export type PatientUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAdmissionsInput
    upsert?: PatientUpsertWithoutAdmissionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAdmissionsInput, PatientUpdateWithoutAdmissionsInput>, PatientUncheckedUpdateWithoutAdmissionsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutAdmissionsInput, StaffProfileUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAdmissionsInput
    upsert?: StaffProfileUpsertWithoutAdmissionsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutAdmissionsInput, StaffProfileUpdateWithoutAdmissionsInput>, StaffProfileUncheckedUpdateWithoutAdmissionsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput = {
    create?: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutAdmissionsInput
    upsert?: DepartmentUpsertWithoutAdmissionsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutAdmissionsInput, DepartmentUpdateWithoutAdmissionsInput>, DepartmentUncheckedUpdateWithoutAdmissionsInput>
  }

  export type OpdVisitUpdateOneWithoutAdmissionNestedInput = {
    create?: XOR<OpdVisitCreateWithoutAdmissionInput, OpdVisitUncheckedCreateWithoutAdmissionInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutAdmissionInput
    upsert?: OpdVisitUpsertWithoutAdmissionInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutAdmissionInput, OpdVisitUpdateWithoutAdmissionInput>, OpdVisitUncheckedUpdateWithoutAdmissionInput>
  }

  export type BedUpdateOneWithoutActiveAdmissionsNestedInput = {
    create?: XOR<BedCreateWithoutActiveAdmissionsInput, BedUncheckedCreateWithoutActiveAdmissionsInput>
    connectOrCreate?: BedCreateOrConnectWithoutActiveAdmissionsInput
    upsert?: BedUpsertWithoutActiveAdmissionsInput
    disconnect?: BedWhereInput | boolean
    delete?: BedWhereInput | boolean
    connect?: BedWhereUniqueInput
    update?: XOR<XOR<BedUpdateToOneWithWhereWithoutActiveAdmissionsInput, BedUpdateWithoutActiveAdmissionsInput>, BedUncheckedUpdateWithoutActiveAdmissionsInput>
  }

  export type BedTransferUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput> | BedTransferCreateWithoutAdmissionInput[] | BedTransferUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutAdmissionInput | BedTransferCreateOrConnectWithoutAdmissionInput[]
    upsert?: BedTransferUpsertWithWhereUniqueWithoutAdmissionInput | BedTransferUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: BedTransferCreateManyAdmissionInputEnvelope
    set?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    disconnect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    delete?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    update?: BedTransferUpdateWithWhereUniqueWithoutAdmissionInput | BedTransferUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: BedTransferUpdateManyWithWhereWithoutAdmissionInput | BedTransferUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
  }

  export type SurgeryUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput> | SurgeryCreateWithoutAdmissionInput[] | SurgeryUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutAdmissionInput | SurgeryCreateOrConnectWithoutAdmissionInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutAdmissionInput | SurgeryUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: SurgeryCreateManyAdmissionInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutAdmissionInput | SurgeryUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutAdmissionInput | SurgeryUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type ClinicalNoteUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput> | ClinicalNoteCreateWithoutAdmissionInput[] | ClinicalNoteUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAdmissionInput | ClinicalNoteCreateOrConnectWithoutAdmissionInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutAdmissionInput | ClinicalNoteUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: ClinicalNoteCreateManyAdmissionInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutAdmissionInput | ClinicalNoteUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutAdmissionInput | ClinicalNoteUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput> | ServiceOrderCreateWithoutAdmissionInput[] | ServiceOrderUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutAdmissionInput | ServiceOrderCreateOrConnectWithoutAdmissionInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutAdmissionInput | ServiceOrderUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: ServiceOrderCreateManyAdmissionInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutAdmissionInput | ServiceOrderUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutAdmissionInput | ServiceOrderUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput> | PrescriptionCreateWithoutAdmissionInput[] | PrescriptionUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAdmissionInput | PrescriptionCreateOrConnectWithoutAdmissionInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutAdmissionInput | PrescriptionUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: PrescriptionCreateManyAdmissionInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutAdmissionInput | PrescriptionUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutAdmissionInput | PrescriptionUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PatientDocumentUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput> | PatientDocumentCreateWithoutAdmissionInput[] | PatientDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutAdmissionInput | PatientDocumentCreateOrConnectWithoutAdmissionInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutAdmissionInput | PatientDocumentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: PatientDocumentCreateManyAdmissionInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutAdmissionInput | PatientDocumentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutAdmissionInput | PatientDocumentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput> | InvoiceCreateWithoutAdmissionInput[] | InvoiceUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAdmissionInput | InvoiceCreateOrConnectWithoutAdmissionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAdmissionInput | InvoiceUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: InvoiceCreateManyAdmissionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAdmissionInput | InvoiceUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAdmissionInput | InvoiceUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InsuranceClaimUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput> | InsuranceClaimCreateWithoutAdmissionInput[] | InsuranceClaimUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutAdmissionInput | InsuranceClaimCreateOrConnectWithoutAdmissionInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutAdmissionInput | InsuranceClaimUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: InsuranceClaimCreateManyAdmissionInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutAdmissionInput | InsuranceClaimUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutAdmissionInput | InsuranceClaimUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput> | BedTransferCreateWithoutAdmissionInput[] | BedTransferUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: BedTransferCreateOrConnectWithoutAdmissionInput | BedTransferCreateOrConnectWithoutAdmissionInput[]
    upsert?: BedTransferUpsertWithWhereUniqueWithoutAdmissionInput | BedTransferUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: BedTransferCreateManyAdmissionInputEnvelope
    set?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    disconnect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    delete?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    connect?: BedTransferWhereUniqueInput | BedTransferWhereUniqueInput[]
    update?: BedTransferUpdateWithWhereUniqueWithoutAdmissionInput | BedTransferUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: BedTransferUpdateManyWithWhereWithoutAdmissionInput | BedTransferUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
  }

  export type SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput> | SurgeryCreateWithoutAdmissionInput[] | SurgeryUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: SurgeryCreateOrConnectWithoutAdmissionInput | SurgeryCreateOrConnectWithoutAdmissionInput[]
    upsert?: SurgeryUpsertWithWhereUniqueWithoutAdmissionInput | SurgeryUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: SurgeryCreateManyAdmissionInputEnvelope
    set?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    disconnect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    delete?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    connect?: SurgeryWhereUniqueInput | SurgeryWhereUniqueInput[]
    update?: SurgeryUpdateWithWhereUniqueWithoutAdmissionInput | SurgeryUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: SurgeryUpdateManyWithWhereWithoutAdmissionInput | SurgeryUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput> | ClinicalNoteCreateWithoutAdmissionInput[] | ClinicalNoteUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ClinicalNoteCreateOrConnectWithoutAdmissionInput | ClinicalNoteCreateOrConnectWithoutAdmissionInput[]
    upsert?: ClinicalNoteUpsertWithWhereUniqueWithoutAdmissionInput | ClinicalNoteUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: ClinicalNoteCreateManyAdmissionInputEnvelope
    set?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    disconnect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    delete?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    connect?: ClinicalNoteWhereUniqueInput | ClinicalNoteWhereUniqueInput[]
    update?: ClinicalNoteUpdateWithWhereUniqueWithoutAdmissionInput | ClinicalNoteUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: ClinicalNoteUpdateManyWithWhereWithoutAdmissionInput | ClinicalNoteUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
  }

  export type ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput> | ServiceOrderCreateWithoutAdmissionInput[] | ServiceOrderUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutAdmissionInput | ServiceOrderCreateOrConnectWithoutAdmissionInput[]
    upsert?: ServiceOrderUpsertWithWhereUniqueWithoutAdmissionInput | ServiceOrderUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: ServiceOrderCreateManyAdmissionInputEnvelope
    set?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    disconnect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    delete?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    connect?: ServiceOrderWhereUniqueInput | ServiceOrderWhereUniqueInput[]
    update?: ServiceOrderUpdateWithWhereUniqueWithoutAdmissionInput | ServiceOrderUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: ServiceOrderUpdateManyWithWhereWithoutAdmissionInput | ServiceOrderUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
  }

  export type PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput> | PrescriptionCreateWithoutAdmissionInput[] | PrescriptionUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAdmissionInput | PrescriptionCreateOrConnectWithoutAdmissionInput[]
    upsert?: PrescriptionUpsertWithWhereUniqueWithoutAdmissionInput | PrescriptionUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: PrescriptionCreateManyAdmissionInputEnvelope
    set?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    disconnect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    delete?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    connect?: PrescriptionWhereUniqueInput | PrescriptionWhereUniqueInput[]
    update?: PrescriptionUpdateWithWhereUniqueWithoutAdmissionInput | PrescriptionUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: PrescriptionUpdateManyWithWhereWithoutAdmissionInput | PrescriptionUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
  }

  export type PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput> | PatientDocumentCreateWithoutAdmissionInput[] | PatientDocumentUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: PatientDocumentCreateOrConnectWithoutAdmissionInput | PatientDocumentCreateOrConnectWithoutAdmissionInput[]
    upsert?: PatientDocumentUpsertWithWhereUniqueWithoutAdmissionInput | PatientDocumentUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: PatientDocumentCreateManyAdmissionInputEnvelope
    set?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    disconnect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    delete?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    connect?: PatientDocumentWhereUniqueInput | PatientDocumentWhereUniqueInput[]
    update?: PatientDocumentUpdateWithWhereUniqueWithoutAdmissionInput | PatientDocumentUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: PatientDocumentUpdateManyWithWhereWithoutAdmissionInput | PatientDocumentUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput> | InvoiceCreateWithoutAdmissionInput[] | InvoiceUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutAdmissionInput | InvoiceCreateOrConnectWithoutAdmissionInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutAdmissionInput | InvoiceUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: InvoiceCreateManyAdmissionInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutAdmissionInput | InvoiceUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutAdmissionInput | InvoiceUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput = {
    create?: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput> | InsuranceClaimCreateWithoutAdmissionInput[] | InsuranceClaimUncheckedCreateWithoutAdmissionInput[]
    connectOrCreate?: InsuranceClaimCreateOrConnectWithoutAdmissionInput | InsuranceClaimCreateOrConnectWithoutAdmissionInput[]
    upsert?: InsuranceClaimUpsertWithWhereUniqueWithoutAdmissionInput | InsuranceClaimUpsertWithWhereUniqueWithoutAdmissionInput[]
    createMany?: InsuranceClaimCreateManyAdmissionInputEnvelope
    set?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    disconnect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    delete?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    connect?: InsuranceClaimWhereUniqueInput | InsuranceClaimWhereUniqueInput[]
    update?: InsuranceClaimUpdateWithWhereUniqueWithoutAdmissionInput | InsuranceClaimUpdateWithWhereUniqueWithoutAdmissionInput[]
    updateMany?: InsuranceClaimUpdateManyWithWhereWithoutAdmissionInput | InsuranceClaimUpdateManyWithWhereWithoutAdmissionInput[]
    deleteMany?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
  }

  export type AdmissionCreateNestedOneWithoutBedTransfersInput = {
    create?: XOR<AdmissionCreateWithoutBedTransfersInput, AdmissionUncheckedCreateWithoutBedTransfersInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedTransfersInput
    connect?: AdmissionWhereUniqueInput
  }

  export type BedCreateNestedOneWithoutTransfersInput = {
    create?: XOR<BedCreateWithoutTransfersInput, BedUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: BedCreateOrConnectWithoutTransfersInput
    connect?: BedWhereUniqueInput
  }

  export type AdmissionUpdateOneRequiredWithoutBedTransfersNestedInput = {
    create?: XOR<AdmissionCreateWithoutBedTransfersInput, AdmissionUncheckedCreateWithoutBedTransfersInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutBedTransfersInput
    upsert?: AdmissionUpsertWithoutBedTransfersInput
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutBedTransfersInput, AdmissionUpdateWithoutBedTransfersInput>, AdmissionUncheckedUpdateWithoutBedTransfersInput>
  }

  export type BedUpdateOneRequiredWithoutTransfersNestedInput = {
    create?: XOR<BedCreateWithoutTransfersInput, BedUncheckedCreateWithoutTransfersInput>
    connectOrCreate?: BedCreateOrConnectWithoutTransfersInput
    upsert?: BedUpsertWithoutTransfersInput
    connect?: BedWhereUniqueInput
    update?: XOR<XOR<BedUpdateToOneWithWhereWithoutTransfersInput, BedUpdateWithoutTransfersInput>, BedUncheckedUpdateWithoutTransfersInput>
  }

  export type AdmissionCreateNestedOneWithoutSurgeriesInput = {
    create?: XOR<AdmissionCreateWithoutSurgeriesInput, AdmissionUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutSurgeriesInput
    connect?: AdmissionWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutSurgeriesInput = {
    create?: XOR<StaffProfileCreateWithoutSurgeriesInput, StaffProfileUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSurgeriesInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type SurgicalChecklistCreateNestedManyWithoutSurgeryInput = {
    create?: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput> | SurgicalChecklistCreateWithoutSurgeryInput[] | SurgicalChecklistUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgicalChecklistCreateOrConnectWithoutSurgeryInput | SurgicalChecklistCreateOrConnectWithoutSurgeryInput[]
    createMany?: SurgicalChecklistCreateManySurgeryInputEnvelope
    connect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
  }

  export type SurgerySStaffCreateNestedManyWithoutSurgeryInput = {
    create?: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput> | SurgerySStaffCreateWithoutSurgeryInput[] | SurgerySStaffUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutSurgeryInput | SurgerySStaffCreateOrConnectWithoutSurgeryInput[]
    createMany?: SurgerySStaffCreateManySurgeryInputEnvelope
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
  }

  export type SurgicalChecklistUncheckedCreateNestedManyWithoutSurgeryInput = {
    create?: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput> | SurgicalChecklistCreateWithoutSurgeryInput[] | SurgicalChecklistUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgicalChecklistCreateOrConnectWithoutSurgeryInput | SurgicalChecklistCreateOrConnectWithoutSurgeryInput[]
    createMany?: SurgicalChecklistCreateManySurgeryInputEnvelope
    connect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
  }

  export type SurgerySStaffUncheckedCreateNestedManyWithoutSurgeryInput = {
    create?: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput> | SurgerySStaffCreateWithoutSurgeryInput[] | SurgerySStaffUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutSurgeryInput | SurgerySStaffCreateOrConnectWithoutSurgeryInput[]
    createMany?: SurgerySStaffCreateManySurgeryInputEnvelope
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
  }

  export type EnumSurgeryStatusFieldUpdateOperationsInput = {
    set?: $Enums.SurgeryStatus
  }

  export type AdmissionUpdateOneRequiredWithoutSurgeriesNestedInput = {
    create?: XOR<AdmissionCreateWithoutSurgeriesInput, AdmissionUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutSurgeriesInput
    upsert?: AdmissionUpsertWithoutSurgeriesInput
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutSurgeriesInput, AdmissionUpdateWithoutSurgeriesInput>, AdmissionUncheckedUpdateWithoutSurgeriesInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutSurgeriesNestedInput = {
    create?: XOR<StaffProfileCreateWithoutSurgeriesInput, StaffProfileUncheckedCreateWithoutSurgeriesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSurgeriesInput
    upsert?: StaffProfileUpsertWithoutSurgeriesInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutSurgeriesInput, StaffProfileUpdateWithoutSurgeriesInput>, StaffProfileUncheckedUpdateWithoutSurgeriesInput>
  }

  export type SurgicalChecklistUpdateManyWithoutSurgeryNestedInput = {
    create?: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput> | SurgicalChecklistCreateWithoutSurgeryInput[] | SurgicalChecklistUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgicalChecklistCreateOrConnectWithoutSurgeryInput | SurgicalChecklistCreateOrConnectWithoutSurgeryInput[]
    upsert?: SurgicalChecklistUpsertWithWhereUniqueWithoutSurgeryInput | SurgicalChecklistUpsertWithWhereUniqueWithoutSurgeryInput[]
    createMany?: SurgicalChecklistCreateManySurgeryInputEnvelope
    set?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    disconnect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    delete?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    connect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    update?: SurgicalChecklistUpdateWithWhereUniqueWithoutSurgeryInput | SurgicalChecklistUpdateWithWhereUniqueWithoutSurgeryInput[]
    updateMany?: SurgicalChecklistUpdateManyWithWhereWithoutSurgeryInput | SurgicalChecklistUpdateManyWithWhereWithoutSurgeryInput[]
    deleteMany?: SurgicalChecklistScalarWhereInput | SurgicalChecklistScalarWhereInput[]
  }

  export type SurgerySStaffUpdateManyWithoutSurgeryNestedInput = {
    create?: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput> | SurgerySStaffCreateWithoutSurgeryInput[] | SurgerySStaffUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutSurgeryInput | SurgerySStaffCreateOrConnectWithoutSurgeryInput[]
    upsert?: SurgerySStaffUpsertWithWhereUniqueWithoutSurgeryInput | SurgerySStaffUpsertWithWhereUniqueWithoutSurgeryInput[]
    createMany?: SurgerySStaffCreateManySurgeryInputEnvelope
    set?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    disconnect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    delete?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    update?: SurgerySStaffUpdateWithWhereUniqueWithoutSurgeryInput | SurgerySStaffUpdateWithWhereUniqueWithoutSurgeryInput[]
    updateMany?: SurgerySStaffUpdateManyWithWhereWithoutSurgeryInput | SurgerySStaffUpdateManyWithWhereWithoutSurgeryInput[]
    deleteMany?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
  }

  export type SurgicalChecklistUncheckedUpdateManyWithoutSurgeryNestedInput = {
    create?: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput> | SurgicalChecklistCreateWithoutSurgeryInput[] | SurgicalChecklistUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgicalChecklistCreateOrConnectWithoutSurgeryInput | SurgicalChecklistCreateOrConnectWithoutSurgeryInput[]
    upsert?: SurgicalChecklistUpsertWithWhereUniqueWithoutSurgeryInput | SurgicalChecklistUpsertWithWhereUniqueWithoutSurgeryInput[]
    createMany?: SurgicalChecklistCreateManySurgeryInputEnvelope
    set?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    disconnect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    delete?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    connect?: SurgicalChecklistWhereUniqueInput | SurgicalChecklistWhereUniqueInput[]
    update?: SurgicalChecklistUpdateWithWhereUniqueWithoutSurgeryInput | SurgicalChecklistUpdateWithWhereUniqueWithoutSurgeryInput[]
    updateMany?: SurgicalChecklistUpdateManyWithWhereWithoutSurgeryInput | SurgicalChecklistUpdateManyWithWhereWithoutSurgeryInput[]
    deleteMany?: SurgicalChecklistScalarWhereInput | SurgicalChecklistScalarWhereInput[]
  }

  export type SurgerySStaffUncheckedUpdateManyWithoutSurgeryNestedInput = {
    create?: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput> | SurgerySStaffCreateWithoutSurgeryInput[] | SurgerySStaffUncheckedCreateWithoutSurgeryInput[]
    connectOrCreate?: SurgerySStaffCreateOrConnectWithoutSurgeryInput | SurgerySStaffCreateOrConnectWithoutSurgeryInput[]
    upsert?: SurgerySStaffUpsertWithWhereUniqueWithoutSurgeryInput | SurgerySStaffUpsertWithWhereUniqueWithoutSurgeryInput[]
    createMany?: SurgerySStaffCreateManySurgeryInputEnvelope
    set?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    disconnect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    delete?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    connect?: SurgerySStaffWhereUniqueInput | SurgerySStaffWhereUniqueInput[]
    update?: SurgerySStaffUpdateWithWhereUniqueWithoutSurgeryInput | SurgerySStaffUpdateWithWhereUniqueWithoutSurgeryInput[]
    updateMany?: SurgerySStaffUpdateManyWithWhereWithoutSurgeryInput | SurgerySStaffUpdateManyWithWhereWithoutSurgeryInput[]
    deleteMany?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
  }

  export type SurgeryCreateNestedOneWithoutSurgerySStaffsInput = {
    create?: XOR<SurgeryCreateWithoutSurgerySStaffsInput, SurgeryUncheckedCreateWithoutSurgerySStaffsInput>
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgerySStaffsInput
    connect?: SurgeryWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutSurgerySStaffsInput = {
    create?: XOR<StaffProfileCreateWithoutSurgerySStaffsInput, StaffProfileUncheckedCreateWithoutSurgerySStaffsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSurgerySStaffsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type SurgeryUpdateOneRequiredWithoutSurgerySStaffsNestedInput = {
    create?: XOR<SurgeryCreateWithoutSurgerySStaffsInput, SurgeryUncheckedCreateWithoutSurgerySStaffsInput>
    connectOrCreate?: SurgeryCreateOrConnectWithoutSurgerySStaffsInput
    upsert?: SurgeryUpsertWithoutSurgerySStaffsInput
    connect?: SurgeryWhereUniqueInput
    update?: XOR<XOR<SurgeryUpdateToOneWithWhereWithoutSurgerySStaffsInput, SurgeryUpdateWithoutSurgerySStaffsInput>, SurgeryUncheckedUpdateWithoutSurgerySStaffsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutSurgerySStaffsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutSurgerySStaffsInput, StaffProfileUncheckedCreateWithoutSurgerySStaffsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSurgerySStaffsInput
    upsert?: StaffProfileUpsertWithoutSurgerySStaffsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutSurgerySStaffsInput, StaffProfileUpdateWithoutSurgerySStaffsInput>, StaffProfileUncheckedUpdateWithoutSurgerySStaffsInput>
  }

  export type SurgeryCreateNestedOneWithoutChecklistsInput = {
    create?: XOR<SurgeryCreateWithoutChecklistsInput, SurgeryUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: SurgeryCreateOrConnectWithoutChecklistsInput
    connect?: SurgeryWhereUniqueInput
  }

  export type EnumChecklistStageFieldUpdateOperationsInput = {
    set?: $Enums.ChecklistStage
  }

  export type SurgeryUpdateOneRequiredWithoutChecklistsNestedInput = {
    create?: XOR<SurgeryCreateWithoutChecklistsInput, SurgeryUncheckedCreateWithoutChecklistsInput>
    connectOrCreate?: SurgeryCreateOrConnectWithoutChecklistsInput
    upsert?: SurgeryUpsertWithoutChecklistsInput
    connect?: SurgeryWhereUniqueInput
    update?: XOR<XOR<SurgeryUpdateToOneWithWhereWithoutChecklistsInput, SurgeryUpdateWithoutChecklistsInput>, SurgeryUncheckedUpdateWithoutChecklistsInput>
  }

  export type PatientCreateNestedOneWithoutClinicalNotesInput = {
    create?: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutClinicalNotesInput
    connect?: PatientWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutClinicalNotesInput = {
    create?: XOR<OpdVisitCreateWithoutClinicalNotesInput, OpdVisitUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutClinicalNotesInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type AdmissionCreateNestedOneWithoutClinicalNotesInput = {
    create?: XOR<AdmissionCreateWithoutClinicalNotesInput, AdmissionUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutClinicalNotesInput
    connect?: AdmissionWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutClinicalNotesInput = {
    create?: XOR<StaffProfileCreateWithoutClinicalNotesInput, StaffProfileUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClinicalNotesInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type EnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType
  }

  export type PatientUpdateOneRequiredWithoutClinicalNotesNestedInput = {
    create?: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutClinicalNotesInput
    upsert?: PatientUpsertWithoutClinicalNotesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutClinicalNotesInput, PatientUpdateWithoutClinicalNotesInput>, PatientUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type OpdVisitUpdateOneWithoutClinicalNotesNestedInput = {
    create?: XOR<OpdVisitCreateWithoutClinicalNotesInput, OpdVisitUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutClinicalNotesInput
    upsert?: OpdVisitUpsertWithoutClinicalNotesInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutClinicalNotesInput, OpdVisitUpdateWithoutClinicalNotesInput>, OpdVisitUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type AdmissionUpdateOneWithoutClinicalNotesNestedInput = {
    create?: XOR<AdmissionCreateWithoutClinicalNotesInput, AdmissionUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutClinicalNotesInput
    upsert?: AdmissionUpsertWithoutClinicalNotesInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutClinicalNotesInput, AdmissionUpdateWithoutClinicalNotesInput>, AdmissionUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutClinicalNotesNestedInput = {
    create?: XOR<StaffProfileCreateWithoutClinicalNotesInput, StaffProfileUncheckedCreateWithoutClinicalNotesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClinicalNotesInput
    upsert?: StaffProfileUpsertWithoutClinicalNotesInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutClinicalNotesInput, StaffProfileUpdateWithoutClinicalNotesInput>, StaffProfileUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type PatientCreateNestedOneWithoutServiceOrdersInput = {
    create?: XOR<PatientCreateWithoutServiceOrdersInput, PatientUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutServiceOrdersInput
    connect?: PatientWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutServiceOrdersInput = {
    create?: XOR<StaffProfileCreateWithoutServiceOrdersInput, StaffProfileUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutServiceOrdersInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutServiceOrdersInput = {
    create?: XOR<OpdVisitCreateWithoutServiceOrdersInput, OpdVisitUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutServiceOrdersInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type AdmissionCreateNestedOneWithoutServiceOrdersInput = {
    create?: XOR<AdmissionCreateWithoutServiceOrdersInput, AdmissionUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutServiceOrdersInput
    connect?: AdmissionWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutServiceOrdersInput = {
    create?: XOR<ServiceCreateWithoutServiceOrdersInput, ServiceUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceOrdersInput
    connect?: ServiceWhereUniqueInput
  }

  export type LabResultCreateNestedManyWithoutServiceOrderInput = {
    create?: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput> | LabResultCreateWithoutServiceOrderInput[] | LabResultUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceOrderInput | LabResultCreateOrConnectWithoutServiceOrderInput[]
    createMany?: LabResultCreateManyServiceOrderInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type InvoiceItemCreateNestedManyWithoutServiceOrderInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput> | InvoiceItemCreateWithoutServiceOrderInput[] | InvoiceItemUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceOrderInput | InvoiceItemCreateOrConnectWithoutServiceOrderInput[]
    createMany?: InvoiceItemCreateManyServiceOrderInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type LabResultUncheckedCreateNestedManyWithoutServiceOrderInput = {
    create?: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput> | LabResultCreateWithoutServiceOrderInput[] | LabResultUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceOrderInput | LabResultCreateOrConnectWithoutServiceOrderInput[]
    createMany?: LabResultCreateManyServiceOrderInputEnvelope
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput> | InvoiceItemCreateWithoutServiceOrderInput[] | InvoiceItemUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceOrderInput | InvoiceItemCreateOrConnectWithoutServiceOrderInput[]
    createMany?: InvoiceItemCreateManyServiceOrderInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumOrderTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderType
  }

  export type EnumOrderPriorityFieldUpdateOperationsInput = {
    set?: $Enums.OrderPriority
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type PatientUpdateOneRequiredWithoutServiceOrdersNestedInput = {
    create?: XOR<PatientCreateWithoutServiceOrdersInput, PatientUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: PatientCreateOrConnectWithoutServiceOrdersInput
    upsert?: PatientUpsertWithoutServiceOrdersInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutServiceOrdersInput, PatientUpdateWithoutServiceOrdersInput>, PatientUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput = {
    create?: XOR<StaffProfileCreateWithoutServiceOrdersInput, StaffProfileUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutServiceOrdersInput
    upsert?: StaffProfileUpsertWithoutServiceOrdersInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutServiceOrdersInput, StaffProfileUpdateWithoutServiceOrdersInput>, StaffProfileUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type OpdVisitUpdateOneWithoutServiceOrdersNestedInput = {
    create?: XOR<OpdVisitCreateWithoutServiceOrdersInput, OpdVisitUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutServiceOrdersInput
    upsert?: OpdVisitUpsertWithoutServiceOrdersInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutServiceOrdersInput, OpdVisitUpdateWithoutServiceOrdersInput>, OpdVisitUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type AdmissionUpdateOneWithoutServiceOrdersNestedInput = {
    create?: XOR<AdmissionCreateWithoutServiceOrdersInput, AdmissionUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutServiceOrdersInput
    upsert?: AdmissionUpsertWithoutServiceOrdersInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutServiceOrdersInput, AdmissionUpdateWithoutServiceOrdersInput>, AdmissionUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceOrdersInput, ServiceUncheckedCreateWithoutServiceOrdersInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceOrdersInput
    upsert?: ServiceUpsertWithoutServiceOrdersInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceOrdersInput, ServiceUpdateWithoutServiceOrdersInput>, ServiceUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type LabResultUpdateManyWithoutServiceOrderNestedInput = {
    create?: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput> | LabResultCreateWithoutServiceOrderInput[] | LabResultUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceOrderInput | LabResultCreateOrConnectWithoutServiceOrderInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutServiceOrderInput | LabResultUpsertWithWhereUniqueWithoutServiceOrderInput[]
    createMany?: LabResultCreateManyServiceOrderInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutServiceOrderInput | LabResultUpdateWithWhereUniqueWithoutServiceOrderInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutServiceOrderInput | LabResultUpdateManyWithWhereWithoutServiceOrderInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type InvoiceItemUpdateManyWithoutServiceOrderNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput> | InvoiceItemCreateWithoutServiceOrderInput[] | InvoiceItemUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceOrderInput | InvoiceItemCreateOrConnectWithoutServiceOrderInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceOrderInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceOrderInput[]
    createMany?: InvoiceItemCreateManyServiceOrderInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceOrderInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceOrderInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceOrderInput | InvoiceItemUpdateManyWithWhereWithoutServiceOrderInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput = {
    create?: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput> | LabResultCreateWithoutServiceOrderInput[] | LabResultUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: LabResultCreateOrConnectWithoutServiceOrderInput | LabResultCreateOrConnectWithoutServiceOrderInput[]
    upsert?: LabResultUpsertWithWhereUniqueWithoutServiceOrderInput | LabResultUpsertWithWhereUniqueWithoutServiceOrderInput[]
    createMany?: LabResultCreateManyServiceOrderInputEnvelope
    set?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    disconnect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    delete?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    connect?: LabResultWhereUniqueInput | LabResultWhereUniqueInput[]
    update?: LabResultUpdateWithWhereUniqueWithoutServiceOrderInput | LabResultUpdateWithWhereUniqueWithoutServiceOrderInput[]
    updateMany?: LabResultUpdateManyWithWhereWithoutServiceOrderInput | LabResultUpdateManyWithWhereWithoutServiceOrderInput[]
    deleteMany?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput> | InvoiceItemCreateWithoutServiceOrderInput[] | InvoiceItemUncheckedCreateWithoutServiceOrderInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutServiceOrderInput | InvoiceItemCreateOrConnectWithoutServiceOrderInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutServiceOrderInput | InvoiceItemUpsertWithWhereUniqueWithoutServiceOrderInput[]
    createMany?: InvoiceItemCreateManyServiceOrderInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutServiceOrderInput | InvoiceItemUpdateWithWhereUniqueWithoutServiceOrderInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutServiceOrderInput | InvoiceItemUpdateManyWithWhereWithoutServiceOrderInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type ServiceOrderCreateNestedOneWithoutLabResultsInput = {
    create?: XOR<ServiceOrderCreateWithoutLabResultsInput, ServiceOrderUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutLabResultsInput
    connect?: ServiceOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLabResultsInput = {
    create?: XOR<UserCreateWithoutLabResultsInput, UserUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabResultsInput
    connect?: UserWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutVerifiedResultsInput = {
    create?: XOR<StaffProfileCreateWithoutVerifiedResultsInput, StaffProfileUncheckedCreateWithoutVerifiedResultsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutVerifiedResultsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ServiceOrderUpdateOneRequiredWithoutLabResultsNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutLabResultsInput, ServiceOrderUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutLabResultsInput
    upsert?: ServiceOrderUpsertWithoutLabResultsInput
    connect?: ServiceOrderWhereUniqueInput
    update?: XOR<XOR<ServiceOrderUpdateToOneWithWhereWithoutLabResultsInput, ServiceOrderUpdateWithoutLabResultsInput>, ServiceOrderUncheckedUpdateWithoutLabResultsInput>
  }

  export type UserUpdateOneWithoutLabResultsNestedInput = {
    create?: XOR<UserCreateWithoutLabResultsInput, UserUncheckedCreateWithoutLabResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabResultsInput
    upsert?: UserUpsertWithoutLabResultsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabResultsInput, UserUpdateWithoutLabResultsInput>, UserUncheckedUpdateWithoutLabResultsInput>
  }

  export type StaffProfileUpdateOneWithoutVerifiedResultsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutVerifiedResultsInput, StaffProfileUncheckedCreateWithoutVerifiedResultsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutVerifiedResultsInput
    upsert?: StaffProfileUpsertWithoutVerifiedResultsInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutVerifiedResultsInput, StaffProfileUpdateWithoutVerifiedResultsInput>, StaffProfileUncheckedUpdateWithoutVerifiedResultsInput>
  }

  export type PatientCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<StaffProfileCreateWithoutPrescriptionsInput, StaffProfileUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutPrescriptionsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<OpdVisitCreateWithoutPrescriptionsInput, OpdVisitUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPrescriptionsInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type AdmissionCreateNestedOneWithoutPrescriptionsInput = {
    create?: XOR<AdmissionCreateWithoutPrescriptionsInput, AdmissionUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutPrescriptionsInput
    connect?: AdmissionWhereUniqueInput
  }

  export type PrescriptionItemCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PharmacySaleCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput> | PharmacySaleCreateWithoutPrescriptionInput[] | PharmacySaleUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPrescriptionInput | PharmacySaleCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PharmacySaleCreateManyPrescriptionInputEnvelope
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput> | PharmacySaleCreateWithoutPrescriptionInput[] | PharmacySaleUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPrescriptionInput | PharmacySaleCreateOrConnectWithoutPrescriptionInput[]
    createMany?: PharmacySaleCreateManyPrescriptionInputEnvelope
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPrescriptionsInput
    upsert?: PatientUpsertWithoutPrescriptionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPrescriptionsInput, PatientUpdateWithoutPrescriptionsInput>, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutPrescriptionsInput, StaffProfileUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutPrescriptionsInput
    upsert?: StaffProfileUpsertWithoutPrescriptionsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutPrescriptionsInput, StaffProfileUpdateWithoutPrescriptionsInput>, StaffProfileUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type OpdVisitUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<OpdVisitCreateWithoutPrescriptionsInput, OpdVisitUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutPrescriptionsInput
    upsert?: OpdVisitUpsertWithoutPrescriptionsInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutPrescriptionsInput, OpdVisitUpdateWithoutPrescriptionsInput>, OpdVisitUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type AdmissionUpdateOneWithoutPrescriptionsNestedInput = {
    create?: XOR<AdmissionCreateWithoutPrescriptionsInput, AdmissionUncheckedCreateWithoutPrescriptionsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutPrescriptionsInput
    upsert?: AdmissionUpsertWithoutPrescriptionsInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutPrescriptionsInput, AdmissionUpdateWithoutPrescriptionsInput>, AdmissionUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PharmacySaleUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput> | PharmacySaleCreateWithoutPrescriptionInput[] | PharmacySaleUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPrescriptionInput | PharmacySaleCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PharmacySaleUpsertWithWhereUniqueWithoutPrescriptionInput | PharmacySaleUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PharmacySaleCreateManyPrescriptionInputEnvelope
    set?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    disconnect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    delete?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    update?: PharmacySaleUpdateWithWhereUniqueWithoutPrescriptionInput | PharmacySaleUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PharmacySaleUpdateManyWithWhereWithoutPrescriptionInput | PharmacySaleUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput> | PrescriptionItemCreateWithoutPrescriptionInput[] | PrescriptionItemUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutPrescriptionInput | PrescriptionItemCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PrescriptionItemCreateManyPrescriptionInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput | PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput | PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput> | PharmacySaleCreateWithoutPrescriptionInput[] | PharmacySaleUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutPrescriptionInput | PharmacySaleCreateOrConnectWithoutPrescriptionInput[]
    upsert?: PharmacySaleUpsertWithWhereUniqueWithoutPrescriptionInput | PharmacySaleUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: PharmacySaleCreateManyPrescriptionInputEnvelope
    set?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    disconnect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    delete?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    connect?: PharmacySaleWhereUniqueInput | PharmacySaleWhereUniqueInput[]
    update?: PharmacySaleUpdateWithWhereUniqueWithoutPrescriptionInput | PharmacySaleUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: PharmacySaleUpdateManyWithWhereWithoutPrescriptionInput | PharmacySaleUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
  }

  export type PrescriptionCreateNestedOneWithoutItemsInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutPrescriptionItemsInput = {
    create?: XOR<MedicineCreateWithoutPrescriptionItemsInput, MedicineUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutPrescriptionItemsInput
    connect?: MedicineWhereUniqueInput
  }

  export type PrescriptionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutItemsInput
    upsert?: PrescriptionUpsertWithoutItemsInput
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutItemsInput, PrescriptionUpdateWithoutItemsInput>, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type MedicineUpdateOneRequiredWithoutPrescriptionItemsNestedInput = {
    create?: XOR<MedicineCreateWithoutPrescriptionItemsInput, MedicineUncheckedCreateWithoutPrescriptionItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutPrescriptionItemsInput
    upsert?: MedicineUpsertWithoutPrescriptionItemsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutPrescriptionItemsInput, MedicineUpdateWithoutPrescriptionItemsInput>, MedicineUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionItemCreateNestedManyWithoutMedicineInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput> | PrescriptionItemCreateWithoutMedicineInput[] | PrescriptionItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicineInput | PrescriptionItemCreateOrConnectWithoutMedicineInput[]
    createMany?: PrescriptionItemCreateManyMedicineInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type SaleItemCreateNestedManyWithoutMedicineInput = {
    create?: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput> | SaleItemCreateWithoutMedicineInput[] | SaleItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutMedicineInput | SaleItemCreateOrConnectWithoutMedicineInput[]
    createMany?: SaleItemCreateManyMedicineInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PrescriptionItemUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput> | PrescriptionItemCreateWithoutMedicineInput[] | PrescriptionItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicineInput | PrescriptionItemCreateOrConnectWithoutMedicineInput[]
    createMany?: PrescriptionItemCreateManyMedicineInputEnvelope
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput> | SaleItemCreateWithoutMedicineInput[] | SaleItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutMedicineInput | SaleItemCreateOrConnectWithoutMedicineInput[]
    createMany?: SaleItemCreateManyMedicineInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PrescriptionItemUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput> | PrescriptionItemCreateWithoutMedicineInput[] | PrescriptionItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicineInput | PrescriptionItemCreateOrConnectWithoutMedicineInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutMedicineInput | PrescriptionItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: PrescriptionItemCreateManyMedicineInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutMedicineInput | PrescriptionItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutMedicineInput | PrescriptionItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type SaleItemUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput> | SaleItemCreateWithoutMedicineInput[] | SaleItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutMedicineInput | SaleItemCreateOrConnectWithoutMedicineInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutMedicineInput | SaleItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: SaleItemCreateManyMedicineInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutMedicineInput | SaleItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutMedicineInput | SaleItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput> | PrescriptionItemCreateWithoutMedicineInput[] | PrescriptionItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: PrescriptionItemCreateOrConnectWithoutMedicineInput | PrescriptionItemCreateOrConnectWithoutMedicineInput[]
    upsert?: PrescriptionItemUpsertWithWhereUniqueWithoutMedicineInput | PrescriptionItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: PrescriptionItemCreateManyMedicineInputEnvelope
    set?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    disconnect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    delete?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    connect?: PrescriptionItemWhereUniqueInput | PrescriptionItemWhereUniqueInput[]
    update?: PrescriptionItemUpdateWithWhereUniqueWithoutMedicineInput | PrescriptionItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: PrescriptionItemUpdateManyWithWhereWithoutMedicineInput | PrescriptionItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput> | SaleItemCreateWithoutMedicineInput[] | SaleItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutMedicineInput | SaleItemCreateOrConnectWithoutMedicineInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutMedicineInput | SaleItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: SaleItemCreateManyMedicineInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutMedicineInput | SaleItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutMedicineInput | SaleItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutPharmacySalesInput = {
    create?: XOR<PatientCreateWithoutPharmacySalesInput, PatientUncheckedCreateWithoutPharmacySalesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPharmacySalesInput
    connect?: PatientWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutSalesInput = {
    create?: XOR<PrescriptionCreateWithoutSalesInput, PrescriptionUncheckedCreateWithoutSalesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutSalesInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type SaleItemCreateNestedManyWithoutPharmacySaleInput = {
    create?: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput> | SaleItemCreateWithoutPharmacySaleInput[] | SaleItemUncheckedCreateWithoutPharmacySaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutPharmacySaleInput | SaleItemCreateOrConnectWithoutPharmacySaleInput[]
    createMany?: SaleItemCreateManyPharmacySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type SaleItemUncheckedCreateNestedManyWithoutPharmacySaleInput = {
    create?: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput> | SaleItemCreateWithoutPharmacySaleInput[] | SaleItemUncheckedCreateWithoutPharmacySaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutPharmacySaleInput | SaleItemCreateOrConnectWithoutPharmacySaleInput[]
    createMany?: SaleItemCreateManyPharmacySaleInputEnvelope
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutPharmacySalesNestedInput = {
    create?: XOR<PatientCreateWithoutPharmacySalesInput, PatientUncheckedCreateWithoutPharmacySalesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutPharmacySalesInput
    upsert?: PatientUpsertWithoutPharmacySalesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutPharmacySalesInput, PatientUpdateWithoutPharmacySalesInput>, PatientUncheckedUpdateWithoutPharmacySalesInput>
  }

  export type PrescriptionUpdateOneWithoutSalesNestedInput = {
    create?: XOR<PrescriptionCreateWithoutSalesInput, PrescriptionUncheckedCreateWithoutSalesInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutSalesInput
    upsert?: PrescriptionUpsertWithoutSalesInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutSalesInput, PrescriptionUpdateWithoutSalesInput>, PrescriptionUncheckedUpdateWithoutSalesInput>
  }

  export type SaleItemUpdateManyWithoutPharmacySaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput> | SaleItemCreateWithoutPharmacySaleInput[] | SaleItemUncheckedCreateWithoutPharmacySaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutPharmacySaleInput | SaleItemCreateOrConnectWithoutPharmacySaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutPharmacySaleInput | SaleItemUpsertWithWhereUniqueWithoutPharmacySaleInput[]
    createMany?: SaleItemCreateManyPharmacySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutPharmacySaleInput | SaleItemUpdateWithWhereUniqueWithoutPharmacySaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutPharmacySaleInput | SaleItemUpdateManyWithWhereWithoutPharmacySaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type SaleItemUncheckedUpdateManyWithoutPharmacySaleNestedInput = {
    create?: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput> | SaleItemCreateWithoutPharmacySaleInput[] | SaleItemUncheckedCreateWithoutPharmacySaleInput[]
    connectOrCreate?: SaleItemCreateOrConnectWithoutPharmacySaleInput | SaleItemCreateOrConnectWithoutPharmacySaleInput[]
    upsert?: SaleItemUpsertWithWhereUniqueWithoutPharmacySaleInput | SaleItemUpsertWithWhereUniqueWithoutPharmacySaleInput[]
    createMany?: SaleItemCreateManyPharmacySaleInputEnvelope
    set?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    disconnect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    delete?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    connect?: SaleItemWhereUniqueInput | SaleItemWhereUniqueInput[]
    update?: SaleItemUpdateWithWhereUniqueWithoutPharmacySaleInput | SaleItemUpdateWithWhereUniqueWithoutPharmacySaleInput[]
    updateMany?: SaleItemUpdateManyWithWhereWithoutPharmacySaleInput | SaleItemUpdateManyWithWhereWithoutPharmacySaleInput[]
    deleteMany?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
  }

  export type PharmacySaleCreateNestedOneWithoutItemsInput = {
    create?: XOR<PharmacySaleCreateWithoutItemsInput, PharmacySaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutItemsInput
    connect?: PharmacySaleWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutSaleItemsInput = {
    create?: XOR<MedicineCreateWithoutSaleItemsInput, MedicineUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutSaleItemsInput
    connect?: MedicineWhereUniqueInput
  }

  export type PharmacySaleUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PharmacySaleCreateWithoutItemsInput, PharmacySaleUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PharmacySaleCreateOrConnectWithoutItemsInput
    upsert?: PharmacySaleUpsertWithoutItemsInput
    connect?: PharmacySaleWhereUniqueInput
    update?: XOR<XOR<PharmacySaleUpdateToOneWithWhereWithoutItemsInput, PharmacySaleUpdateWithoutItemsInput>, PharmacySaleUncheckedUpdateWithoutItemsInput>
  }

  export type MedicineUpdateOneRequiredWithoutSaleItemsNestedInput = {
    create?: XOR<MedicineCreateWithoutSaleItemsInput, MedicineUncheckedCreateWithoutSaleItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutSaleItemsInput
    upsert?: MedicineUpsertWithoutSaleItemsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutSaleItemsInput, MedicineUpdateWithoutSaleItemsInput>, MedicineUncheckedUpdateWithoutSaleItemsInput>
  }

  export type PatientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
  }

  export type AdmissionCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<AdmissionCreateWithoutInvoicesInput, AdmissionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutInvoicesInput
    connect?: AdmissionWhereUniqueInput
  }

  export type OpdVisitCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<OpdVisitCreateWithoutInvoicesInput, OpdVisitUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutInvoicesInput
    connect?: OpdVisitWhereUniqueInput
  }

  export type InvoiceItemCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type PatientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: PatientCreateOrConnectWithoutInvoicesInput
    upsert?: PatientUpsertWithoutInvoicesInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutInvoicesInput, PatientUpdateWithoutInvoicesInput>, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type AdmissionUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<AdmissionCreateWithoutInvoicesInput, AdmissionUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutInvoicesInput
    upsert?: AdmissionUpsertWithoutInvoicesInput
    disconnect?: AdmissionWhereInput | boolean
    delete?: AdmissionWhereInput | boolean
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutInvoicesInput, AdmissionUpdateWithoutInvoicesInput>, AdmissionUncheckedUpdateWithoutInvoicesInput>
  }

  export type OpdVisitUpdateOneWithoutInvoicesNestedInput = {
    create?: XOR<OpdVisitCreateWithoutInvoicesInput, OpdVisitUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: OpdVisitCreateOrConnectWithoutInvoicesInput
    upsert?: OpdVisitUpsertWithoutInvoicesInput
    disconnect?: OpdVisitWhereInput | boolean
    delete?: OpdVisitWhereInput | boolean
    connect?: OpdVisitWhereUniqueInput
    update?: XOR<XOR<OpdVisitUpdateToOneWithWhereWithoutInvoicesInput, OpdVisitUpdateWithoutInvoicesInput>, OpdVisitUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceItemUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput> | InvoiceItemCreateWithoutInvoiceInput[] | InvoiceItemUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceItemCreateOrConnectWithoutInvoiceInput | InvoiceItemCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceItemCreateManyInvoiceInputEnvelope
    set?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    disconnect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    delete?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    connect?: InvoiceItemWhereUniqueInput | InvoiceItemWhereUniqueInput[]
    update?: InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceItemUpdateManyWithWhereWithoutInvoiceInput | InvoiceItemUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutItemsInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceOrderCreateNestedOneWithoutInvoiceItemsInput = {
    create?: XOR<ServiceOrderCreateWithoutInvoiceItemsInput, ServiceOrderUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutInvoiceItemsInput
    connect?: ServiceOrderWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutItemsInput
    upsert?: InvoiceUpsertWithoutItemsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutItemsInput, InvoiceUpdateWithoutItemsInput>, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type ServiceUpdateOneRequiredWithoutInvoiceItemsNestedInput = {
    create?: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ServiceUpsertWithoutInvoiceItemsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput, ServiceUpdateWithoutInvoiceItemsInput>, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ServiceOrderUpdateOneWithoutInvoiceItemsNestedInput = {
    create?: XOR<ServiceOrderCreateWithoutInvoiceItemsInput, ServiceOrderUncheckedCreateWithoutInvoiceItemsInput>
    connectOrCreate?: ServiceOrderCreateOrConnectWithoutInvoiceItemsInput
    upsert?: ServiceOrderUpsertWithoutInvoiceItemsInput
    disconnect?: ServiceOrderWhereInput | boolean
    delete?: ServiceOrderWhereInput | boolean
    connect?: ServiceOrderWhereUniqueInput
    update?: XOR<XOR<ServiceOrderUpdateToOneWithWhereWithoutInvoiceItemsInput, ServiceOrderUpdateWithoutInvoiceItemsInput>, ServiceOrderUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type AdmissionCreateNestedOneWithoutInsuranceClaimsInput = {
    create?: XOR<AdmissionCreateWithoutInsuranceClaimsInput, AdmissionUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutInsuranceClaimsInput
    connect?: AdmissionWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumClaimStatusFieldUpdateOperationsInput = {
    set?: $Enums.ClaimStatus
  }

  export type AdmissionUpdateOneRequiredWithoutInsuranceClaimsNestedInput = {
    create?: XOR<AdmissionCreateWithoutInsuranceClaimsInput, AdmissionUncheckedCreateWithoutInsuranceClaimsInput>
    connectOrCreate?: AdmissionCreateOrConnectWithoutInsuranceClaimsInput
    upsert?: AdmissionUpsertWithoutInsuranceClaimsInput
    connect?: AdmissionWhereUniqueInput
    update?: XOR<XOR<AdmissionUpdateToOneWithWhereWithoutInsuranceClaimsInput, AdmissionUpdateWithoutInsuranceClaimsInput>, AdmissionUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumDepartmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DepartmentType | EnumDepartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentTypeFilter<$PrismaModel> | $Enums.DepartmentType
  }

  export type NestedEnumDepartmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DepartmentType | EnumDepartmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DepartmentType[] | ListEnumDepartmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDepartmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DepartmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDepartmentTypeFilter<$PrismaModel>
    _max?: NestedEnumDepartmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBedStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BedStatus | EnumBedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStatusFilter<$PrismaModel> | $Enums.BedStatus
  }

  export type NestedEnumBedStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BedStatus | EnumBedStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BedStatus[] | ListEnumBedStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBedStatusWithAggregatesFilter<$PrismaModel> | $Enums.BedStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBedStatusFilter<$PrismaModel>
    _max?: NestedEnumBedStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumVisitTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeFilter<$PrismaModel> | $Enums.VisitType
  }

  export type NestedEnumTriageColorNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.TriageColor | EnumTriageColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriageColorNullableFilter<$PrismaModel> | $Enums.TriageColor | null
  }

  export type NestedEnumVisitStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusFilter<$PrismaModel> | $Enums.VisitStatus
  }

  export type NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitType | EnumVisitTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitType[] | ListEnumVisitTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitTypeWithAggregatesFilter<$PrismaModel> | $Enums.VisitType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitTypeFilter<$PrismaModel>
    _max?: NestedEnumVisitTypeFilter<$PrismaModel>
  }

  export type NestedEnumTriageColorNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TriageColor | EnumTriageColorFieldRefInput<$PrismaModel> | null
    in?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.TriageColor[] | ListEnumTriageColorFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTriageColorNullableWithAggregatesFilter<$PrismaModel> | $Enums.TriageColor | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTriageColorNullableFilter<$PrismaModel>
    _max?: NestedEnumTriageColorNullableFilter<$PrismaModel>
  }

  export type NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VisitStatus | EnumVisitStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VisitStatus[] | ListEnumVisitStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVisitStatusWithAggregatesFilter<$PrismaModel> | $Enums.VisitStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVisitStatusFilter<$PrismaModel>
    _max?: NestedEnumVisitStatusFilter<$PrismaModel>
  }

  export type NestedEnumAdmissionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionType | EnumAdmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionTypeFilter<$PrismaModel> | $Enums.AdmissionType
  }

  export type NestedEnumAdmissionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusFilter<$PrismaModel> | $Enums.AdmissionStatus
  }

  export type NestedEnumDischargeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.DischargeType | EnumDischargeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDischargeTypeNullableFilter<$PrismaModel> | $Enums.DischargeType | null
  }

  export type NestedEnumAdmissionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionType | EnumAdmissionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionType[] | ListEnumAdmissionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionTypeFilter<$PrismaModel>
    _max?: NestedEnumAdmissionTypeFilter<$PrismaModel>
  }

  export type NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdmissionStatus | EnumAdmissionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdmissionStatus[] | ListEnumAdmissionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAdmissionStatusWithAggregatesFilter<$PrismaModel> | $Enums.AdmissionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdmissionStatusFilter<$PrismaModel>
    _max?: NestedEnumAdmissionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDischargeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DischargeType | EnumDischargeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.DischargeType[] | ListEnumDischargeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumDischargeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.DischargeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumDischargeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumDischargeTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSurgeryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SurgeryStatus | EnumSurgeryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurgeryStatusFilter<$PrismaModel> | $Enums.SurgeryStatus
  }

  export type NestedEnumSurgeryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SurgeryStatus | EnumSurgeryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SurgeryStatus[] | ListEnumSurgeryStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSurgeryStatusWithAggregatesFilter<$PrismaModel> | $Enums.SurgeryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSurgeryStatusFilter<$PrismaModel>
    _max?: NestedEnumSurgeryStatusFilter<$PrismaModel>
  }

  export type NestedEnumChecklistStageFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistStage | EnumChecklistStageFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistStageFilter<$PrismaModel> | $Enums.ChecklistStage
  }

  export type NestedEnumChecklistStageWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistStage | EnumChecklistStageFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistStage[] | ListEnumChecklistStageFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistStageWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistStage
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistStageFilter<$PrismaModel>
    _max?: NestedEnumChecklistStageFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NoteType[] | ListEnumNoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOrderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeFilter<$PrismaModel> | $Enums.OrderType
  }

  export type NestedEnumOrderPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityFilter<$PrismaModel> | $Enums.OrderPriority
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderType | EnumOrderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderType[] | ListEnumOrderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderPriority | EnumOrderPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderPriority[] | ListEnumOrderPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderPriorityWithAggregatesFilter<$PrismaModel> | $Enums.OrderPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderPriorityFilter<$PrismaModel>
    _max?: NestedEnumOrderPriorityFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumClaimStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusFilter<$PrismaModel> | $Enums.ClaimStatus
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClaimStatus | EnumClaimStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClaimStatus[] | ListEnumClaimStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumClaimStatusWithAggregatesFilter<$PrismaModel> | $Enums.ClaimStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClaimStatusFilter<$PrismaModel>
    _max?: NestedEnumClaimStatusFilter<$PrismaModel>
  }

  export type StaffProfileCreateWithoutUserInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutUserInput = {
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutUserInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
  }

  export type LabResultCreateWithoutTechnicianInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    resultDate?: Date | string
    serviceOrder: ServiceOrderCreateNestedOneWithoutLabResultsInput
    verifiedBy?: StaffProfileCreateNestedOneWithoutVerifiedResultsInput
  }

  export type LabResultUncheckedCreateWithoutTechnicianInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type LabResultCreateOrConnectWithoutTechnicianInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput>
  }

  export type LabResultCreateManyTechnicianInputEnvelope = {
    data: LabResultCreateManyTechnicianInput | LabResultCreateManyTechnicianInput[]
    skipDuplicates?: boolean
  }

  export type StaffProfileUpsertWithoutUserInput = {
    update: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type StaffProfileUpdateWithoutUserInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutUserInput = {
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type LabResultUpsertWithWhereUniqueWithoutTechnicianInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutTechnicianInput, LabResultUncheckedUpdateWithoutTechnicianInput>
    create: XOR<LabResultCreateWithoutTechnicianInput, LabResultUncheckedCreateWithoutTechnicianInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutTechnicianInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutTechnicianInput, LabResultUncheckedUpdateWithoutTechnicianInput>
  }

  export type LabResultUpdateManyWithWhereWithoutTechnicianInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutTechnicianInput>
  }

  export type LabResultScalarWhereInput = {
    AND?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    OR?: LabResultScalarWhereInput[]
    NOT?: LabResultScalarWhereInput | LabResultScalarWhereInput[]
    id?: StringFilter<"LabResult"> | string
    serviceOrderId?: StringFilter<"LabResult"> | string
    testName?: StringFilter<"LabResult"> | string
    resultValue?: StringFilter<"LabResult"> | string
    referenceRange?: StringNullableFilter<"LabResult"> | string | null
    unit?: StringNullableFilter<"LabResult"> | string | null
    technicianId?: StringNullableFilter<"LabResult"> | string | null
    verifiedByDoctorId?: StringNullableFilter<"LabResult"> | string | null
    resultDate?: DateTimeFilter<"LabResult"> | Date | string
  }

  export type UserCreateWithoutStaffProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    labResults?: LabResultCreateNestedManyWithoutTechnicianInput
  }

  export type UserUncheckedCreateWithoutStaffProfileInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutTechnicianInput
  }

  export type UserCreateOrConnectWithoutStaffProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
  }

  export type DepartmentCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutStaffInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutStaffInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
  }

  export type DepartmentCreateWithoutHeadDoctorInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutHeadDoctorInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutHeadDoctorInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput>
  }

  export type DepartmentCreateManyHeadDoctorInputEnvelope = {
    data: DepartmentCreateManyHeadDoctorInput | DepartmentCreateManyHeadDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDoctorInput = {
    id?: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    department: DepartmentCreateNestedOneWithoutAppointmentsInput
    opdVisit?: OpdVisitCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type OpdVisitCreateWithoutDoctorInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutDoctorInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutDoctorInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput>
  }

  export type OpdVisitCreateManyDoctorInputEnvelope = {
    data: OpdVisitCreateManyDoctorInput | OpdVisitCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutAdmittingDoctorInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutAdmittingDoctorInput = {
    id?: string
    patientId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutAdmittingDoctorInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput>
  }

  export type AdmissionCreateManyAdmittingDoctorInputEnvelope = {
    data: AdmissionCreateManyAdmittingDoctorInput | AdmissionCreateManyAdmittingDoctorInput[]
    skipDuplicates?: boolean
  }

  export type SurgeryCreateWithoutSurgeonInput = {
    id?: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    admission: AdmissionCreateNestedOneWithoutSurgeriesInput
    checklists?: SurgicalChecklistCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUncheckedCreateWithoutSurgeonInput = {
    id?: string
    admissionId: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    checklists?: SurgicalChecklistUncheckedCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryCreateOrConnectWithoutSurgeonInput = {
    where: SurgeryWhereUniqueInput
    create: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput>
  }

  export type SurgeryCreateManySurgeonInputEnvelope = {
    data: SurgeryCreateManySurgeonInput | SurgeryCreateManySurgeonInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutDoctorInput = {
    id?: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
    patient: PatientCreateNestedOneWithoutClinicalNotesInput
    visit?: OpdVisitCreateNestedOneWithoutClinicalNotesInput
    admission?: AdmissionCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteCreateOrConnectWithoutDoctorInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput>
  }

  export type ClinicalNoteCreateManyDoctorInputEnvelope = {
    data: ClinicalNoteCreateManyDoctorInput | ClinicalNoteCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutDoctorInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutDoctorInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput>
  }

  export type ServiceOrderCreateManyDoctorInputEnvelope = {
    data: ServiceOrderCreateManyDoctorInput | ServiceOrderCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type LabResultCreateWithoutVerifiedByInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    resultDate?: Date | string
    serviceOrder: ServiceOrderCreateNestedOneWithoutLabResultsInput
    technician?: UserCreateNestedOneWithoutLabResultsInput
  }

  export type LabResultUncheckedCreateWithoutVerifiedByInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    resultDate?: Date | string
  }

  export type LabResultCreateOrConnectWithoutVerifiedByInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput>
  }

  export type LabResultCreateManyVerifiedByInputEnvelope = {
    data: LabResultCreateManyVerifiedByInput | LabResultCreateManyVerifiedByInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutDoctorInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionCreateManyDoctorInputEnvelope = {
    data: PrescriptionCreateManyDoctorInput | PrescriptionCreateManyDoctorInput[]
    skipDuplicates?: boolean
  }

  export type SurgerySStaffCreateWithoutStaffInput = {
    role: string
    surgery: SurgeryCreateNestedOneWithoutSurgerySStaffsInput
  }

  export type SurgerySStaffUncheckedCreateWithoutStaffInput = {
    surgeryId: string
    role: string
  }

  export type SurgerySStaffCreateOrConnectWithoutStaffInput = {
    where: SurgerySStaffWhereUniqueInput
    create: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput>
  }

  export type SurgerySStaffCreateManyStaffInputEnvelope = {
    data: SurgerySStaffCreateManyStaffInput | SurgerySStaffCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStaffProfileInput = {
    update: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type UserUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUpdateManyWithoutTechnicianNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutTechnicianNestedInput
  }

  export type DepartmentUpsertWithoutStaffInput = {
    update: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
    create: XOR<DepartmentCreateWithoutStaffInput, DepartmentUncheckedCreateWithoutStaffInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutStaffInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutStaffInput, DepartmentUncheckedUpdateWithoutStaffInput>
  }

  export type DepartmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutHeadDoctorInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutHeadDoctorInput, DepartmentUncheckedUpdateWithoutHeadDoctorInput>
    create: XOR<DepartmentCreateWithoutHeadDoctorInput, DepartmentUncheckedCreateWithoutHeadDoctorInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutHeadDoctorInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutHeadDoctorInput, DepartmentUncheckedUpdateWithoutHeadDoctorInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutHeadDoctorInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutHeadDoctorInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringFilter<"Department"> | string
    headDoctorId?: StringNullableFilter<"Department"> | string | null
    type?: EnumDepartmentTypeFilter<"Department"> | $Enums.DepartmentType
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    doctorId?: StringFilter<"Appointment"> | string
    departmentId?: StringFilter<"Appointment"> | string
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    tokenNumber?: IntFilter<"Appointment"> | number
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
  }

  export type OpdVisitUpsertWithWhereUniqueWithoutDoctorInput = {
    where: OpdVisitWhereUniqueInput
    update: XOR<OpdVisitUpdateWithoutDoctorInput, OpdVisitUncheckedUpdateWithoutDoctorInput>
    create: XOR<OpdVisitCreateWithoutDoctorInput, OpdVisitUncheckedCreateWithoutDoctorInput>
  }

  export type OpdVisitUpdateWithWhereUniqueWithoutDoctorInput = {
    where: OpdVisitWhereUniqueInput
    data: XOR<OpdVisitUpdateWithoutDoctorInput, OpdVisitUncheckedUpdateWithoutDoctorInput>
  }

  export type OpdVisitUpdateManyWithWhereWithoutDoctorInput = {
    where: OpdVisitScalarWhereInput
    data: XOR<OpdVisitUpdateManyMutationInput, OpdVisitUncheckedUpdateManyWithoutDoctorInput>
  }

  export type OpdVisitScalarWhereInput = {
    AND?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
    OR?: OpdVisitScalarWhereInput[]
    NOT?: OpdVisitScalarWhereInput | OpdVisitScalarWhereInput[]
    id?: StringFilter<"OpdVisit"> | string
    appointmentId?: StringNullableFilter<"OpdVisit"> | string | null
    patientId?: StringFilter<"OpdVisit"> | string
    doctorId?: StringFilter<"OpdVisit"> | string
    visitDate?: DateTimeFilter<"OpdVisit"> | Date | string
    visitType?: EnumVisitTypeFilter<"OpdVisit"> | $Enums.VisitType
    triageColor?: EnumTriageColorNullableFilter<"OpdVisit"> | $Enums.TriageColor | null
    status?: EnumVisitStatusFilter<"OpdVisit"> | $Enums.VisitStatus
    isMedicoLegal?: BoolFilter<"OpdVisit"> | boolean
  }

  export type AdmissionUpsertWithWhereUniqueWithoutAdmittingDoctorInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutAdmittingDoctorInput, AdmissionUncheckedUpdateWithoutAdmittingDoctorInput>
    create: XOR<AdmissionCreateWithoutAdmittingDoctorInput, AdmissionUncheckedCreateWithoutAdmittingDoctorInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutAdmittingDoctorInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutAdmittingDoctorInput, AdmissionUncheckedUpdateWithoutAdmittingDoctorInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutAdmittingDoctorInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutAdmittingDoctorInput>
  }

  export type AdmissionScalarWhereInput = {
    AND?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    OR?: AdmissionScalarWhereInput[]
    NOT?: AdmissionScalarWhereInput | AdmissionScalarWhereInput[]
    id?: StringFilter<"Admission"> | string
    patientId?: StringFilter<"Admission"> | string
    admittingDoctorId?: StringFilter<"Admission"> | string
    departmentId?: StringFilter<"Admission"> | string
    visitId?: StringNullableFilter<"Admission"> | string | null
    currentBedId?: StringNullableFilter<"Admission"> | string | null
    admissionDate?: DateTimeFilter<"Admission"> | Date | string
    dischargeDate?: DateTimeNullableFilter<"Admission"> | Date | string | null
    reasonForAdmission?: StringNullableFilter<"Admission"> | string | null
    admissionType?: EnumAdmissionTypeFilter<"Admission"> | $Enums.AdmissionType
    status?: EnumAdmissionStatusFilter<"Admission"> | $Enums.AdmissionStatus
    dischargeType?: EnumDischargeTypeNullableFilter<"Admission"> | $Enums.DischargeType | null
    mlc?: BoolFilter<"Admission"> | boolean
  }

  export type SurgeryUpsertWithWhereUniqueWithoutSurgeonInput = {
    where: SurgeryWhereUniqueInput
    update: XOR<SurgeryUpdateWithoutSurgeonInput, SurgeryUncheckedUpdateWithoutSurgeonInput>
    create: XOR<SurgeryCreateWithoutSurgeonInput, SurgeryUncheckedCreateWithoutSurgeonInput>
  }

  export type SurgeryUpdateWithWhereUniqueWithoutSurgeonInput = {
    where: SurgeryWhereUniqueInput
    data: XOR<SurgeryUpdateWithoutSurgeonInput, SurgeryUncheckedUpdateWithoutSurgeonInput>
  }

  export type SurgeryUpdateManyWithWhereWithoutSurgeonInput = {
    where: SurgeryScalarWhereInput
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyWithoutSurgeonInput>
  }

  export type SurgeryScalarWhereInput = {
    AND?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
    OR?: SurgeryScalarWhereInput[]
    NOT?: SurgeryScalarWhereInput | SurgeryScalarWhereInput[]
    id?: StringFilter<"Surgery"> | string
    admissionId?: StringFilter<"Surgery"> | string
    procedureName?: StringFilter<"Surgery"> | string
    surgeonId?: StringFilter<"Surgery"> | string
    otRoomNumber?: StringNullableFilter<"Surgery"> | string | null
    surgeryDate?: DateTimeFilter<"Surgery"> | Date | string
    status?: EnumSurgeryStatusFilter<"Surgery"> | $Enums.SurgeryStatus
    notes?: StringNullableFilter<"Surgery"> | string | null
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutDoctorInput, ClinicalNoteUncheckedUpdateWithoutDoctorInput>
    create: XOR<ClinicalNoteCreateWithoutDoctorInput, ClinicalNoteUncheckedCreateWithoutDoctorInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutDoctorInput, ClinicalNoteUncheckedUpdateWithoutDoctorInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutDoctorInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ClinicalNoteScalarWhereInput = {
    AND?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    OR?: ClinicalNoteScalarWhereInput[]
    NOT?: ClinicalNoteScalarWhereInput | ClinicalNoteScalarWhereInput[]
    id?: StringFilter<"ClinicalNote"> | string
    patientId?: StringFilter<"ClinicalNote"> | string
    visitId?: StringNullableFilter<"ClinicalNote"> | string | null
    admissionId?: StringNullableFilter<"ClinicalNote"> | string | null
    doctorId?: StringFilter<"ClinicalNote"> | string
    noteType?: EnumNoteTypeFilter<"ClinicalNote"> | $Enums.NoteType
    content?: JsonFilter<"ClinicalNote">
    createdAt?: DateTimeFilter<"ClinicalNote"> | Date | string
    isFinalized?: BoolFilter<"ClinicalNote"> | boolean
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutDoctorInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutDoctorInput, ServiceOrderUncheckedUpdateWithoutDoctorInput>
    create: XOR<ServiceOrderCreateWithoutDoctorInput, ServiceOrderUncheckedCreateWithoutDoctorInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutDoctorInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutDoctorInput, ServiceOrderUncheckedUpdateWithoutDoctorInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutDoctorInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutDoctorInput>
  }

  export type ServiceOrderScalarWhereInput = {
    AND?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
    OR?: ServiceOrderScalarWhereInput[]
    NOT?: ServiceOrderScalarWhereInput | ServiceOrderScalarWhereInput[]
    id?: StringFilter<"ServiceOrder"> | string
    patientId?: StringFilter<"ServiceOrder"> | string
    doctorId?: StringFilter<"ServiceOrder"> | string
    visitId?: StringNullableFilter<"ServiceOrder"> | string | null
    admissionId?: StringNullableFilter<"ServiceOrder"> | string | null
    serviceId?: StringFilter<"ServiceOrder"> | string
    orderType?: EnumOrderTypeFilter<"ServiceOrder"> | $Enums.OrderType
    priority?: EnumOrderPriorityFilter<"ServiceOrder"> | $Enums.OrderPriority
    clinicalIndication?: StringNullableFilter<"ServiceOrder"> | string | null
    isPaid?: BoolFilter<"ServiceOrder"> | boolean
    status?: EnumOrderStatusFilter<"ServiceOrder"> | $Enums.OrderStatus
    orderDate?: DateTimeFilter<"ServiceOrder"> | Date | string
  }

  export type LabResultUpsertWithWhereUniqueWithoutVerifiedByInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutVerifiedByInput, LabResultUncheckedUpdateWithoutVerifiedByInput>
    create: XOR<LabResultCreateWithoutVerifiedByInput, LabResultUncheckedCreateWithoutVerifiedByInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutVerifiedByInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutVerifiedByInput, LabResultUncheckedUpdateWithoutVerifiedByInput>
  }

  export type LabResultUpdateManyWithWhereWithoutVerifiedByInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutVerifiedByInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
    create: XOR<PrescriptionCreateWithoutDoctorInput, PrescriptionUncheckedCreateWithoutDoctorInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutDoctorInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutDoctorInput, PrescriptionUncheckedUpdateWithoutDoctorInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutDoctorInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutDoctorInput>
  }

  export type PrescriptionScalarWhereInput = {
    AND?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    OR?: PrescriptionScalarWhereInput[]
    NOT?: PrescriptionScalarWhereInput | PrescriptionScalarWhereInput[]
    id?: StringFilter<"Prescription"> | string
    patientId?: StringFilter<"Prescription"> | string
    doctorId?: StringFilter<"Prescription"> | string
    visitId?: StringNullableFilter<"Prescription"> | string | null
    admissionId?: StringNullableFilter<"Prescription"> | string | null
    isPaid?: BoolFilter<"Prescription"> | boolean
    date?: DateTimeFilter<"Prescription"> | Date | string
  }

  export type SurgerySStaffUpsertWithWhereUniqueWithoutStaffInput = {
    where: SurgerySStaffWhereUniqueInput
    update: XOR<SurgerySStaffUpdateWithoutStaffInput, SurgerySStaffUncheckedUpdateWithoutStaffInput>
    create: XOR<SurgerySStaffCreateWithoutStaffInput, SurgerySStaffUncheckedCreateWithoutStaffInput>
  }

  export type SurgerySStaffUpdateWithWhereUniqueWithoutStaffInput = {
    where: SurgerySStaffWhereUniqueInput
    data: XOR<SurgerySStaffUpdateWithoutStaffInput, SurgerySStaffUncheckedUpdateWithoutStaffInput>
  }

  export type SurgerySStaffUpdateManyWithWhereWithoutStaffInput = {
    where: SurgerySStaffScalarWhereInput
    data: XOR<SurgerySStaffUpdateManyMutationInput, SurgerySStaffUncheckedUpdateManyWithoutStaffInput>
  }

  export type SurgerySStaffScalarWhereInput = {
    AND?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
    OR?: SurgerySStaffScalarWhereInput[]
    NOT?: SurgerySStaffScalarWhereInput | SurgerySStaffScalarWhereInput[]
    surgeryId?: StringFilter<"SurgerySStaff"> | string
    staffId?: StringFilter<"SurgerySStaff"> | string
    role?: StringFilter<"SurgerySStaff"> | string
  }

  export type StaffProfileCreateWithoutHeadOfDepartmentsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutHeadOfDepartmentsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutHeadOfDepartmentsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedCreateWithoutHeadOfDepartmentsInput>
  }

  export type StaffProfileCreateWithoutDepartmentInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutDepartmentInput = {
    id: string
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutDepartmentInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffProfileCreateManyDepartmentInputEnvelope = {
    data: StaffProfileCreateManyDepartmentInput | StaffProfileCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type ServiceCreateWithoutDepartmentInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    serviceOrders?: ServiceOrderCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutServiceInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceCreateManyDepartmentInputEnvelope = {
    data: ServiceCreateManyDepartmentInput | ServiceCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type WardCreateWithoutDepartmentInput = {
    id?: string
    name: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
    beds?: BedCreateNestedManyWithoutWardInput
  }

  export type WardUncheckedCreateWithoutDepartmentInput = {
    id?: string
    name: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
    beds?: BedUncheckedCreateNestedManyWithoutWardInput
  }

  export type WardCreateOrConnectWithoutDepartmentInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput>
  }

  export type WardCreateManyDepartmentInputEnvelope = {
    data: WardCreateManyDepartmentInput | WardCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutDepartmentInput = {
    id?: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: StaffProfileCreateNestedOneWithoutAppointmentsInput
    opdVisit?: OpdVisitCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDepartmentInput = {
    id?: string
    patientId: string
    doctorId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput>
  }

  export type AppointmentCreateManyDepartmentInputEnvelope = {
    data: AppointmentCreateManyDepartmentInput | AppointmentCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutDepartmentInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutDepartmentInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmissionCreateManyDepartmentInputEnvelope = {
    data: AdmissionCreateManyDepartmentInput | AdmissionCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type StaffProfileUpsertWithoutHeadOfDepartmentsInput = {
    update: XOR<StaffProfileUpdateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedUpdateWithoutHeadOfDepartmentsInput>
    create: XOR<StaffProfileCreateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedCreateWithoutHeadOfDepartmentsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutHeadOfDepartmentsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutHeadOfDepartmentsInput, StaffProfileUncheckedUpdateWithoutHeadOfDepartmentsInput>
  }

  export type StaffProfileUpdateWithoutHeadOfDepartmentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutHeadOfDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: StaffProfileWhereUniqueInput
    update: XOR<StaffProfileUpdateWithoutDepartmentInput, StaffProfileUncheckedUpdateWithoutDepartmentInput>
    create: XOR<StaffProfileCreateWithoutDepartmentInput, StaffProfileUncheckedCreateWithoutDepartmentInput>
  }

  export type StaffProfileUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: StaffProfileWhereUniqueInput
    data: XOR<StaffProfileUpdateWithoutDepartmentInput, StaffProfileUncheckedUpdateWithoutDepartmentInput>
  }

  export type StaffProfileUpdateManyWithWhereWithoutDepartmentInput = {
    where: StaffProfileScalarWhereInput
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type StaffProfileScalarWhereInput = {
    AND?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
    OR?: StaffProfileScalarWhereInput[]
    NOT?: StaffProfileScalarWhereInput | StaffProfileScalarWhereInput[]
    id?: StringFilter<"StaffProfile"> | string
    departmentId?: StringNullableFilter<"StaffProfile"> | string | null
    fullName?: StringFilter<"StaffProfile"> | string
    qualification?: StringNullableFilter<"StaffProfile"> | string | null
    registrationNumber?: StringNullableFilter<"StaffProfile"> | string | null
    contactNumber?: StringNullableFilter<"StaffProfile"> | string | null
    shiftTiming?: StringNullableFilter<"StaffProfile"> | string | null
  }

  export type ServiceUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
    create: XOR<ServiceCreateWithoutDepartmentInput, ServiceUncheckedCreateWithoutDepartmentInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutDepartmentInput, ServiceUncheckedUpdateWithoutDepartmentInput>
  }

  export type ServiceUpdateManyWithWhereWithoutDepartmentInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    name?: StringFilter<"Service"> | string
    category?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    departmentId?: StringFilter<"Service"> | string
    basePrice?: DecimalFilter<"Service"> | Decimal | DecimalJsLike | number | string
    code?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
  }

  export type WardUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: WardWhereUniqueInput
    update: XOR<WardUpdateWithoutDepartmentInput, WardUncheckedUpdateWithoutDepartmentInput>
    create: XOR<WardCreateWithoutDepartmentInput, WardUncheckedCreateWithoutDepartmentInput>
  }

  export type WardUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: WardWhereUniqueInput
    data: XOR<WardUpdateWithoutDepartmentInput, WardUncheckedUpdateWithoutDepartmentInput>
  }

  export type WardUpdateManyWithWhereWithoutDepartmentInput = {
    where: WardScalarWhereInput
    data: XOR<WardUpdateManyMutationInput, WardUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type WardScalarWhereInput = {
    AND?: WardScalarWhereInput | WardScalarWhereInput[]
    OR?: WardScalarWhereInput[]
    NOT?: WardScalarWhereInput | WardScalarWhereInput[]
    id?: StringFilter<"Ward"> | string
    name?: StringFilter<"Ward"> | string
    departmentId?: StringFilter<"Ward"> | string
    floorNumber?: IntFilter<"Ward"> | number
    type?: StringFilter<"Ward"> | string
    basePricePerDay?: DecimalFilter<"Ward"> | Decimal | DecimalJsLike | number | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDepartmentInput, AppointmentUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AppointmentCreateWithoutDepartmentInput, AppointmentUncheckedCreateWithoutDepartmentInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDepartmentInput, AppointmentUncheckedUpdateWithoutDepartmentInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDepartmentInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type AdmissionUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutDepartmentInput, AdmissionUncheckedUpdateWithoutDepartmentInput>
    create: XOR<AdmissionCreateWithoutDepartmentInput, AdmissionUncheckedCreateWithoutDepartmentInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutDepartmentInput, AdmissionUncheckedUpdateWithoutDepartmentInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutDepartmentInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentCreateWithoutServicesInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutServicesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
  }

  export type ServiceOrderCreateWithoutServiceInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutServiceInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceOrderCreateManyServiceInputEnvelope = {
    data: ServiceOrderCreateManyServiceInput | ServiceOrderCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutServiceInput = {
    id?: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    serviceOrder?: ServiceOrderCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutServiceInput = {
    id?: string
    invoiceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemCreateManyServiceInputEnvelope = {
    data: InvoiceItemCreateManyServiceInput | InvoiceItemCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutServicesInput = {
    update: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
    create: XOR<DepartmentCreateWithoutServicesInput, DepartmentUncheckedCreateWithoutServicesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutServicesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutServicesInput, DepartmentUncheckedUpdateWithoutServicesInput>
  }

  export type DepartmentUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutServiceInput, ServiceOrderUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceOrderCreateWithoutServiceInput, ServiceOrderUncheckedCreateWithoutServiceInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutServiceInput, ServiceOrderUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
    create: XOR<InvoiceItemCreateWithoutServiceInput, InvoiceItemUncheckedCreateWithoutServiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutServiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutServiceInput, InvoiceItemUncheckedUpdateWithoutServiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutServiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutServiceInput>
  }

  export type InvoiceItemScalarWhereInput = {
    AND?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    OR?: InvoiceItemScalarWhereInput[]
    NOT?: InvoiceItemScalarWhereInput | InvoiceItemScalarWhereInput[]
    id?: StringFilter<"InvoiceItem"> | string
    invoiceId?: StringFilter<"InvoiceItem"> | string
    serviceId?: StringFilter<"InvoiceItem"> | string
    serviceOrderId?: StringNullableFilter<"InvoiceItem"> | string | null
    itemName?: StringFilter<"InvoiceItem"> | string
    quantity?: IntFilter<"InvoiceItem"> | number
    unitPrice?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
    total?: DecimalFilter<"InvoiceItem"> | Decimal | DecimalJsLike | number | string
  }

  export type DepartmentCreateWithoutWardsInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutWardsInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutWardsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutWardsInput, DepartmentUncheckedCreateWithoutWardsInput>
  }

  export type BedCreateWithoutWardInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
    transfers?: BedTransferCreateNestedManyWithoutBedInput
    activeAdmissions?: AdmissionCreateNestedManyWithoutCurrentBedInput
  }

  export type BedUncheckedCreateWithoutWardInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
    transfers?: BedTransferUncheckedCreateNestedManyWithoutBedInput
    activeAdmissions?: AdmissionUncheckedCreateNestedManyWithoutCurrentBedInput
  }

  export type BedCreateOrConnectWithoutWardInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedCreateManyWardInputEnvelope = {
    data: BedCreateManyWardInput | BedCreateManyWardInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentUpsertWithoutWardsInput = {
    update: XOR<DepartmentUpdateWithoutWardsInput, DepartmentUncheckedUpdateWithoutWardsInput>
    create: XOR<DepartmentCreateWithoutWardsInput, DepartmentUncheckedCreateWithoutWardsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutWardsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutWardsInput, DepartmentUncheckedUpdateWithoutWardsInput>
  }

  export type DepartmentUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutWardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type BedUpsertWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    update: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
    create: XOR<BedCreateWithoutWardInput, BedUncheckedCreateWithoutWardInput>
  }

  export type BedUpdateWithWhereUniqueWithoutWardInput = {
    where: BedWhereUniqueInput
    data: XOR<BedUpdateWithoutWardInput, BedUncheckedUpdateWithoutWardInput>
  }

  export type BedUpdateManyWithWhereWithoutWardInput = {
    where: BedScalarWhereInput
    data: XOR<BedUpdateManyMutationInput, BedUncheckedUpdateManyWithoutWardInput>
  }

  export type BedScalarWhereInput = {
    AND?: BedScalarWhereInput | BedScalarWhereInput[]
    OR?: BedScalarWhereInput[]
    NOT?: BedScalarWhereInput | BedScalarWhereInput[]
    id?: StringFilter<"Bed"> | string
    wardId?: StringFilter<"Bed"> | string
    bedNumber?: StringFilter<"Bed"> | string
    status?: EnumBedStatusFilter<"Bed"> | $Enums.BedStatus
  }

  export type WardCreateWithoutBedsInput = {
    id?: string
    name: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
    department: DepartmentCreateNestedOneWithoutWardsInput
  }

  export type WardUncheckedCreateWithoutBedsInput = {
    id?: string
    name: string
    departmentId: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
  }

  export type WardCreateOrConnectWithoutBedsInput = {
    where: WardWhereUniqueInput
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
  }

  export type BedTransferCreateWithoutBedInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
    admission: AdmissionCreateNestedOneWithoutBedTransfersInput
  }

  export type BedTransferUncheckedCreateWithoutBedInput = {
    id?: string
    admissionId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type BedTransferCreateOrConnectWithoutBedInput = {
    where: BedTransferWhereUniqueInput
    create: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput>
  }

  export type BedTransferCreateManyBedInputEnvelope = {
    data: BedTransferCreateManyBedInput | BedTransferCreateManyBedInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutCurrentBedInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutCurrentBedInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutCurrentBedInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput>
  }

  export type AdmissionCreateManyCurrentBedInputEnvelope = {
    data: AdmissionCreateManyCurrentBedInput | AdmissionCreateManyCurrentBedInput[]
    skipDuplicates?: boolean
  }

  export type WardUpsertWithoutBedsInput = {
    update: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
    create: XOR<WardCreateWithoutBedsInput, WardUncheckedCreateWithoutBedsInput>
    where?: WardWhereInput
  }

  export type WardUpdateToOneWithWhereWithoutBedsInput = {
    where?: WardWhereInput
    data: XOR<WardUpdateWithoutBedsInput, WardUncheckedUpdateWithoutBedsInput>
  }

  export type WardUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    department?: DepartmentUpdateOneRequiredWithoutWardsNestedInput
  }

  export type WardUncheckedUpdateWithoutBedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BedTransferUpsertWithWhereUniqueWithoutBedInput = {
    where: BedTransferWhereUniqueInput
    update: XOR<BedTransferUpdateWithoutBedInput, BedTransferUncheckedUpdateWithoutBedInput>
    create: XOR<BedTransferCreateWithoutBedInput, BedTransferUncheckedCreateWithoutBedInput>
  }

  export type BedTransferUpdateWithWhereUniqueWithoutBedInput = {
    where: BedTransferWhereUniqueInput
    data: XOR<BedTransferUpdateWithoutBedInput, BedTransferUncheckedUpdateWithoutBedInput>
  }

  export type BedTransferUpdateManyWithWhereWithoutBedInput = {
    where: BedTransferScalarWhereInput
    data: XOR<BedTransferUpdateManyMutationInput, BedTransferUncheckedUpdateManyWithoutBedInput>
  }

  export type BedTransferScalarWhereInput = {
    AND?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
    OR?: BedTransferScalarWhereInput[]
    NOT?: BedTransferScalarWhereInput | BedTransferScalarWhereInput[]
    id?: StringFilter<"BedTransfer"> | string
    admissionId?: StringFilter<"BedTransfer"> | string
    bedId?: StringFilter<"BedTransfer"> | string
    startDate?: DateTimeFilter<"BedTransfer"> | Date | string
    endDate?: DateTimeNullableFilter<"BedTransfer"> | Date | string | null
    reason?: StringNullableFilter<"BedTransfer"> | string | null
  }

  export type AdmissionUpsertWithWhereUniqueWithoutCurrentBedInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutCurrentBedInput, AdmissionUncheckedUpdateWithoutCurrentBedInput>
    create: XOR<AdmissionCreateWithoutCurrentBedInput, AdmissionUncheckedCreateWithoutCurrentBedInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutCurrentBedInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutCurrentBedInput, AdmissionUncheckedUpdateWithoutCurrentBedInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutCurrentBedInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutCurrentBedInput>
  }

  export type MedicalHistoryCreateWithoutPatientInput = {
    id?: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
  }

  export type MedicalHistoryUncheckedCreateWithoutPatientInput = {
    id?: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
  }

  export type MedicalHistoryCreateOrConnectWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    create: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput>
  }

  export type MedicalHistoryCreateManyPatientInputEnvelope = {
    data: MedicalHistoryCreateManyPatientInput | MedicalHistoryCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientDocumentCreateWithoutPatientInput = {
    id?: string
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
    visit?: OpdVisitCreateNestedOneWithoutDocumentsInput
    admission?: AdmissionCreateNestedOneWithoutDocumentsInput
  }

  export type PatientDocumentUncheckedCreateWithoutPatientInput = {
    id?: string
    visitId?: string | null
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type PatientDocumentCreateOrConnectWithoutPatientInput = {
    where: PatientDocumentWhereUniqueInput
    create: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput>
  }

  export type PatientDocumentCreateManyPatientInputEnvelope = {
    data: PatientDocumentCreateManyPatientInput | PatientDocumentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    doctor: StaffProfileCreateNestedOneWithoutAppointmentsInput
    department: DepartmentCreateNestedOneWithoutAppointmentsInput
    opdVisit?: OpdVisitCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type OpdVisitCreateWithoutPatientInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutPatientInput = {
    id?: string
    appointmentId?: string | null
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutPatientInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput>
  }

  export type OpdVisitCreateManyPatientInputEnvelope = {
    data: OpdVisitCreateManyPatientInput | OpdVisitCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutPatientInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutPatientInput = {
    id?: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionCreateManyPatientInputEnvelope = {
    data: AdmissionCreateManyPatientInput | AdmissionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutPatientInput = {
    id?: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
    visit?: OpdVisitCreateNestedOneWithoutClinicalNotesInput
    admission?: AdmissionCreateNestedOneWithoutClinicalNotesInput
    doctor: StaffProfileCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutPatientInput = {
    id?: string
    visitId?: string | null
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteCreateOrConnectWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteCreateManyPatientInputEnvelope = {
    data: ClinicalNoteCreateManyPatientInput | ClinicalNoteCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutPatientInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutPatientInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput>
  }

  export type ServiceOrderCreateManyPatientInputEnvelope = {
    data: ServiceOrderCreateManyPatientInput | ServiceOrderCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutPatientInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutPatientInput = {
    id?: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionCreateManyPatientInputEnvelope = {
    data: PrescriptionCreateManyPatientInput | PrescriptionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PharmacySaleCreateWithoutPatientInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    prescription?: PrescriptionCreateNestedOneWithoutSalesInput
    items?: SaleItemCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleUncheckedCreateWithoutPatientInput = {
    id?: string
    prescriptionId?: string | null
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleCreateOrConnectWithoutPatientInput = {
    where: PharmacySaleWhereUniqueInput
    create: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput>
  }

  export type PharmacySaleCreateManyPatientInputEnvelope = {
    data: PharmacySaleCreateManyPatientInput | PharmacySaleCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutPatientInput = {
    id?: string
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    admission?: AdmissionCreateNestedOneWithoutInvoicesInput
    visit?: OpdVisitCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPatientInput = {
    id?: string
    admissionId?: string | null
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceCreateManyPatientInputEnvelope = {
    data: InvoiceCreateManyPatientInput | InvoiceCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicalHistoryUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    update: XOR<MedicalHistoryUpdateWithoutPatientInput, MedicalHistoryUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicalHistoryCreateWithoutPatientInput, MedicalHistoryUncheckedCreateWithoutPatientInput>
  }

  export type MedicalHistoryUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicalHistoryWhereUniqueInput
    data: XOR<MedicalHistoryUpdateWithoutPatientInput, MedicalHistoryUncheckedUpdateWithoutPatientInput>
  }

  export type MedicalHistoryUpdateManyWithWhereWithoutPatientInput = {
    where: MedicalHistoryScalarWhereInput
    data: XOR<MedicalHistoryUpdateManyMutationInput, MedicalHistoryUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicalHistoryScalarWhereInput = {
    AND?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
    OR?: MedicalHistoryScalarWhereInput[]
    NOT?: MedicalHistoryScalarWhereInput | MedicalHistoryScalarWhereInput[]
    id?: StringFilter<"MedicalHistory"> | string
    patientId?: StringFilter<"MedicalHistory"> | string
    category?: StringFilter<"MedicalHistory"> | string
    name?: StringFilter<"MedicalHistory"> | string
    severity?: StringNullableFilter<"MedicalHistory"> | string | null
    status?: StringNullableFilter<"MedicalHistory"> | string | null
    diagnosedDate?: DateTimeNullableFilter<"MedicalHistory"> | Date | string | null
    notes?: StringNullableFilter<"MedicalHistory"> | string | null
  }

  export type PatientDocumentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientDocumentWhereUniqueInput
    update: XOR<PatientDocumentUpdateWithoutPatientInput, PatientDocumentUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientDocumentCreateWithoutPatientInput, PatientDocumentUncheckedCreateWithoutPatientInput>
  }

  export type PatientDocumentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientDocumentWhereUniqueInput
    data: XOR<PatientDocumentUpdateWithoutPatientInput, PatientDocumentUncheckedUpdateWithoutPatientInput>
  }

  export type PatientDocumentUpdateManyWithWhereWithoutPatientInput = {
    where: PatientDocumentScalarWhereInput
    data: XOR<PatientDocumentUpdateManyMutationInput, PatientDocumentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientDocumentScalarWhereInput = {
    AND?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
    OR?: PatientDocumentScalarWhereInput[]
    NOT?: PatientDocumentScalarWhereInput | PatientDocumentScalarWhereInput[]
    id?: StringFilter<"PatientDocument"> | string
    patientId?: StringFilter<"PatientDocument"> | string
    visitId?: StringNullableFilter<"PatientDocument"> | string | null
    admissionId?: StringNullableFilter<"PatientDocument"> | string | null
    category?: StringFilter<"PatientDocument"> | string
    fileUrl?: StringFilter<"PatientDocument"> | string
    uploadedBy?: StringNullableFilter<"PatientDocument"> | string | null
    uploadedAt?: DateTimeFilter<"PatientDocument"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type OpdVisitUpsertWithWhereUniqueWithoutPatientInput = {
    where: OpdVisitWhereUniqueInput
    update: XOR<OpdVisitUpdateWithoutPatientInput, OpdVisitUncheckedUpdateWithoutPatientInput>
    create: XOR<OpdVisitCreateWithoutPatientInput, OpdVisitUncheckedCreateWithoutPatientInput>
  }

  export type OpdVisitUpdateWithWhereUniqueWithoutPatientInput = {
    where: OpdVisitWhereUniqueInput
    data: XOR<OpdVisitUpdateWithoutPatientInput, OpdVisitUncheckedUpdateWithoutPatientInput>
  }

  export type OpdVisitUpdateManyWithWhereWithoutPatientInput = {
    where: OpdVisitScalarWhereInput
    data: XOR<OpdVisitUpdateManyMutationInput, OpdVisitUncheckedUpdateManyWithoutPatientInput>
  }

  export type AdmissionUpsertWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    update: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
    create: XOR<AdmissionCreateWithoutPatientInput, AdmissionUncheckedCreateWithoutPatientInput>
  }

  export type AdmissionUpdateWithWhereUniqueWithoutPatientInput = {
    where: AdmissionWhereUniqueInput
    data: XOR<AdmissionUpdateWithoutPatientInput, AdmissionUncheckedUpdateWithoutPatientInput>
  }

  export type AdmissionUpdateManyWithWhereWithoutPatientInput = {
    where: AdmissionScalarWhereInput
    data: XOR<AdmissionUpdateManyMutationInput, AdmissionUncheckedUpdateManyWithoutPatientInput>
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
    create: XOR<ClinicalNoteCreateWithoutPatientInput, ClinicalNoteUncheckedCreateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutPatientInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutPatientInput, ClinicalNoteUncheckedUpdateWithoutPatientInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutPatientInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutPatientInput>
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutPatientInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutPatientInput, ServiceOrderUncheckedUpdateWithoutPatientInput>
    create: XOR<ServiceOrderCreateWithoutPatientInput, ServiceOrderUncheckedCreateWithoutPatientInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutPatientInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutPatientInput, ServiceOrderUncheckedUpdateWithoutPatientInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutPatientInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutPatientInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
    create: XOR<PrescriptionCreateWithoutPatientInput, PrescriptionUncheckedCreateWithoutPatientInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutPatientInput, PrescriptionUncheckedUpdateWithoutPatientInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutPatientInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PharmacySaleUpsertWithWhereUniqueWithoutPatientInput = {
    where: PharmacySaleWhereUniqueInput
    update: XOR<PharmacySaleUpdateWithoutPatientInput, PharmacySaleUncheckedUpdateWithoutPatientInput>
    create: XOR<PharmacySaleCreateWithoutPatientInput, PharmacySaleUncheckedCreateWithoutPatientInput>
  }

  export type PharmacySaleUpdateWithWhereUniqueWithoutPatientInput = {
    where: PharmacySaleWhereUniqueInput
    data: XOR<PharmacySaleUpdateWithoutPatientInput, PharmacySaleUncheckedUpdateWithoutPatientInput>
  }

  export type PharmacySaleUpdateManyWithWhereWithoutPatientInput = {
    where: PharmacySaleScalarWhereInput
    data: XOR<PharmacySaleUpdateManyMutationInput, PharmacySaleUncheckedUpdateManyWithoutPatientInput>
  }

  export type PharmacySaleScalarWhereInput = {
    AND?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
    OR?: PharmacySaleScalarWhereInput[]
    NOT?: PharmacySaleScalarWhereInput | PharmacySaleScalarWhereInput[]
    id?: StringFilter<"PharmacySale"> | string
    patientId?: StringFilter<"PharmacySale"> | string
    prescriptionId?: StringNullableFilter<"PharmacySale"> | string | null
    saleDate?: DateTimeFilter<"PharmacySale"> | Date | string
    totalAmount?: DecimalFilter<"PharmacySale"> | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
    create: XOR<InvoiceCreateWithoutPatientInput, InvoiceUncheckedCreateWithoutPatientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutPatientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutPatientInput, InvoiceUncheckedUpdateWithoutPatientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutPatientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutPatientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    patientId?: StringFilter<"Invoice"> | string
    admissionId?: StringNullableFilter<"Invoice"> | string | null
    visitId?: StringNullableFilter<"Invoice"> | string | null
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    totalAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
  }

  export type PatientCreateWithoutMedicalHistoryInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicalHistoryInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicalHistoryInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicalHistoryInput, PatientUncheckedCreateWithoutMedicalHistoryInput>
  }

  export type PatientUpsertWithoutMedicalHistoryInput = {
    update: XOR<PatientUpdateWithoutMedicalHistoryInput, PatientUncheckedUpdateWithoutMedicalHistoryInput>
    create: XOR<PatientCreateWithoutMedicalHistoryInput, PatientUncheckedCreateWithoutMedicalHistoryInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicalHistoryInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicalHistoryInput, PatientUncheckedUpdateWithoutMedicalHistoryInput>
  }

  export type PatientUpdateWithoutMedicalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicalHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutDocumentsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutDocumentsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutDocumentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
  }

  export type OpdVisitCreateWithoutDocumentsInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutDocumentsInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutDocumentsInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutDocumentsInput, OpdVisitUncheckedCreateWithoutDocumentsInput>
  }

  export type AdmissionCreateWithoutDocumentsInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutDocumentsInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutDocumentsInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
  }

  export type PatientUpsertWithoutDocumentsInput = {
    update: XOR<PatientUpdateWithoutDocumentsInput, PatientUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PatientCreateWithoutDocumentsInput, PatientUncheckedCreateWithoutDocumentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutDocumentsInput, PatientUncheckedUpdateWithoutDocumentsInput>
  }

  export type PatientUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type OpdVisitUpsertWithoutDocumentsInput = {
    update: XOR<OpdVisitUpdateWithoutDocumentsInput, OpdVisitUncheckedUpdateWithoutDocumentsInput>
    create: XOR<OpdVisitCreateWithoutDocumentsInput, OpdVisitUncheckedCreateWithoutDocumentsInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutDocumentsInput, OpdVisitUncheckedUpdateWithoutDocumentsInput>
  }

  export type OpdVisitUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type AdmissionUpsertWithoutDocumentsInput = {
    update: XOR<AdmissionUpdateWithoutDocumentsInput, AdmissionUncheckedUpdateWithoutDocumentsInput>
    create: XOR<AdmissionCreateWithoutDocumentsInput, AdmissionUncheckedCreateWithoutDocumentsInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutDocumentsInput, AdmissionUncheckedUpdateWithoutDocumentsInput>
  }

  export type AdmissionUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type StaffProfileCreateWithoutAppointmentsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutAppointmentsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutAppointmentsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutAppointmentsInput, StaffProfileUncheckedCreateWithoutAppointmentsInput>
  }

  export type DepartmentCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAppointmentsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
  }

  export type OpdVisitCreateWithoutAppointmentInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutAppointmentInput = {
    id?: string
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutAppointmentInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StaffProfileUpsertWithoutAppointmentsInput = {
    update: XOR<StaffProfileUpdateWithoutAppointmentsInput, StaffProfileUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<StaffProfileCreateWithoutAppointmentsInput, StaffProfileUncheckedCreateWithoutAppointmentsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutAppointmentsInput, StaffProfileUncheckedUpdateWithoutAppointmentsInput>
  }

  export type StaffProfileUpdateWithoutAppointmentsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type DepartmentUpsertWithoutAppointmentsInput = {
    update: XOR<DepartmentUpdateWithoutAppointmentsInput, DepartmentUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DepartmentCreateWithoutAppointmentsInput, DepartmentUncheckedCreateWithoutAppointmentsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAppointmentsInput, DepartmentUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DepartmentUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type OpdVisitUpsertWithoutAppointmentInput = {
    update: XOR<OpdVisitUpdateWithoutAppointmentInput, OpdVisitUncheckedUpdateWithoutAppointmentInput>
    create: XOR<OpdVisitCreateWithoutAppointmentInput, OpdVisitUncheckedCreateWithoutAppointmentInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutAppointmentInput, OpdVisitUncheckedUpdateWithoutAppointmentInput>
  }

  export type OpdVisitUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutAppointmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type AppointmentCreateWithoutOpdVisitInput = {
    id?: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
    patient: PatientCreateNestedOneWithoutAppointmentsInput
    doctor: StaffProfileCreateNestedOneWithoutAppointmentsInput
    department: DepartmentCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateWithoutOpdVisitInput = {
    id?: string
    patientId: string
    doctorId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
  }

  export type AppointmentCreateOrConnectWithoutOpdVisitInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutOpdVisitInput, AppointmentUncheckedCreateWithoutOpdVisitInput>
  }

  export type PatientCreateWithoutOpdVisitsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutOpdVisitsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutOpdVisitsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutOpdVisitsInput, PatientUncheckedCreateWithoutOpdVisitsInput>
  }

  export type StaffProfileCreateWithoutOpdVisitsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutOpdVisitsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutOpdVisitsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutOpdVisitsInput, StaffProfileUncheckedCreateWithoutOpdVisitsInput>
  }

  export type ClinicalNoteCreateWithoutVisitInput = {
    id?: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
    patient: PatientCreateNestedOneWithoutClinicalNotesInput
    admission?: AdmissionCreateNestedOneWithoutClinicalNotesInput
    doctor: StaffProfileCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteCreateOrConnectWithoutVisitInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput>
  }

  export type ClinicalNoteCreateManyVisitInputEnvelope = {
    data: ClinicalNoteCreateManyVisitInput | ClinicalNoteCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutVisitInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    doctorId: string
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutVisitInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput>
  }

  export type ServiceOrderCreateManyVisitInputEnvelope = {
    data: ServiceOrderCreateManyVisitInput | ServiceOrderCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutVisitInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    doctorId: string
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutVisitInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput>
  }

  export type PrescriptionCreateManyVisitInputEnvelope = {
    data: PrescriptionCreateManyVisitInput | PrescriptionCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type PatientDocumentCreateWithoutVisitInput = {
    id?: string
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    admission?: AdmissionCreateNestedOneWithoutDocumentsInput
  }

  export type PatientDocumentUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type PatientDocumentCreateOrConnectWithoutVisitInput = {
    where: PatientDocumentWhereUniqueInput
    create: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput>
  }

  export type PatientDocumentCreateManyVisitInputEnvelope = {
    data: PatientDocumentCreateManyVisitInput | PatientDocumentCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutVisitInput = {
    id?: string
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    patient: PatientCreateNestedOneWithoutInvoicesInput
    admission?: AdmissionCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutVisitInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput>
  }

  export type InvoiceCreateManyVisitInputEnvelope = {
    data: InvoiceCreateManyVisitInput | InvoiceCreateManyVisitInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionCreateWithoutVisitInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutVisitInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutVisitInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
  }

  export type AppointmentUpsertWithoutOpdVisitInput = {
    update: XOR<AppointmentUpdateWithoutOpdVisitInput, AppointmentUncheckedUpdateWithoutOpdVisitInput>
    create: XOR<AppointmentCreateWithoutOpdVisitInput, AppointmentUncheckedCreateWithoutOpdVisitInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutOpdVisitInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutOpdVisitInput, AppointmentUncheckedUpdateWithoutOpdVisitInput>
  }

  export type AppointmentUpdateWithoutOpdVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutOpdVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type PatientUpsertWithoutOpdVisitsInput = {
    update: XOR<PatientUpdateWithoutOpdVisitsInput, PatientUncheckedUpdateWithoutOpdVisitsInput>
    create: XOR<PatientCreateWithoutOpdVisitsInput, PatientUncheckedCreateWithoutOpdVisitsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutOpdVisitsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutOpdVisitsInput, PatientUncheckedUpdateWithoutOpdVisitsInput>
  }

  export type PatientUpdateWithoutOpdVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutOpdVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StaffProfileUpsertWithoutOpdVisitsInput = {
    update: XOR<StaffProfileUpdateWithoutOpdVisitsInput, StaffProfileUncheckedUpdateWithoutOpdVisitsInput>
    create: XOR<StaffProfileCreateWithoutOpdVisitsInput, StaffProfileUncheckedCreateWithoutOpdVisitsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutOpdVisitsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutOpdVisitsInput, StaffProfileUncheckedUpdateWithoutOpdVisitsInput>
  }

  export type StaffProfileUpdateWithoutOpdVisitsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutOpdVisitsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutVisitInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutVisitInput, ClinicalNoteUncheckedUpdateWithoutVisitInput>
    create: XOR<ClinicalNoteCreateWithoutVisitInput, ClinicalNoteUncheckedCreateWithoutVisitInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutVisitInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutVisitInput, ClinicalNoteUncheckedUpdateWithoutVisitInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutVisitInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutVisitInput>
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutVisitInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutVisitInput, ServiceOrderUncheckedUpdateWithoutVisitInput>
    create: XOR<ServiceOrderCreateWithoutVisitInput, ServiceOrderUncheckedCreateWithoutVisitInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutVisitInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutVisitInput, ServiceOrderUncheckedUpdateWithoutVisitInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutVisitInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutVisitInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutVisitInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutVisitInput, PrescriptionUncheckedUpdateWithoutVisitInput>
    create: XOR<PrescriptionCreateWithoutVisitInput, PrescriptionUncheckedCreateWithoutVisitInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutVisitInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutVisitInput, PrescriptionUncheckedUpdateWithoutVisitInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutVisitInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutVisitInput>
  }

  export type PatientDocumentUpsertWithWhereUniqueWithoutVisitInput = {
    where: PatientDocumentWhereUniqueInput
    update: XOR<PatientDocumentUpdateWithoutVisitInput, PatientDocumentUncheckedUpdateWithoutVisitInput>
    create: XOR<PatientDocumentCreateWithoutVisitInput, PatientDocumentUncheckedCreateWithoutVisitInput>
  }

  export type PatientDocumentUpdateWithWhereUniqueWithoutVisitInput = {
    where: PatientDocumentWhereUniqueInput
    data: XOR<PatientDocumentUpdateWithoutVisitInput, PatientDocumentUncheckedUpdateWithoutVisitInput>
  }

  export type PatientDocumentUpdateManyWithWhereWithoutVisitInput = {
    where: PatientDocumentScalarWhereInput
    data: XOR<PatientDocumentUpdateManyMutationInput, PatientDocumentUncheckedUpdateManyWithoutVisitInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutVisitInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutVisitInput, InvoiceUncheckedUpdateWithoutVisitInput>
    create: XOR<InvoiceCreateWithoutVisitInput, InvoiceUncheckedCreateWithoutVisitInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutVisitInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutVisitInput, InvoiceUncheckedUpdateWithoutVisitInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutVisitInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutVisitInput>
  }

  export type AdmissionUpsertWithoutVisitInput = {
    update: XOR<AdmissionUpdateWithoutVisitInput, AdmissionUncheckedUpdateWithoutVisitInput>
    create: XOR<AdmissionCreateWithoutVisitInput, AdmissionUncheckedCreateWithoutVisitInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutVisitInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutVisitInput, AdmissionUncheckedUpdateWithoutVisitInput>
  }

  export type AdmissionUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type PatientCreateWithoutAdmissionsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAdmissionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
  }

  export type StaffProfileCreateWithoutAdmissionsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutAdmissionsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutAdmissionsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutAdmissionsInput, StaffProfileUncheckedCreateWithoutAdmissionsInput>
  }

  export type DepartmentCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
    headDoctor?: StaffProfileCreateNestedOneWithoutHeadOfDepartmentsInput
    staff?: StaffProfileCreateNestedManyWithoutDepartmentInput
    services?: ServiceCreateNestedManyWithoutDepartmentInput
    wards?: WardCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutAdmissionsInput = {
    id?: string
    name: string
    code: string
    headDoctorId?: string | null
    type: $Enums.DepartmentType
    staff?: StaffProfileUncheckedCreateNestedManyWithoutDepartmentInput
    services?: ServiceUncheckedCreateNestedManyWithoutDepartmentInput
    wards?: WardUncheckedCreateNestedManyWithoutDepartmentInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutAdmissionsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
  }

  export type OpdVisitCreateWithoutAdmissionInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutAdmissionInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutAdmissionInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutAdmissionInput, OpdVisitUncheckedCreateWithoutAdmissionInput>
  }

  export type BedCreateWithoutActiveAdmissionsInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
    ward: WardCreateNestedOneWithoutBedsInput
    transfers?: BedTransferCreateNestedManyWithoutBedInput
  }

  export type BedUncheckedCreateWithoutActiveAdmissionsInput = {
    id?: string
    wardId: string
    bedNumber: string
    status: $Enums.BedStatus
    transfers?: BedTransferUncheckedCreateNestedManyWithoutBedInput
  }

  export type BedCreateOrConnectWithoutActiveAdmissionsInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutActiveAdmissionsInput, BedUncheckedCreateWithoutActiveAdmissionsInput>
  }

  export type BedTransferCreateWithoutAdmissionInput = {
    id?: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
    bed: BedCreateNestedOneWithoutTransfersInput
  }

  export type BedTransferUncheckedCreateWithoutAdmissionInput = {
    id?: string
    bedId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type BedTransferCreateOrConnectWithoutAdmissionInput = {
    where: BedTransferWhereUniqueInput
    create: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput>
  }

  export type BedTransferCreateManyAdmissionInputEnvelope = {
    data: BedTransferCreateManyAdmissionInput | BedTransferCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type SurgeryCreateWithoutAdmissionInput = {
    id?: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    surgeon: StaffProfileCreateNestedOneWithoutSurgeriesInput
    checklists?: SurgicalChecklistCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUncheckedCreateWithoutAdmissionInput = {
    id?: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    checklists?: SurgicalChecklistUncheckedCreateNestedManyWithoutSurgeryInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryCreateOrConnectWithoutAdmissionInput = {
    where: SurgeryWhereUniqueInput
    create: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput>
  }

  export type SurgeryCreateManyAdmissionInputEnvelope = {
    data: SurgeryCreateManyAdmissionInput | SurgeryCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type ClinicalNoteCreateWithoutAdmissionInput = {
    id?: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
    patient: PatientCreateNestedOneWithoutClinicalNotesInput
    visit?: OpdVisitCreateNestedOneWithoutClinicalNotesInput
    doctor: StaffProfileCreateNestedOneWithoutClinicalNotesInput
  }

  export type ClinicalNoteUncheckedCreateWithoutAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ClinicalNoteCreateOrConnectWithoutAdmissionInput = {
    where: ClinicalNoteWhereUniqueInput
    create: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput>
  }

  export type ClinicalNoteCreateManyAdmissionInputEnvelope = {
    data: ClinicalNoteCreateManyAdmissionInput | ClinicalNoteCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type ServiceOrderCreateWithoutAdmissionInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutAdmissionInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutAdmissionInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput>
  }

  export type ServiceOrderCreateManyAdmissionInputEnvelope = {
    data: ServiceOrderCreateManyAdmissionInput | ServiceOrderCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionCreateWithoutAdmissionInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutAdmissionInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutAdmissionInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput>
  }

  export type PrescriptionCreateManyAdmissionInputEnvelope = {
    data: PrescriptionCreateManyAdmissionInput | PrescriptionCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type PatientDocumentCreateWithoutAdmissionInput = {
    id?: string
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
    patient: PatientCreateNestedOneWithoutDocumentsInput
    visit?: OpdVisitCreateNestedOneWithoutDocumentsInput
  }

  export type PatientDocumentUncheckedCreateWithoutAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type PatientDocumentCreateOrConnectWithoutAdmissionInput = {
    where: PatientDocumentWhereUniqueInput
    create: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput>
  }

  export type PatientDocumentCreateManyAdmissionInputEnvelope = {
    data: PatientDocumentCreateManyAdmissionInput | PatientDocumentCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutAdmissionInput = {
    id?: string
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    patient: PatientCreateNestedOneWithoutInvoicesInput
    visit?: OpdVisitCreateNestedOneWithoutInvoicesInput
    items?: InvoiceItemCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutAdmissionInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput>
  }

  export type InvoiceCreateManyAdmissionInputEnvelope = {
    data: InvoiceCreateManyAdmissionInput | InvoiceCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type InsuranceClaimCreateWithoutAdmissionInput = {
    id?: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
  }

  export type InsuranceClaimUncheckedCreateWithoutAdmissionInput = {
    id?: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
  }

  export type InsuranceClaimCreateOrConnectWithoutAdmissionInput = {
    where: InsuranceClaimWhereUniqueInput
    create: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput>
  }

  export type InsuranceClaimCreateManyAdmissionInputEnvelope = {
    data: InsuranceClaimCreateManyAdmissionInput | InsuranceClaimCreateManyAdmissionInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutAdmissionsInput = {
    update: XOR<PatientUpdateWithoutAdmissionsInput, PatientUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<PatientCreateWithoutAdmissionsInput, PatientUncheckedCreateWithoutAdmissionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAdmissionsInput, PatientUncheckedUpdateWithoutAdmissionsInput>
  }

  export type PatientUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StaffProfileUpsertWithoutAdmissionsInput = {
    update: XOR<StaffProfileUpdateWithoutAdmissionsInput, StaffProfileUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<StaffProfileCreateWithoutAdmissionsInput, StaffProfileUncheckedCreateWithoutAdmissionsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutAdmissionsInput, StaffProfileUncheckedUpdateWithoutAdmissionsInput>
  }

  export type StaffProfileUpdateWithoutAdmissionsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type DepartmentUpsertWithoutAdmissionsInput = {
    update: XOR<DepartmentUpdateWithoutAdmissionsInput, DepartmentUncheckedUpdateWithoutAdmissionsInput>
    create: XOR<DepartmentCreateWithoutAdmissionsInput, DepartmentUncheckedCreateWithoutAdmissionsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutAdmissionsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutAdmissionsInput, DepartmentUncheckedUpdateWithoutAdmissionsInput>
  }

  export type DepartmentUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    headDoctor?: StaffProfileUpdateOneWithoutHeadOfDepartmentsNestedInput
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    headDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type OpdVisitUpsertWithoutAdmissionInput = {
    update: XOR<OpdVisitUpdateWithoutAdmissionInput, OpdVisitUncheckedUpdateWithoutAdmissionInput>
    create: XOR<OpdVisitCreateWithoutAdmissionInput, OpdVisitUncheckedCreateWithoutAdmissionInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutAdmissionInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutAdmissionInput, OpdVisitUncheckedUpdateWithoutAdmissionInput>
  }

  export type OpdVisitUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
  }

  export type BedUpsertWithoutActiveAdmissionsInput = {
    update: XOR<BedUpdateWithoutActiveAdmissionsInput, BedUncheckedUpdateWithoutActiveAdmissionsInput>
    create: XOR<BedCreateWithoutActiveAdmissionsInput, BedUncheckedCreateWithoutActiveAdmissionsInput>
    where?: BedWhereInput
  }

  export type BedUpdateToOneWithWhereWithoutActiveAdmissionsInput = {
    where?: BedWhereInput
    data: XOR<BedUpdateWithoutActiveAdmissionsInput, BedUncheckedUpdateWithoutActiveAdmissionsInput>
  }

  export type BedUpdateWithoutActiveAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    transfers?: BedTransferUpdateManyWithoutBedNestedInput
  }

  export type BedUncheckedUpdateWithoutActiveAdmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    transfers?: BedTransferUncheckedUpdateManyWithoutBedNestedInput
  }

  export type BedTransferUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: BedTransferWhereUniqueInput
    update: XOR<BedTransferUpdateWithoutAdmissionInput, BedTransferUncheckedUpdateWithoutAdmissionInput>
    create: XOR<BedTransferCreateWithoutAdmissionInput, BedTransferUncheckedCreateWithoutAdmissionInput>
  }

  export type BedTransferUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: BedTransferWhereUniqueInput
    data: XOR<BedTransferUpdateWithoutAdmissionInput, BedTransferUncheckedUpdateWithoutAdmissionInput>
  }

  export type BedTransferUpdateManyWithWhereWithoutAdmissionInput = {
    where: BedTransferScalarWhereInput
    data: XOR<BedTransferUpdateManyMutationInput, BedTransferUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type SurgeryUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: SurgeryWhereUniqueInput
    update: XOR<SurgeryUpdateWithoutAdmissionInput, SurgeryUncheckedUpdateWithoutAdmissionInput>
    create: XOR<SurgeryCreateWithoutAdmissionInput, SurgeryUncheckedCreateWithoutAdmissionInput>
  }

  export type SurgeryUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: SurgeryWhereUniqueInput
    data: XOR<SurgeryUpdateWithoutAdmissionInput, SurgeryUncheckedUpdateWithoutAdmissionInput>
  }

  export type SurgeryUpdateManyWithWhereWithoutAdmissionInput = {
    where: SurgeryScalarWhereInput
    data: XOR<SurgeryUpdateManyMutationInput, SurgeryUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type ClinicalNoteUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: ClinicalNoteWhereUniqueInput
    update: XOR<ClinicalNoteUpdateWithoutAdmissionInput, ClinicalNoteUncheckedUpdateWithoutAdmissionInput>
    create: XOR<ClinicalNoteCreateWithoutAdmissionInput, ClinicalNoteUncheckedCreateWithoutAdmissionInput>
  }

  export type ClinicalNoteUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: ClinicalNoteWhereUniqueInput
    data: XOR<ClinicalNoteUpdateWithoutAdmissionInput, ClinicalNoteUncheckedUpdateWithoutAdmissionInput>
  }

  export type ClinicalNoteUpdateManyWithWhereWithoutAdmissionInput = {
    where: ClinicalNoteScalarWhereInput
    data: XOR<ClinicalNoteUpdateManyMutationInput, ClinicalNoteUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type ServiceOrderUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: ServiceOrderWhereUniqueInput
    update: XOR<ServiceOrderUpdateWithoutAdmissionInput, ServiceOrderUncheckedUpdateWithoutAdmissionInput>
    create: XOR<ServiceOrderCreateWithoutAdmissionInput, ServiceOrderUncheckedCreateWithoutAdmissionInput>
  }

  export type ServiceOrderUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: ServiceOrderWhereUniqueInput
    data: XOR<ServiceOrderUpdateWithoutAdmissionInput, ServiceOrderUncheckedUpdateWithoutAdmissionInput>
  }

  export type ServiceOrderUpdateManyWithWhereWithoutAdmissionInput = {
    where: ServiceOrderScalarWhereInput
    data: XOR<ServiceOrderUpdateManyMutationInput, ServiceOrderUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type PrescriptionUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: PrescriptionWhereUniqueInput
    update: XOR<PrescriptionUpdateWithoutAdmissionInput, PrescriptionUncheckedUpdateWithoutAdmissionInput>
    create: XOR<PrescriptionCreateWithoutAdmissionInput, PrescriptionUncheckedCreateWithoutAdmissionInput>
  }

  export type PrescriptionUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: PrescriptionWhereUniqueInput
    data: XOR<PrescriptionUpdateWithoutAdmissionInput, PrescriptionUncheckedUpdateWithoutAdmissionInput>
  }

  export type PrescriptionUpdateManyWithWhereWithoutAdmissionInput = {
    where: PrescriptionScalarWhereInput
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type PatientDocumentUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: PatientDocumentWhereUniqueInput
    update: XOR<PatientDocumentUpdateWithoutAdmissionInput, PatientDocumentUncheckedUpdateWithoutAdmissionInput>
    create: XOR<PatientDocumentCreateWithoutAdmissionInput, PatientDocumentUncheckedCreateWithoutAdmissionInput>
  }

  export type PatientDocumentUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: PatientDocumentWhereUniqueInput
    data: XOR<PatientDocumentUpdateWithoutAdmissionInput, PatientDocumentUncheckedUpdateWithoutAdmissionInput>
  }

  export type PatientDocumentUpdateManyWithWhereWithoutAdmissionInput = {
    where: PatientDocumentScalarWhereInput
    data: XOR<PatientDocumentUpdateManyMutationInput, PatientDocumentUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutAdmissionInput, InvoiceUncheckedUpdateWithoutAdmissionInput>
    create: XOR<InvoiceCreateWithoutAdmissionInput, InvoiceUncheckedCreateWithoutAdmissionInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutAdmissionInput, InvoiceUncheckedUpdateWithoutAdmissionInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutAdmissionInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type InsuranceClaimUpsertWithWhereUniqueWithoutAdmissionInput = {
    where: InsuranceClaimWhereUniqueInput
    update: XOR<InsuranceClaimUpdateWithoutAdmissionInput, InsuranceClaimUncheckedUpdateWithoutAdmissionInput>
    create: XOR<InsuranceClaimCreateWithoutAdmissionInput, InsuranceClaimUncheckedCreateWithoutAdmissionInput>
  }

  export type InsuranceClaimUpdateWithWhereUniqueWithoutAdmissionInput = {
    where: InsuranceClaimWhereUniqueInput
    data: XOR<InsuranceClaimUpdateWithoutAdmissionInput, InsuranceClaimUncheckedUpdateWithoutAdmissionInput>
  }

  export type InsuranceClaimUpdateManyWithWhereWithoutAdmissionInput = {
    where: InsuranceClaimScalarWhereInput
    data: XOR<InsuranceClaimUpdateManyMutationInput, InsuranceClaimUncheckedUpdateManyWithoutAdmissionInput>
  }

  export type InsuranceClaimScalarWhereInput = {
    AND?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
    OR?: InsuranceClaimScalarWhereInput[]
    NOT?: InsuranceClaimScalarWhereInput | InsuranceClaimScalarWhereInput[]
    id?: StringFilter<"InsuranceClaim"> | string
    admissionId?: StringFilter<"InsuranceClaim"> | string
    providerName?: StringFilter<"InsuranceClaim"> | string
    policyNumber?: StringFilter<"InsuranceClaim"> | string
    claimAmount?: DecimalFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string
    approvedAmount?: DecimalNullableFilter<"InsuranceClaim"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFilter<"InsuranceClaim"> | $Enums.ClaimStatus
    submissionDate?: DateTimeFilter<"InsuranceClaim"> | Date | string
  }

  export type AdmissionCreateWithoutBedTransfersInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutBedTransfersInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutBedTransfersInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutBedTransfersInput, AdmissionUncheckedCreateWithoutBedTransfersInput>
  }

  export type BedCreateWithoutTransfersInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
    ward: WardCreateNestedOneWithoutBedsInput
    activeAdmissions?: AdmissionCreateNestedManyWithoutCurrentBedInput
  }

  export type BedUncheckedCreateWithoutTransfersInput = {
    id?: string
    wardId: string
    bedNumber: string
    status: $Enums.BedStatus
    activeAdmissions?: AdmissionUncheckedCreateNestedManyWithoutCurrentBedInput
  }

  export type BedCreateOrConnectWithoutTransfersInput = {
    where: BedWhereUniqueInput
    create: XOR<BedCreateWithoutTransfersInput, BedUncheckedCreateWithoutTransfersInput>
  }

  export type AdmissionUpsertWithoutBedTransfersInput = {
    update: XOR<AdmissionUpdateWithoutBedTransfersInput, AdmissionUncheckedUpdateWithoutBedTransfersInput>
    create: XOR<AdmissionCreateWithoutBedTransfersInput, AdmissionUncheckedCreateWithoutBedTransfersInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutBedTransfersInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutBedTransfersInput, AdmissionUncheckedUpdateWithoutBedTransfersInput>
  }

  export type AdmissionUpdateWithoutBedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutBedTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type BedUpsertWithoutTransfersInput = {
    update: XOR<BedUpdateWithoutTransfersInput, BedUncheckedUpdateWithoutTransfersInput>
    create: XOR<BedCreateWithoutTransfersInput, BedUncheckedCreateWithoutTransfersInput>
    where?: BedWhereInput
  }

  export type BedUpdateToOneWithWhereWithoutTransfersInput = {
    where?: BedWhereInput
    data: XOR<BedUpdateWithoutTransfersInput, BedUncheckedUpdateWithoutTransfersInput>
  }

  export type BedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    ward?: WardUpdateOneRequiredWithoutBedsNestedInput
    activeAdmissions?: AdmissionUpdateManyWithoutCurrentBedNestedInput
  }

  export type BedUncheckedUpdateWithoutTransfersInput = {
    id?: StringFieldUpdateOperationsInput | string
    wardId?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    activeAdmissions?: AdmissionUncheckedUpdateManyWithoutCurrentBedNestedInput
  }

  export type AdmissionCreateWithoutSurgeriesInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutSurgeriesInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutSurgeriesInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutSurgeriesInput, AdmissionUncheckedCreateWithoutSurgeriesInput>
  }

  export type StaffProfileCreateWithoutSurgeriesInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutSurgeriesInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutSurgeriesInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutSurgeriesInput, StaffProfileUncheckedCreateWithoutSurgeriesInput>
  }

  export type SurgicalChecklistCreateWithoutSurgeryInput = {
    id?: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
  }

  export type SurgicalChecklistUncheckedCreateWithoutSurgeryInput = {
    id?: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
  }

  export type SurgicalChecklistCreateOrConnectWithoutSurgeryInput = {
    where: SurgicalChecklistWhereUniqueInput
    create: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput>
  }

  export type SurgicalChecklistCreateManySurgeryInputEnvelope = {
    data: SurgicalChecklistCreateManySurgeryInput | SurgicalChecklistCreateManySurgeryInput[]
    skipDuplicates?: boolean
  }

  export type SurgerySStaffCreateWithoutSurgeryInput = {
    role: string
    staff: StaffProfileCreateNestedOneWithoutSurgerySStaffsInput
  }

  export type SurgerySStaffUncheckedCreateWithoutSurgeryInput = {
    staffId: string
    role: string
  }

  export type SurgerySStaffCreateOrConnectWithoutSurgeryInput = {
    where: SurgerySStaffWhereUniqueInput
    create: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput>
  }

  export type SurgerySStaffCreateManySurgeryInputEnvelope = {
    data: SurgerySStaffCreateManySurgeryInput | SurgerySStaffCreateManySurgeryInput[]
    skipDuplicates?: boolean
  }

  export type AdmissionUpsertWithoutSurgeriesInput = {
    update: XOR<AdmissionUpdateWithoutSurgeriesInput, AdmissionUncheckedUpdateWithoutSurgeriesInput>
    create: XOR<AdmissionCreateWithoutSurgeriesInput, AdmissionUncheckedCreateWithoutSurgeriesInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutSurgeriesInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutSurgeriesInput, AdmissionUncheckedUpdateWithoutSurgeriesInput>
  }

  export type AdmissionUpdateWithoutSurgeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutSurgeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type StaffProfileUpsertWithoutSurgeriesInput = {
    update: XOR<StaffProfileUpdateWithoutSurgeriesInput, StaffProfileUncheckedUpdateWithoutSurgeriesInput>
    create: XOR<StaffProfileCreateWithoutSurgeriesInput, StaffProfileUncheckedCreateWithoutSurgeriesInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutSurgeriesInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutSurgeriesInput, StaffProfileUncheckedUpdateWithoutSurgeriesInput>
  }

  export type StaffProfileUpdateWithoutSurgeriesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutSurgeriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type SurgicalChecklistUpsertWithWhereUniqueWithoutSurgeryInput = {
    where: SurgicalChecklistWhereUniqueInput
    update: XOR<SurgicalChecklistUpdateWithoutSurgeryInput, SurgicalChecklistUncheckedUpdateWithoutSurgeryInput>
    create: XOR<SurgicalChecklistCreateWithoutSurgeryInput, SurgicalChecklistUncheckedCreateWithoutSurgeryInput>
  }

  export type SurgicalChecklistUpdateWithWhereUniqueWithoutSurgeryInput = {
    where: SurgicalChecklistWhereUniqueInput
    data: XOR<SurgicalChecklistUpdateWithoutSurgeryInput, SurgicalChecklistUncheckedUpdateWithoutSurgeryInput>
  }

  export type SurgicalChecklistUpdateManyWithWhereWithoutSurgeryInput = {
    where: SurgicalChecklistScalarWhereInput
    data: XOR<SurgicalChecklistUpdateManyMutationInput, SurgicalChecklistUncheckedUpdateManyWithoutSurgeryInput>
  }

  export type SurgicalChecklistScalarWhereInput = {
    AND?: SurgicalChecklistScalarWhereInput | SurgicalChecklistScalarWhereInput[]
    OR?: SurgicalChecklistScalarWhereInput[]
    NOT?: SurgicalChecklistScalarWhereInput | SurgicalChecklistScalarWhereInput[]
    id?: StringFilter<"SurgicalChecklist"> | string
    surgeryId?: StringFilter<"SurgicalChecklist"> | string
    stage?: EnumChecklistStageFilter<"SurgicalChecklist"> | $Enums.ChecklistStage
    itemName?: StringFilter<"SurgicalChecklist"> | string
    isChecked?: BoolFilter<"SurgicalChecklist"> | boolean
    checkedBy?: StringNullableFilter<"SurgicalChecklist"> | string | null
    timestamp?: DateTimeFilter<"SurgicalChecklist"> | Date | string
  }

  export type SurgerySStaffUpsertWithWhereUniqueWithoutSurgeryInput = {
    where: SurgerySStaffWhereUniqueInput
    update: XOR<SurgerySStaffUpdateWithoutSurgeryInput, SurgerySStaffUncheckedUpdateWithoutSurgeryInput>
    create: XOR<SurgerySStaffCreateWithoutSurgeryInput, SurgerySStaffUncheckedCreateWithoutSurgeryInput>
  }

  export type SurgerySStaffUpdateWithWhereUniqueWithoutSurgeryInput = {
    where: SurgerySStaffWhereUniqueInput
    data: XOR<SurgerySStaffUpdateWithoutSurgeryInput, SurgerySStaffUncheckedUpdateWithoutSurgeryInput>
  }

  export type SurgerySStaffUpdateManyWithWhereWithoutSurgeryInput = {
    where: SurgerySStaffScalarWhereInput
    data: XOR<SurgerySStaffUpdateManyMutationInput, SurgerySStaffUncheckedUpdateManyWithoutSurgeryInput>
  }

  export type SurgeryCreateWithoutSurgerySStaffsInput = {
    id?: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    admission: AdmissionCreateNestedOneWithoutSurgeriesInput
    surgeon: StaffProfileCreateNestedOneWithoutSurgeriesInput
    checklists?: SurgicalChecklistCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUncheckedCreateWithoutSurgerySStaffsInput = {
    id?: string
    admissionId: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    checklists?: SurgicalChecklistUncheckedCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryCreateOrConnectWithoutSurgerySStaffsInput = {
    where: SurgeryWhereUniqueInput
    create: XOR<SurgeryCreateWithoutSurgerySStaffsInput, SurgeryUncheckedCreateWithoutSurgerySStaffsInput>
  }

  export type StaffProfileCreateWithoutSurgerySStaffsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
  }

  export type StaffProfileUncheckedCreateWithoutSurgerySStaffsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type StaffProfileCreateOrConnectWithoutSurgerySStaffsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutSurgerySStaffsInput, StaffProfileUncheckedCreateWithoutSurgerySStaffsInput>
  }

  export type SurgeryUpsertWithoutSurgerySStaffsInput = {
    update: XOR<SurgeryUpdateWithoutSurgerySStaffsInput, SurgeryUncheckedUpdateWithoutSurgerySStaffsInput>
    create: XOR<SurgeryCreateWithoutSurgerySStaffsInput, SurgeryUncheckedCreateWithoutSurgerySStaffsInput>
    where?: SurgeryWhereInput
  }

  export type SurgeryUpdateToOneWithWhereWithoutSurgerySStaffsInput = {
    where?: SurgeryWhereInput
    data: XOR<SurgeryUpdateWithoutSurgerySStaffsInput, SurgeryUncheckedUpdateWithoutSurgerySStaffsInput>
  }

  export type SurgeryUpdateWithoutSurgerySStaffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutSurgeriesNestedInput
    surgeon?: StaffProfileUpdateOneRequiredWithoutSurgeriesNestedInput
    checklists?: SurgicalChecklistUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateWithoutSurgerySStaffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checklists?: SurgicalChecklistUncheckedUpdateManyWithoutSurgeryNestedInput
  }

  export type StaffProfileUpsertWithoutSurgerySStaffsInput = {
    update: XOR<StaffProfileUpdateWithoutSurgerySStaffsInput, StaffProfileUncheckedUpdateWithoutSurgerySStaffsInput>
    create: XOR<StaffProfileCreateWithoutSurgerySStaffsInput, StaffProfileUncheckedCreateWithoutSurgerySStaffsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutSurgerySStaffsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutSurgerySStaffsInput, StaffProfileUncheckedUpdateWithoutSurgerySStaffsInput>
  }

  export type StaffProfileUpdateWithoutSurgerySStaffsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutSurgerySStaffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type SurgeryCreateWithoutChecklistsInput = {
    id?: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    admission: AdmissionCreateNestedOneWithoutSurgeriesInput
    surgeon: StaffProfileCreateNestedOneWithoutSurgeriesInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryUncheckedCreateWithoutChecklistsInput = {
    id?: string
    admissionId: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutSurgeryInput
  }

  export type SurgeryCreateOrConnectWithoutChecklistsInput = {
    where: SurgeryWhereUniqueInput
    create: XOR<SurgeryCreateWithoutChecklistsInput, SurgeryUncheckedCreateWithoutChecklistsInput>
  }

  export type SurgeryUpsertWithoutChecklistsInput = {
    update: XOR<SurgeryUpdateWithoutChecklistsInput, SurgeryUncheckedUpdateWithoutChecklistsInput>
    create: XOR<SurgeryCreateWithoutChecklistsInput, SurgeryUncheckedCreateWithoutChecklistsInput>
    where?: SurgeryWhereInput
  }

  export type SurgeryUpdateToOneWithWhereWithoutChecklistsInput = {
    where?: SurgeryWhereInput
    data: XOR<SurgeryUpdateWithoutChecklistsInput, SurgeryUncheckedUpdateWithoutChecklistsInput>
  }

  export type SurgeryUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutSurgeriesNestedInput
    surgeon?: StaffProfileUpdateOneRequiredWithoutSurgeriesNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateWithoutChecklistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutSurgeryNestedInput
  }

  export type PatientCreateWithoutClinicalNotesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutClinicalNotesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutClinicalNotesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
  }

  export type OpdVisitCreateWithoutClinicalNotesInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutClinicalNotesInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutClinicalNotesInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutClinicalNotesInput, OpdVisitUncheckedCreateWithoutClinicalNotesInput>
  }

  export type AdmissionCreateWithoutClinicalNotesInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutClinicalNotesInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutClinicalNotesInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutClinicalNotesInput, AdmissionUncheckedCreateWithoutClinicalNotesInput>
  }

  export type StaffProfileCreateWithoutClinicalNotesInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutClinicalNotesInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutClinicalNotesInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutClinicalNotesInput, StaffProfileUncheckedCreateWithoutClinicalNotesInput>
  }

  export type PatientUpsertWithoutClinicalNotesInput = {
    update: XOR<PatientUpdateWithoutClinicalNotesInput, PatientUncheckedUpdateWithoutClinicalNotesInput>
    create: XOR<PatientCreateWithoutClinicalNotesInput, PatientUncheckedCreateWithoutClinicalNotesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutClinicalNotesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutClinicalNotesInput, PatientUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type PatientUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type OpdVisitUpsertWithoutClinicalNotesInput = {
    update: XOR<OpdVisitUpdateWithoutClinicalNotesInput, OpdVisitUncheckedUpdateWithoutClinicalNotesInput>
    create: XOR<OpdVisitCreateWithoutClinicalNotesInput, OpdVisitUncheckedCreateWithoutClinicalNotesInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutClinicalNotesInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutClinicalNotesInput, OpdVisitUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type OpdVisitUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type AdmissionUpsertWithoutClinicalNotesInput = {
    update: XOR<AdmissionUpdateWithoutClinicalNotesInput, AdmissionUncheckedUpdateWithoutClinicalNotesInput>
    create: XOR<AdmissionCreateWithoutClinicalNotesInput, AdmissionUncheckedCreateWithoutClinicalNotesInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutClinicalNotesInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutClinicalNotesInput, AdmissionUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type AdmissionUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type StaffProfileUpsertWithoutClinicalNotesInput = {
    update: XOR<StaffProfileUpdateWithoutClinicalNotesInput, StaffProfileUncheckedUpdateWithoutClinicalNotesInput>
    create: XOR<StaffProfileCreateWithoutClinicalNotesInput, StaffProfileUncheckedCreateWithoutClinicalNotesInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutClinicalNotesInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutClinicalNotesInput, StaffProfileUncheckedUpdateWithoutClinicalNotesInput>
  }

  export type StaffProfileUpdateWithoutClinicalNotesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutClinicalNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PatientCreateWithoutServiceOrdersInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutServiceOrdersInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutServiceOrdersInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutServiceOrdersInput, PatientUncheckedCreateWithoutServiceOrdersInput>
  }

  export type StaffProfileCreateWithoutServiceOrdersInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutServiceOrdersInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutServiceOrdersInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutServiceOrdersInput, StaffProfileUncheckedCreateWithoutServiceOrdersInput>
  }

  export type OpdVisitCreateWithoutServiceOrdersInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutServiceOrdersInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutServiceOrdersInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutServiceOrdersInput, OpdVisitUncheckedCreateWithoutServiceOrdersInput>
  }

  export type AdmissionCreateWithoutServiceOrdersInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutServiceOrdersInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutServiceOrdersInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutServiceOrdersInput, AdmissionUncheckedCreateWithoutServiceOrdersInput>
  }

  export type ServiceCreateWithoutServiceOrdersInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    department: DepartmentCreateNestedOneWithoutServicesInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceOrdersInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    departmentId: string
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceOrdersInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceOrdersInput, ServiceUncheckedCreateWithoutServiceOrdersInput>
  }

  export type LabResultCreateWithoutServiceOrderInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    resultDate?: Date | string
    technician?: UserCreateNestedOneWithoutLabResultsInput
    verifiedBy?: StaffProfileCreateNestedOneWithoutVerifiedResultsInput
  }

  export type LabResultUncheckedCreateWithoutServiceOrderInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type LabResultCreateOrConnectWithoutServiceOrderInput = {
    where: LabResultWhereUniqueInput
    create: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput>
  }

  export type LabResultCreateManyServiceOrderInputEnvelope = {
    data: LabResultCreateManyServiceOrderInput | LabResultCreateManyServiceOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceItemCreateWithoutServiceOrderInput = {
    id?: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    invoice: InvoiceCreateNestedOneWithoutItemsInput
    service: ServiceCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutServiceOrderInput = {
    id?: string
    invoiceId: string
    serviceId: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutServiceOrderInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput>
  }

  export type InvoiceItemCreateManyServiceOrderInputEnvelope = {
    data: InvoiceItemCreateManyServiceOrderInput | InvoiceItemCreateManyServiceOrderInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutServiceOrdersInput = {
    update: XOR<PatientUpdateWithoutServiceOrdersInput, PatientUncheckedUpdateWithoutServiceOrdersInput>
    create: XOR<PatientCreateWithoutServiceOrdersInput, PatientUncheckedCreateWithoutServiceOrdersInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutServiceOrdersInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutServiceOrdersInput, PatientUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type PatientUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StaffProfileUpsertWithoutServiceOrdersInput = {
    update: XOR<StaffProfileUpdateWithoutServiceOrdersInput, StaffProfileUncheckedUpdateWithoutServiceOrdersInput>
    create: XOR<StaffProfileCreateWithoutServiceOrdersInput, StaffProfileUncheckedCreateWithoutServiceOrdersInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutServiceOrdersInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutServiceOrdersInput, StaffProfileUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type StaffProfileUpdateWithoutServiceOrdersInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type OpdVisitUpsertWithoutServiceOrdersInput = {
    update: XOR<OpdVisitUpdateWithoutServiceOrdersInput, OpdVisitUncheckedUpdateWithoutServiceOrdersInput>
    create: XOR<OpdVisitCreateWithoutServiceOrdersInput, OpdVisitUncheckedCreateWithoutServiceOrdersInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutServiceOrdersInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutServiceOrdersInput, OpdVisitUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type OpdVisitUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type AdmissionUpsertWithoutServiceOrdersInput = {
    update: XOR<AdmissionUpdateWithoutServiceOrdersInput, AdmissionUncheckedUpdateWithoutServiceOrdersInput>
    create: XOR<AdmissionCreateWithoutServiceOrdersInput, AdmissionUncheckedCreateWithoutServiceOrdersInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutServiceOrdersInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutServiceOrdersInput, AdmissionUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type AdmissionUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type ServiceUpsertWithoutServiceOrdersInput = {
    update: XOR<ServiceUpdateWithoutServiceOrdersInput, ServiceUncheckedUpdateWithoutServiceOrdersInput>
    create: XOR<ServiceCreateWithoutServiceOrdersInput, ServiceUncheckedCreateWithoutServiceOrdersInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceOrdersInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceOrdersInput, ServiceUncheckedUpdateWithoutServiceOrdersInput>
  }

  export type ServiceUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: StringFieldUpdateOperationsInput | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type LabResultUpsertWithWhereUniqueWithoutServiceOrderInput = {
    where: LabResultWhereUniqueInput
    update: XOR<LabResultUpdateWithoutServiceOrderInput, LabResultUncheckedUpdateWithoutServiceOrderInput>
    create: XOR<LabResultCreateWithoutServiceOrderInput, LabResultUncheckedCreateWithoutServiceOrderInput>
  }

  export type LabResultUpdateWithWhereUniqueWithoutServiceOrderInput = {
    where: LabResultWhereUniqueInput
    data: XOR<LabResultUpdateWithoutServiceOrderInput, LabResultUncheckedUpdateWithoutServiceOrderInput>
  }

  export type LabResultUpdateManyWithWhereWithoutServiceOrderInput = {
    where: LabResultScalarWhereInput
    data: XOR<LabResultUpdateManyMutationInput, LabResultUncheckedUpdateManyWithoutServiceOrderInput>
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutServiceOrderInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutServiceOrderInput, InvoiceItemUncheckedUpdateWithoutServiceOrderInput>
    create: XOR<InvoiceItemCreateWithoutServiceOrderInput, InvoiceItemUncheckedCreateWithoutServiceOrderInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutServiceOrderInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutServiceOrderInput, InvoiceItemUncheckedUpdateWithoutServiceOrderInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutServiceOrderInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutServiceOrderInput>
  }

  export type ServiceOrderCreateWithoutLabResultsInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    invoiceItems?: InvoiceItemCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutLabResultsInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    invoiceItems?: InvoiceItemUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutLabResultsInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutLabResultsInput, ServiceOrderUncheckedCreateWithoutLabResultsInput>
  }

  export type UserCreateWithoutLabResultsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLabResultsInput = {
    id?: string
    email: string
    passwordHash: string
    role: $Enums.UserRole
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLabResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabResultsInput, UserUncheckedCreateWithoutLabResultsInput>
  }

  export type StaffProfileCreateWithoutVerifiedResultsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutVerifiedResultsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutDoctorInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutVerifiedResultsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutVerifiedResultsInput, StaffProfileUncheckedCreateWithoutVerifiedResultsInput>
  }

  export type ServiceOrderUpsertWithoutLabResultsInput = {
    update: XOR<ServiceOrderUpdateWithoutLabResultsInput, ServiceOrderUncheckedUpdateWithoutLabResultsInput>
    create: XOR<ServiceOrderCreateWithoutLabResultsInput, ServiceOrderUncheckedCreateWithoutLabResultsInput>
    where?: ServiceOrderWhereInput
  }

  export type ServiceOrderUpdateToOneWithWhereWithoutLabResultsInput = {
    where?: ServiceOrderWhereInput
    data: XOR<ServiceOrderUpdateWithoutLabResultsInput, ServiceOrderUncheckedUpdateWithoutLabResultsInput>
  }

  export type ServiceOrderUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type UserUpsertWithoutLabResultsInput = {
    update: XOR<UserUpdateWithoutLabResultsInput, UserUncheckedUpdateWithoutLabResultsInput>
    create: XOR<UserCreateWithoutLabResultsInput, UserUncheckedCreateWithoutLabResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabResultsInput, UserUncheckedUpdateWithoutLabResultsInput>
  }

  export type UserUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLabResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StaffProfileUpsertWithoutVerifiedResultsInput = {
    update: XOR<StaffProfileUpdateWithoutVerifiedResultsInput, StaffProfileUncheckedUpdateWithoutVerifiedResultsInput>
    create: XOR<StaffProfileCreateWithoutVerifiedResultsInput, StaffProfileUncheckedCreateWithoutVerifiedResultsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutVerifiedResultsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutVerifiedResultsInput, StaffProfileUncheckedUpdateWithoutVerifiedResultsInput>
  }

  export type StaffProfileUpdateWithoutVerifiedResultsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutVerifiedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type PatientCreateWithoutPrescriptionsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPrescriptionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
  }

  export type StaffProfileCreateWithoutPrescriptionsInput = {
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    user: UserCreateNestedOneWithoutStaffProfileInput
    department?: DepartmentCreateNestedOneWithoutStaffInput
    headOfDepartments?: DepartmentCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultCreateNestedManyWithoutVerifiedByInput
    surgerySStaffs?: SurgerySStaffCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutPrescriptionsInput = {
    id: string
    departmentId?: string | null
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
    headOfDepartments?: DepartmentUncheckedCreateNestedManyWithoutHeadDoctorInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutDoctorInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutAdmittingDoctorInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutSurgeonInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutDoctorInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutDoctorInput
    verifiedResults?: LabResultUncheckedCreateNestedManyWithoutVerifiedByInput
    surgerySStaffs?: SurgerySStaffUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutPrescriptionsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutPrescriptionsInput, StaffProfileUncheckedCreateWithoutPrescriptionsInput>
  }

  export type OpdVisitCreateWithoutPrescriptionsInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    invoices?: InvoiceCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutPrescriptionsInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutPrescriptionsInput, OpdVisitUncheckedCreateWithoutPrescriptionsInput>
  }

  export type AdmissionCreateWithoutPrescriptionsInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutPrescriptionsInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutPrescriptionsInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutPrescriptionsInput, AdmissionUncheckedCreateWithoutPrescriptionsInput>
  }

  export type PrescriptionItemCreateWithoutPrescriptionInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
    medicine: MedicineCreateNestedOneWithoutPrescriptionItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    medicineId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type PrescriptionItemCreateOrConnectWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemCreateManyPrescriptionInputEnvelope = {
    data: PrescriptionItemCreateManyPrescriptionInput | PrescriptionItemCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PharmacySaleCreateWithoutPrescriptionInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    patient: PatientCreateNestedOneWithoutPharmacySalesInput
    items?: SaleItemCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleUncheckedCreateWithoutPrescriptionInput = {
    id?: string
    patientId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedCreateNestedManyWithoutPharmacySaleInput
  }

  export type PharmacySaleCreateOrConnectWithoutPrescriptionInput = {
    where: PharmacySaleWhereUniqueInput
    create: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput>
  }

  export type PharmacySaleCreateManyPrescriptionInputEnvelope = {
    data: PharmacySaleCreateManyPrescriptionInput | PharmacySaleCreateManyPrescriptionInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPrescriptionsInput = {
    update: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<PatientCreateWithoutPrescriptionsInput, PatientUncheckedCreateWithoutPrescriptionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPrescriptionsInput, PatientUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type PatientUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type StaffProfileUpsertWithoutPrescriptionsInput = {
    update: XOR<StaffProfileUpdateWithoutPrescriptionsInput, StaffProfileUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<StaffProfileCreateWithoutPrescriptionsInput, StaffProfileUncheckedCreateWithoutPrescriptionsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutPrescriptionsInput, StaffProfileUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type StaffProfileUpdateWithoutPrescriptionsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    department?: DepartmentUpdateOneWithoutStaffNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type OpdVisitUpsertWithoutPrescriptionsInput = {
    update: XOR<OpdVisitUpdateWithoutPrescriptionsInput, OpdVisitUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<OpdVisitCreateWithoutPrescriptionsInput, OpdVisitUncheckedCreateWithoutPrescriptionsInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutPrescriptionsInput, OpdVisitUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type OpdVisitUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type AdmissionUpsertWithoutPrescriptionsInput = {
    update: XOR<AdmissionUpdateWithoutPrescriptionsInput, AdmissionUncheckedUpdateWithoutPrescriptionsInput>
    create: XOR<AdmissionCreateWithoutPrescriptionsInput, AdmissionUncheckedCreateWithoutPrescriptionsInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutPrescriptionsInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutPrescriptionsInput, AdmissionUncheckedUpdateWithoutPrescriptionsInput>
  }

  export type AdmissionUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutPrescriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PrescriptionItemCreateWithoutPrescriptionInput, PrescriptionItemUncheckedCreateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutPrescriptionInput, PrescriptionItemUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionItemScalarWhereInput = {
    AND?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    OR?: PrescriptionItemScalarWhereInput[]
    NOT?: PrescriptionItemScalarWhereInput | PrescriptionItemScalarWhereInput[]
    id?: StringFilter<"PrescriptionItem"> | string
    prescriptionId?: StringFilter<"PrescriptionItem"> | string
    medicineId?: StringFilter<"PrescriptionItem"> | string
    dosage?: StringFilter<"PrescriptionItem"> | string
    frequency?: StringFilter<"PrescriptionItem"> | string
    duration?: StringFilter<"PrescriptionItem"> | string
    instruction?: StringNullableFilter<"PrescriptionItem"> | string | null
  }

  export type PharmacySaleUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: PharmacySaleWhereUniqueInput
    update: XOR<PharmacySaleUpdateWithoutPrescriptionInput, PharmacySaleUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<PharmacySaleCreateWithoutPrescriptionInput, PharmacySaleUncheckedCreateWithoutPrescriptionInput>
  }

  export type PharmacySaleUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: PharmacySaleWhereUniqueInput
    data: XOR<PharmacySaleUpdateWithoutPrescriptionInput, PharmacySaleUncheckedUpdateWithoutPrescriptionInput>
  }

  export type PharmacySaleUpdateManyWithWhereWithoutPrescriptionInput = {
    where: PharmacySaleScalarWhereInput
    data: XOR<PharmacySaleUpdateManyMutationInput, PharmacySaleUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type PrescriptionCreateWithoutItemsInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    sales?: PharmacySaleCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutItemsInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    sales?: PharmacySaleUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutItemsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
  }

  export type MedicineCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    saleItems?: SaleItemCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutPrescriptionItemsInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    saleItems?: SaleItemUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutPrescriptionItemsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutPrescriptionItemsInput, MedicineUncheckedCreateWithoutPrescriptionItemsInput>
  }

  export type PrescriptionUpsertWithoutItemsInput = {
    update: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
    create: XOR<PrescriptionCreateWithoutItemsInput, PrescriptionUncheckedCreateWithoutItemsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutItemsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutItemsInput, PrescriptionUncheckedUpdateWithoutItemsInput>
  }

  export type PrescriptionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type MedicineUpsertWithoutPrescriptionItemsInput = {
    update: XOR<MedicineUpdateWithoutPrescriptionItemsInput, MedicineUncheckedUpdateWithoutPrescriptionItemsInput>
    create: XOR<MedicineCreateWithoutPrescriptionItemsInput, MedicineUncheckedCreateWithoutPrescriptionItemsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutPrescriptionItemsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutPrescriptionItemsInput, MedicineUncheckedUpdateWithoutPrescriptionItemsInput>
  }

  export type MedicineUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saleItems?: SaleItemUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutPrescriptionItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    saleItems?: SaleItemUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type PrescriptionItemCreateWithoutMedicineInput = {
    id?: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
    prescription: PrescriptionCreateNestedOneWithoutItemsInput
  }

  export type PrescriptionItemUncheckedCreateWithoutMedicineInput = {
    id?: string
    prescriptionId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type PrescriptionItemCreateOrConnectWithoutMedicineInput = {
    where: PrescriptionItemWhereUniqueInput
    create: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput>
  }

  export type PrescriptionItemCreateManyMedicineInputEnvelope = {
    data: PrescriptionItemCreateManyMedicineInput | PrescriptionItemCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type SaleItemCreateWithoutMedicineInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    pharmacySale: PharmacySaleCreateNestedOneWithoutItemsInput
  }

  export type SaleItemUncheckedCreateWithoutMedicineInput = {
    id?: string
    pharmacySaleId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateOrConnectWithoutMedicineInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput>
  }

  export type SaleItemCreateManyMedicineInputEnvelope = {
    data: SaleItemCreateManyMedicineInput | SaleItemCreateManyMedicineInput[]
    skipDuplicates?: boolean
  }

  export type PrescriptionItemUpsertWithWhereUniqueWithoutMedicineInput = {
    where: PrescriptionItemWhereUniqueInput
    update: XOR<PrescriptionItemUpdateWithoutMedicineInput, PrescriptionItemUncheckedUpdateWithoutMedicineInput>
    create: XOR<PrescriptionItemCreateWithoutMedicineInput, PrescriptionItemUncheckedCreateWithoutMedicineInput>
  }

  export type PrescriptionItemUpdateWithWhereUniqueWithoutMedicineInput = {
    where: PrescriptionItemWhereUniqueInput
    data: XOR<PrescriptionItemUpdateWithoutMedicineInput, PrescriptionItemUncheckedUpdateWithoutMedicineInput>
  }

  export type PrescriptionItemUpdateManyWithWhereWithoutMedicineInput = {
    where: PrescriptionItemScalarWhereInput
    data: XOR<PrescriptionItemUpdateManyMutationInput, PrescriptionItemUncheckedUpdateManyWithoutMedicineInput>
  }

  export type SaleItemUpsertWithWhereUniqueWithoutMedicineInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutMedicineInput, SaleItemUncheckedUpdateWithoutMedicineInput>
    create: XOR<SaleItemCreateWithoutMedicineInput, SaleItemUncheckedCreateWithoutMedicineInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutMedicineInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutMedicineInput, SaleItemUncheckedUpdateWithoutMedicineInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutMedicineInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutMedicineInput>
  }

  export type SaleItemScalarWhereInput = {
    AND?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    OR?: SaleItemScalarWhereInput[]
    NOT?: SaleItemScalarWhereInput | SaleItemScalarWhereInput[]
    id?: StringFilter<"SaleItem"> | string
    pharmacySaleId?: StringFilter<"SaleItem"> | string
    medicineId?: StringFilter<"SaleItem"> | string
    quantity?: IntFilter<"SaleItem"> | number
    unitPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFilter<"SaleItem"> | Decimal | DecimalJsLike | number | string
  }

  export type PatientCreateWithoutPharmacySalesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    invoices?: InvoiceCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutPharmacySalesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutPharmacySalesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutPharmacySalesInput, PatientUncheckedCreateWithoutPharmacySalesInput>
  }

  export type PrescriptionCreateWithoutSalesInput = {
    id?: string
    isPaid?: boolean
    date?: Date | string
    patient: PatientCreateNestedOneWithoutPrescriptionsInput
    doctor: StaffProfileCreateNestedOneWithoutPrescriptionsInput
    visit?: OpdVisitCreateNestedOneWithoutPrescriptionsInput
    admission?: AdmissionCreateNestedOneWithoutPrescriptionsInput
    items?: PrescriptionItemCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateWithoutSalesInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
    items?: PrescriptionItemUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionCreateOrConnectWithoutSalesInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutSalesInput, PrescriptionUncheckedCreateWithoutSalesInput>
  }

  export type SaleItemCreateWithoutPharmacySaleInput = {
    id?: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
    medicine: MedicineCreateNestedOneWithoutSaleItemsInput
  }

  export type SaleItemUncheckedCreateWithoutPharmacySaleInput = {
    id?: string
    medicineId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateOrConnectWithoutPharmacySaleInput = {
    where: SaleItemWhereUniqueInput
    create: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput>
  }

  export type SaleItemCreateManyPharmacySaleInputEnvelope = {
    data: SaleItemCreateManyPharmacySaleInput | SaleItemCreateManyPharmacySaleInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutPharmacySalesInput = {
    update: XOR<PatientUpdateWithoutPharmacySalesInput, PatientUncheckedUpdateWithoutPharmacySalesInput>
    create: XOR<PatientCreateWithoutPharmacySalesInput, PatientUncheckedCreateWithoutPharmacySalesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutPharmacySalesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutPharmacySalesInput, PatientUncheckedUpdateWithoutPharmacySalesInput>
  }

  export type PatientUpdateWithoutPharmacySalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutPharmacySalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PrescriptionUpsertWithoutSalesInput = {
    update: XOR<PrescriptionUpdateWithoutSalesInput, PrescriptionUncheckedUpdateWithoutSalesInput>
    create: XOR<PrescriptionCreateWithoutSalesInput, PrescriptionUncheckedCreateWithoutSalesInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutSalesInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutSalesInput, PrescriptionUncheckedUpdateWithoutSalesInput>
  }

  export type PrescriptionUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type SaleItemUpsertWithWhereUniqueWithoutPharmacySaleInput = {
    where: SaleItemWhereUniqueInput
    update: XOR<SaleItemUpdateWithoutPharmacySaleInput, SaleItemUncheckedUpdateWithoutPharmacySaleInput>
    create: XOR<SaleItemCreateWithoutPharmacySaleInput, SaleItemUncheckedCreateWithoutPharmacySaleInput>
  }

  export type SaleItemUpdateWithWhereUniqueWithoutPharmacySaleInput = {
    where: SaleItemWhereUniqueInput
    data: XOR<SaleItemUpdateWithoutPharmacySaleInput, SaleItemUncheckedUpdateWithoutPharmacySaleInput>
  }

  export type SaleItemUpdateManyWithWhereWithoutPharmacySaleInput = {
    where: SaleItemScalarWhereInput
    data: XOR<SaleItemUpdateManyMutationInput, SaleItemUncheckedUpdateManyWithoutPharmacySaleInput>
  }

  export type PharmacySaleCreateWithoutItemsInput = {
    id?: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    patient: PatientCreateNestedOneWithoutPharmacySalesInput
    prescription?: PrescriptionCreateNestedOneWithoutSalesInput
  }

  export type PharmacySaleUncheckedCreateWithoutItemsInput = {
    id?: string
    patientId: string
    prescriptionId?: string | null
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
  }

  export type PharmacySaleCreateOrConnectWithoutItemsInput = {
    where: PharmacySaleWhereUniqueInput
    create: XOR<PharmacySaleCreateWithoutItemsInput, PharmacySaleUncheckedCreateWithoutItemsInput>
  }

  export type MedicineCreateWithoutSaleItemsInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateWithoutSaleItemsInput = {
    id?: string
    name: string
    genericName: string
    batchNumber: string
    expiryDate: Date | string
    stockQuantity: number
    reorderLevel: number
    unitPrice: Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineCreateOrConnectWithoutSaleItemsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutSaleItemsInput, MedicineUncheckedCreateWithoutSaleItemsInput>
  }

  export type PharmacySaleUpsertWithoutItemsInput = {
    update: XOR<PharmacySaleUpdateWithoutItemsInput, PharmacySaleUncheckedUpdateWithoutItemsInput>
    create: XOR<PharmacySaleCreateWithoutItemsInput, PharmacySaleUncheckedCreateWithoutItemsInput>
    where?: PharmacySaleWhereInput
  }

  export type PharmacySaleUpdateToOneWithWhereWithoutItemsInput = {
    where?: PharmacySaleWhereInput
    data: XOR<PharmacySaleUpdateWithoutItemsInput, PharmacySaleUncheckedUpdateWithoutItemsInput>
  }

  export type PharmacySaleUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneRequiredWithoutPharmacySalesNestedInput
    prescription?: PrescriptionUpdateOneWithoutSalesNestedInput
  }

  export type PharmacySaleUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type MedicineUpsertWithoutSaleItemsInput = {
    update: XOR<MedicineUpdateWithoutSaleItemsInput, MedicineUncheckedUpdateWithoutSaleItemsInput>
    create: XOR<MedicineCreateWithoutSaleItemsInput, MedicineUncheckedCreateWithoutSaleItemsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutSaleItemsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutSaleItemsInput, MedicineUncheckedUpdateWithoutSaleItemsInput>
  }

  export type MedicineUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateWithoutSaleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    genericName?: StringFieldUpdateOperationsInput | string
    batchNumber?: StringFieldUpdateOperationsInput | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    stockQuantity?: IntFieldUpdateOperationsInput | number
    reorderLevel?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prescriptionItems?: PrescriptionItemUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type PatientCreateWithoutInvoicesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitCreateNestedManyWithoutPatientInput
    admissions?: AdmissionCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    uhid: string
    firstName: string
    middleName?: string | null
    lastName: string
    dob: Date | string
    gender?: string | null
    maritalStatus?: string | null
    nationality?: string | null
    phone: string
    email?: string | null
    preferredLanguage?: string | null
    permanentAddress?: string | null
    currentAddress?: string | null
    city?: string | null
    state?: string | null
    pincode?: string | null
    idProofType?: string | null
    idProofNumber?: string | null
    abhaId?: string | null
    emergencyContactName?: string | null
    emergencyContactPhone?: string | null
    emergencyContactRelation?: string | null
    defaultPayerType?: string | null
    insuranceProvider?: string | null
    policyNumber?: string | null
    isDeceased?: boolean
    registrationDate?: Date | string
    medicalHistory?: MedicalHistoryUncheckedCreateNestedManyWithoutPatientInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    opdVisits?: OpdVisitUncheckedCreateNestedManyWithoutPatientInput
    admissions?: AdmissionUncheckedCreateNestedManyWithoutPatientInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutPatientInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutPatientInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutPatientInput
    pharmacySales?: PharmacySaleUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutInvoicesInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
  }

  export type AdmissionCreateWithoutInvoicesInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutInvoicesInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    insuranceClaims?: InsuranceClaimUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutInvoicesInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutInvoicesInput, AdmissionUncheckedCreateWithoutInvoicesInput>
  }

  export type OpdVisitCreateWithoutInvoicesInput = {
    id?: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    appointment?: AppointmentCreateNestedOneWithoutOpdVisitInput
    patient: PatientCreateNestedOneWithoutOpdVisitsInput
    doctor: StaffProfileCreateNestedOneWithoutOpdVisitsInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentCreateNestedManyWithoutVisitInput
    admission?: AdmissionCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitUncheckedCreateWithoutInvoicesInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutVisitInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutVisitInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutVisitInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutVisitInput
    admission?: AdmissionUncheckedCreateNestedOneWithoutVisitInput
  }

  export type OpdVisitCreateOrConnectWithoutInvoicesInput = {
    where: OpdVisitWhereUniqueInput
    create: XOR<OpdVisitCreateWithoutInvoicesInput, OpdVisitUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceItemCreateWithoutInvoiceInput = {
    id?: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
    service: ServiceCreateNestedOneWithoutInvoiceItemsInput
    serviceOrder?: ServiceOrderCreateNestedOneWithoutInvoiceItemsInput
  }

  export type InvoiceItemUncheckedCreateWithoutInvoiceInput = {
    id?: string
    serviceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemCreateManyInvoiceInputEnvelope = {
    data: InvoiceItemCreateManyInvoiceInput | InvoiceItemCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutInvoicesInput = {
    update: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<PatientCreateWithoutInvoicesInput, PatientUncheckedCreateWithoutInvoicesInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutInvoicesInput, PatientUncheckedUpdateWithoutInvoicesInput>
  }

  export type PatientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    uhid?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    dob?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    maritalStatus?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    permanentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    currentAddress?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    pincode?: NullableStringFieldUpdateOperationsInput | string | null
    idProofType?: NullableStringFieldUpdateOperationsInput | string | null
    idProofNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactName?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactPhone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContactRelation?: NullableStringFieldUpdateOperationsInput | string | null
    defaultPayerType?: NullableStringFieldUpdateOperationsInput | string | null
    insuranceProvider?: NullableStringFieldUpdateOperationsInput | string | null
    policyNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeceased?: BoolFieldUpdateOperationsInput | boolean
    registrationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalHistory?: MedicalHistoryUncheckedUpdateManyWithoutPatientNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutPatientNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutPatientNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutPatientNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutPatientNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutPatientNestedInput
    pharmacySales?: PharmacySaleUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type AdmissionUpsertWithoutInvoicesInput = {
    update: XOR<AdmissionUpdateWithoutInvoicesInput, AdmissionUncheckedUpdateWithoutInvoicesInput>
    create: XOR<AdmissionCreateWithoutInvoicesInput, AdmissionUncheckedCreateWithoutInvoicesInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutInvoicesInput, AdmissionUncheckedUpdateWithoutInvoicesInput>
  }

  export type AdmissionUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type OpdVisitUpsertWithoutInvoicesInput = {
    update: XOR<OpdVisitUpdateWithoutInvoicesInput, OpdVisitUncheckedUpdateWithoutInvoicesInput>
    create: XOR<OpdVisitCreateWithoutInvoicesInput, OpdVisitUncheckedCreateWithoutInvoicesInput>
    where?: OpdVisitWhereInput
  }

  export type OpdVisitUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: OpdVisitWhereInput
    data: XOR<OpdVisitUpdateWithoutInvoicesInput, OpdVisitUncheckedUpdateWithoutInvoicesInput>
  }

  export type OpdVisitUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type InvoiceItemUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    update: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceItemCreateWithoutInvoiceInput, InvoiceItemUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceItemWhereUniqueInput
    data: XOR<InvoiceItemUpdateWithoutInvoiceInput, InvoiceItemUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceItemUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceItemScalarWhereInput
    data: XOR<InvoiceItemUpdateManyMutationInput, InvoiceItemUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceCreateWithoutItemsInput = {
    id?: string
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
    patient: PatientCreateNestedOneWithoutInvoicesInput
    admission?: AdmissionCreateNestedOneWithoutInvoicesInput
    visit?: OpdVisitCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutItemsInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
  }

  export type InvoiceCreateOrConnectWithoutItemsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
  }

  export type ServiceCreateWithoutInvoiceItemsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    department: DepartmentCreateNestedOneWithoutServicesInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    departmentId: string
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutInvoiceItemsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type ServiceOrderCreateWithoutInvoiceItemsInput = {
    id?: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    patient: PatientCreateNestedOneWithoutServiceOrdersInput
    doctor: StaffProfileCreateNestedOneWithoutServiceOrdersInput
    visit?: OpdVisitCreateNestedOneWithoutServiceOrdersInput
    admission?: AdmissionCreateNestedOneWithoutServiceOrdersInput
    service: ServiceCreateNestedOneWithoutServiceOrdersInput
    labResults?: LabResultCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderUncheckedCreateWithoutInvoiceItemsInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
    labResults?: LabResultUncheckedCreateNestedManyWithoutServiceOrderInput
  }

  export type ServiceOrderCreateOrConnectWithoutInvoiceItemsInput = {
    where: ServiceOrderWhereUniqueInput
    create: XOR<ServiceOrderCreateWithoutInvoiceItemsInput, ServiceOrderUncheckedCreateWithoutInvoiceItemsInput>
  }

  export type InvoiceUpsertWithoutItemsInput = {
    update: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
    create: XOR<InvoiceCreateWithoutItemsInput, InvoiceUncheckedCreateWithoutItemsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutItemsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutItemsInput, InvoiceUncheckedUpdateWithoutItemsInput>
  }

  export type InvoiceUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    admission?: AdmissionUpdateOneWithoutInvoicesNestedInput
    visit?: OpdVisitUpdateOneWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type ServiceUpsertWithoutInvoiceItemsInput = {
    update: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ServiceCreateWithoutInvoiceItemsInput, ServiceUncheckedCreateWithoutInvoiceItemsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutInvoiceItemsInput, ServiceUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ServiceUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    department?: DepartmentUpdateOneRequiredWithoutServicesNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    departmentId?: StringFieldUpdateOperationsInput | string
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceOrderUpsertWithoutInvoiceItemsInput = {
    update: XOR<ServiceOrderUpdateWithoutInvoiceItemsInput, ServiceOrderUncheckedUpdateWithoutInvoiceItemsInput>
    create: XOR<ServiceOrderCreateWithoutInvoiceItemsInput, ServiceOrderUncheckedCreateWithoutInvoiceItemsInput>
    where?: ServiceOrderWhereInput
  }

  export type ServiceOrderUpdateToOneWithWhereWithoutInvoiceItemsInput = {
    where?: ServiceOrderWhereInput
    data: XOR<ServiceOrderUpdateWithoutInvoiceItemsInput, ServiceOrderUncheckedUpdateWithoutInvoiceItemsInput>
  }

  export type ServiceOrderUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutInvoiceItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type AdmissionCreateWithoutInsuranceClaimsInput = {
    id?: string
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    patient: PatientCreateNestedOneWithoutAdmissionsInput
    admittingDoctor: StaffProfileCreateNestedOneWithoutAdmissionsInput
    department: DepartmentCreateNestedOneWithoutAdmissionsInput
    visit?: OpdVisitCreateNestedOneWithoutAdmissionInput
    currentBed?: BedCreateNestedOneWithoutActiveAdmissionsInput
    bedTransfers?: BedTransferCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionUncheckedCreateWithoutInsuranceClaimsInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
    bedTransfers?: BedTransferUncheckedCreateNestedManyWithoutAdmissionInput
    surgeries?: SurgeryUncheckedCreateNestedManyWithoutAdmissionInput
    clinicalNotes?: ClinicalNoteUncheckedCreateNestedManyWithoutAdmissionInput
    serviceOrders?: ServiceOrderUncheckedCreateNestedManyWithoutAdmissionInput
    prescriptions?: PrescriptionUncheckedCreateNestedManyWithoutAdmissionInput
    documents?: PatientDocumentUncheckedCreateNestedManyWithoutAdmissionInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutAdmissionInput
  }

  export type AdmissionCreateOrConnectWithoutInsuranceClaimsInput = {
    where: AdmissionWhereUniqueInput
    create: XOR<AdmissionCreateWithoutInsuranceClaimsInput, AdmissionUncheckedCreateWithoutInsuranceClaimsInput>
  }

  export type AdmissionUpsertWithoutInsuranceClaimsInput = {
    update: XOR<AdmissionUpdateWithoutInsuranceClaimsInput, AdmissionUncheckedUpdateWithoutInsuranceClaimsInput>
    create: XOR<AdmissionCreateWithoutInsuranceClaimsInput, AdmissionUncheckedCreateWithoutInsuranceClaimsInput>
    where?: AdmissionWhereInput
  }

  export type AdmissionUpdateToOneWithWhereWithoutInsuranceClaimsInput = {
    where?: AdmissionWhereInput
    data: XOR<AdmissionUpdateWithoutInsuranceClaimsInput, AdmissionUncheckedUpdateWithoutInsuranceClaimsInput>
  }

  export type AdmissionUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutInsuranceClaimsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type LabResultCreateManyTechnicianInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type LabResultUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceOrder?: ServiceOrderUpdateOneRequiredWithoutLabResultsNestedInput
    verifiedBy?: StaffProfileUpdateOneWithoutVerifiedResultsNestedInput
  }

  export type LabResultUncheckedUpdateWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUncheckedUpdateManyWithoutTechnicianInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyHeadDoctorInput = {
    id?: string
    name: string
    code: string
    type: $Enums.DepartmentType
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: string
    patientId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
  }

  export type OpdVisitCreateManyDoctorInput = {
    id?: string
    appointmentId?: string | null
    patientId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
  }

  export type AdmissionCreateManyAdmittingDoctorInput = {
    id?: string
    patientId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
  }

  export type SurgeryCreateManySurgeonInput = {
    id?: string
    admissionId: string
    procedureName: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
  }

  export type ClinicalNoteCreateManyDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ServiceOrderCreateManyDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type LabResultCreateManyVerifiedByInput = {
    id?: string
    serviceOrderId: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    resultDate?: Date | string
  }

  export type PrescriptionCreateManyDoctorInput = {
    id?: string
    patientId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
  }

  export type SurgerySStaffCreateManyStaffInput = {
    surgeryId: string
    role: string
  }

  export type DepartmentUpdateWithoutHeadDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUpdateManyWithoutDepartmentNestedInput
    wards?: WardUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutHeadDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
    staff?: StaffProfileUncheckedUpdateManyWithoutDepartmentNestedInput
    services?: ServiceUncheckedUpdateManyWithoutDepartmentNestedInput
    wards?: WardUncheckedUpdateManyWithoutDepartmentNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDepartmentNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutHeadDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumDepartmentTypeFieldUpdateOperationsInput | $Enums.DepartmentType
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAppointmentsNestedInput
    opdVisit?: OpdVisitUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type OpdVisitUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    patient?: PatientUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    patientId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdmissionUpdateWithoutAdmittingDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutAdmittingDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutAdmittingDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SurgeryUpdateWithoutSurgeonInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutSurgeriesNestedInput
    checklists?: SurgicalChecklistUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateWithoutSurgeonInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checklists?: SurgicalChecklistUncheckedUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateManyWithoutSurgeonInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicalNoteUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutClinicalNotesNestedInput
    visit?: OpdVisitUpdateOneWithoutClinicalNotesNestedInput
    admission?: AdmissionUpdateOneWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceOrder?: ServiceOrderUpdateOneRequiredWithoutLabResultsNestedInput
    technician?: UserUpdateOneWithoutLabResultsNestedInput
  }

  export type LabResultUncheckedUpdateWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUncheckedUpdateManyWithoutVerifiedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutDoctorInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgerySStaffUpdateWithoutStaffInput = {
    role?: StringFieldUpdateOperationsInput | string
    surgery?: SurgeryUpdateOneRequiredWithoutSurgerySStaffsNestedInput
  }

  export type SurgerySStaffUncheckedUpdateWithoutStaffInput = {
    surgeryId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SurgerySStaffUncheckedUpdateManyWithoutStaffInput = {
    surgeryId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type StaffProfileCreateManyDepartmentInput = {
    id: string
    fullName: string
    qualification?: string | null
    registrationNumber?: string | null
    contactNumber?: string | null
    shiftTiming?: string | null
  }

  export type ServiceCreateManyDepartmentInput = {
    id?: string
    name: string
    category: $Enums.ServiceCategory
    basePrice: Decimal | DecimalJsLike | number | string
    code?: string | null
    isActive?: boolean
  }

  export type WardCreateManyDepartmentInput = {
    id?: string
    name: string
    floorNumber: number
    type: string
    basePricePerDay: Decimal | DecimalJsLike | number | string
  }

  export type AppointmentCreateManyDepartmentInput = {
    id?: string
    patientId: string
    doctorId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
  }

  export type AdmissionCreateManyDepartmentInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
  }

  export type StaffProfileUpdateWithoutDepartmentInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    headOfDepartments?: DepartmentUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
    headOfDepartments?: DepartmentUncheckedUpdateManyWithoutHeadDoctorNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    opdVisits?: OpdVisitUncheckedUpdateManyWithoutDoctorNestedInput
    admissions?: AdmissionUncheckedUpdateManyWithoutAdmittingDoctorNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutSurgeonNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutDoctorNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutDoctorNestedInput
    verifiedResults?: LabResultUncheckedUpdateManyWithoutVerifiedByNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutDoctorNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    qualification?: NullableStringFieldUpdateOperationsInput | string | null
    registrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    contactNumber?: NullableStringFieldUpdateOperationsInput | string | null
    shiftTiming?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceOrders?: ServiceOrderUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutServiceNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    basePrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WardUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beds?: BedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    beds?: BedUncheckedUpdateManyWithoutWardNestedInput
  }

  export type WardUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    floorNumber?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    basePricePerDay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type AppointmentUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutAppointmentsNestedInput
    opdVisit?: OpdVisitUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type AdmissionUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderCreateManyServiceInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type InvoiceItemCreateManyServiceInput = {
    id?: string
    invoiceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type ServiceOrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    serviceOrder?: ServiceOrderUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BedCreateManyWardInput = {
    id?: string
    bedNumber: string
    status: $Enums.BedStatus
  }

  export type BedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    transfers?: BedTransferUpdateManyWithoutBedNestedInput
    activeAdmissions?: AdmissionUpdateManyWithoutCurrentBedNestedInput
  }

  export type BedUncheckedUpdateWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
    transfers?: BedTransferUncheckedUpdateManyWithoutBedNestedInput
    activeAdmissions?: AdmissionUncheckedUpdateManyWithoutCurrentBedNestedInput
  }

  export type BedUncheckedUpdateManyWithoutWardInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedNumber?: StringFieldUpdateOperationsInput | string
    status?: EnumBedStatusFieldUpdateOperationsInput | $Enums.BedStatus
  }

  export type BedTransferCreateManyBedInput = {
    id?: string
    admissionId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type AdmissionCreateManyCurrentBedInput = {
    id?: string
    patientId: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
  }

  export type BedTransferUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    admission?: AdmissionUpdateOneRequiredWithoutBedTransfersNestedInput
  }

  export type BedTransferUncheckedUpdateWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedTransferUncheckedUpdateManyWithoutBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdmissionUpdateWithoutCurrentBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutAdmissionsNestedInput
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutCurrentBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutCurrentBedInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalHistoryCreateManyPatientInput = {
    id?: string
    category: string
    name: string
    severity?: string | null
    status?: string | null
    diagnosedDate?: Date | string | null
    notes?: string | null
  }

  export type PatientDocumentCreateManyPatientInput = {
    id?: string
    visitId?: string | null
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    doctorId: string
    departmentId: string
    appointmentDate: Date | string
    tokenNumber: number
    status: $Enums.AppointmentStatus
    type: $Enums.AppointmentType
  }

  export type OpdVisitCreateManyPatientInput = {
    id?: string
    appointmentId?: string | null
    doctorId: string
    visitDate?: Date | string
    visitType: $Enums.VisitType
    triageColor?: $Enums.TriageColor | null
    status: $Enums.VisitStatus
    isMedicoLegal?: boolean
  }

  export type AdmissionCreateManyPatientInput = {
    id?: string
    admittingDoctorId: string
    departmentId: string
    visitId?: string | null
    currentBedId?: string | null
    admissionDate?: Date | string
    dischargeDate?: Date | string | null
    reasonForAdmission?: string | null
    admissionType: $Enums.AdmissionType
    status: $Enums.AdmissionStatus
    dischargeType?: $Enums.DischargeType | null
    mlc?: boolean
  }

  export type ClinicalNoteCreateManyPatientInput = {
    id?: string
    visitId?: string | null
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ServiceOrderCreateManyPatientInput = {
    id?: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type PrescriptionCreateManyPatientInput = {
    id?: string
    doctorId: string
    visitId?: string | null
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
  }

  export type PharmacySaleCreateManyPatientInput = {
    id?: string
    prescriptionId?: string | null
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceCreateManyPatientInput = {
    id?: string
    admissionId?: string | null
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
  }

  export type MedicalHistoryUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalHistoryUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalHistoryUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    severity?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientDocumentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    visit?: OpdVisitUpdateOneWithoutDocumentsNestedInput
    admission?: AdmissionUpdateOneWithoutDocumentsNestedInput
  }

  export type PatientDocumentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    doctor?: StaffProfileUpdateOneRequiredWithoutAppointmentsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAppointmentsNestedInput
    opdVisit?: OpdVisitUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    opdVisit?: OpdVisitUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    tokenNumber?: IntFieldUpdateOperationsInput | number
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
  }

  export type OpdVisitUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    appointment?: AppointmentUpdateOneWithoutOpdVisitNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutOpdVisitsNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutVisitNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutVisitNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutVisitNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutVisitNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutVisitNestedInput
    admission?: AdmissionUncheckedUpdateOneWithoutVisitNestedInput
  }

  export type OpdVisitUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    visitDate?: DateTimeFieldUpdateOperationsInput | Date | string
    visitType?: EnumVisitTypeFieldUpdateOperationsInput | $Enums.VisitType
    triageColor?: NullableEnumTriageColorFieldUpdateOperationsInput | $Enums.TriageColor | null
    status?: EnumVisitStatusFieldUpdateOperationsInput | $Enums.VisitStatus
    isMedicoLegal?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AdmissionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    admittingDoctor?: StaffProfileUpdateOneRequiredWithoutAdmissionsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutAdmissionsNestedInput
    visit?: OpdVisitUpdateOneWithoutAdmissionNestedInput
    currentBed?: BedUpdateOneWithoutActiveAdmissionsNestedInput
    bedTransfers?: BedTransferUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
    bedTransfers?: BedTransferUncheckedUpdateManyWithoutAdmissionNestedInput
    surgeries?: SurgeryUncheckedUpdateManyWithoutAdmissionNestedInput
    clinicalNotes?: ClinicalNoteUncheckedUpdateManyWithoutAdmissionNestedInput
    serviceOrders?: ServiceOrderUncheckedUpdateManyWithoutAdmissionNestedInput
    prescriptions?: PrescriptionUncheckedUpdateManyWithoutAdmissionNestedInput
    documents?: PatientDocumentUncheckedUpdateManyWithoutAdmissionNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutAdmissionNestedInput
    insuranceClaims?: InsuranceClaimUncheckedUpdateManyWithoutAdmissionNestedInput
  }

  export type AdmissionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admittingDoctorId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    currentBedId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dischargeDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reasonForAdmission?: NullableStringFieldUpdateOperationsInput | string | null
    admissionType?: EnumAdmissionTypeFieldUpdateOperationsInput | $Enums.AdmissionType
    status?: EnumAdmissionStatusFieldUpdateOperationsInput | $Enums.AdmissionStatus
    dischargeType?: NullableEnumDischargeTypeFieldUpdateOperationsInput | $Enums.DischargeType | null
    mlc?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
    visit?: OpdVisitUpdateOneWithoutClinicalNotesNestedInput
    admission?: AdmissionUpdateOneWithoutClinicalNotesNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PharmacySaleUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    prescription?: PrescriptionUpdateOneWithoutSalesNestedInput
    items?: SaleItemUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    admission?: AdmissionUpdateOneWithoutInvoicesNestedInput
    visit?: OpdVisitUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type ClinicalNoteCreateManyVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ServiceOrderCreateManyVisitInput = {
    id?: string
    patientId: string
    doctorId: string
    admissionId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type PrescriptionCreateManyVisitInput = {
    id?: string
    patientId: string
    doctorId: string
    admissionId?: string | null
    isPaid?: boolean
    date?: Date | string
  }

  export type PatientDocumentCreateManyVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type InvoiceCreateManyVisitInput = {
    id?: string
    patientId: string
    admissionId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
  }

  export type ClinicalNoteUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutClinicalNotesNestedInput
    admission?: AdmissionUpdateOneWithoutClinicalNotesNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    admission?: AdmissionUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    admission?: AdmissionUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    admission?: AdmissionUpdateOneWithoutDocumentsNestedInput
  }

  export type PatientDocumentUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    admission?: AdmissionUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutVisitInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    admissionId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type BedTransferCreateManyAdmissionInput = {
    id?: string
    bedId: string
    startDate?: Date | string
    endDate?: Date | string | null
    reason?: string | null
  }

  export type SurgeryCreateManyAdmissionInput = {
    id?: string
    procedureName: string
    surgeonId: string
    otRoomNumber?: string | null
    surgeryDate: Date | string
    status: $Enums.SurgeryStatus
    notes?: string | null
  }

  export type ClinicalNoteCreateManyAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    doctorId: string
    noteType: $Enums.NoteType
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    isFinalized?: boolean
  }

  export type ServiceOrderCreateManyAdmissionInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    serviceId: string
    orderType: $Enums.OrderType
    priority: $Enums.OrderPriority
    clinicalIndication?: string | null
    isPaid?: boolean
    status: $Enums.OrderStatus
    orderDate?: Date | string
  }

  export type PrescriptionCreateManyAdmissionInput = {
    id?: string
    patientId: string
    doctorId: string
    visitId?: string | null
    isPaid?: boolean
    date?: Date | string
  }

  export type PatientDocumentCreateManyAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    category: string
    fileUrl: string
    uploadedBy?: string | null
    uploadedAt?: Date | string
  }

  export type InvoiceCreateManyAdmissionInput = {
    id?: string
    patientId: string
    visitId?: string | null
    invoiceDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
    taxAmount: Decimal | DecimalJsLike | number | string
    discountAmount: Decimal | DecimalJsLike | number | string
    netAmount: Decimal | DecimalJsLike | number | string
    status: $Enums.InvoiceStatus
  }

  export type InsuranceClaimCreateManyAdmissionInput = {
    id?: string
    providerName: string
    policyNumber: string
    claimAmount: Decimal | DecimalJsLike | number | string
    approvedAmount?: Decimal | DecimalJsLike | number | string | null
    status: $Enums.ClaimStatus
    submissionDate?: Date | string
  }

  export type BedTransferUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    bed?: BedUpdateOneRequiredWithoutTransfersNestedInput
  }

  export type BedTransferUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BedTransferUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    bedId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SurgeryUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    surgeon?: StaffProfileUpdateOneRequiredWithoutSurgeriesNestedInput
    checklists?: SurgicalChecklistUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checklists?: SurgicalChecklistUncheckedUpdateManyWithoutSurgeryNestedInput
    surgerySStaffs?: SurgerySStaffUncheckedUpdateManyWithoutSurgeryNestedInput
  }

  export type SurgeryUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    procedureName?: StringFieldUpdateOperationsInput | string
    surgeonId?: StringFieldUpdateOperationsInput | string
    otRoomNumber?: NullableStringFieldUpdateOperationsInput | string | null
    surgeryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumSurgeryStatusFieldUpdateOperationsInput | $Enums.SurgeryStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClinicalNoteUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
    patient?: PatientUpdateOneRequiredWithoutClinicalNotesNestedInput
    visit?: OpdVisitUpdateOneWithoutClinicalNotesNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutClinicalNotesNestedInput
  }

  export type ClinicalNoteUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ClinicalNoteUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    doctorId?: StringFieldUpdateOperationsInput | string
    noteType?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isFinalized?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceOrderUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutServiceOrdersNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutServiceOrdersNestedInput
    visit?: OpdVisitUpdateOneWithoutServiceOrdersNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceOrdersNestedInput
    labResults?: LabResultUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    labResults?: LabResultUncheckedUpdateManyWithoutServiceOrderNestedInput
    invoiceItems?: InvoiceItemUncheckedUpdateManyWithoutServiceOrderNestedInput
  }

  export type ServiceOrderUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    orderType?: EnumOrderTypeFieldUpdateOperationsInput | $Enums.OrderType
    priority?: EnumOrderPriorityFieldUpdateOperationsInput | $Enums.OrderPriority
    clinicalIndication?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutPrescriptionsNestedInput
    doctor?: StaffProfileUpdateOneRequiredWithoutPrescriptionsNestedInput
    visit?: OpdVisitUpdateOneWithoutPrescriptionsNestedInput
    items?: PrescriptionItemUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PrescriptionItemUncheckedUpdateManyWithoutPrescriptionNestedInput
    sales?: PharmacySaleUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    doctorId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutDocumentsNestedInput
    visit?: OpdVisitUpdateOneWithoutDocumentsNestedInput
  }

  export type PatientDocumentUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientDocumentUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    patient?: PatientUpdateOneRequiredWithoutInvoicesNestedInput
    visit?: OpdVisitUpdateOneWithoutInvoicesNestedInput
    items?: InvoiceItemUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    items?: InvoiceItemUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    visitId?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    discountAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    netAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
  }

  export type InsuranceClaimUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUncheckedUpdateWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsuranceClaimUncheckedUpdateManyWithoutAdmissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerName?: StringFieldUpdateOperationsInput | string
    policyNumber?: StringFieldUpdateOperationsInput | string
    claimAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approvedAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumClaimStatusFieldUpdateOperationsInput | $Enums.ClaimStatus
    submissionDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgicalChecklistCreateManySurgeryInput = {
    id?: string
    stage: $Enums.ChecklistStage
    itemName: string
    isChecked?: boolean
    checkedBy?: string | null
    timestamp?: Date | string
  }

  export type SurgerySStaffCreateManySurgeryInput = {
    staffId: string
    role: string
  }

  export type SurgicalChecklistUpdateWithoutSurgeryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgicalChecklistUncheckedUpdateWithoutSurgeryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgicalChecklistUncheckedUpdateManyWithoutSurgeryInput = {
    id?: StringFieldUpdateOperationsInput | string
    stage?: EnumChecklistStageFieldUpdateOperationsInput | $Enums.ChecklistStage
    itemName?: StringFieldUpdateOperationsInput | string
    isChecked?: BoolFieldUpdateOperationsInput | boolean
    checkedBy?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SurgerySStaffUpdateWithoutSurgeryInput = {
    role?: StringFieldUpdateOperationsInput | string
    staff?: StaffProfileUpdateOneRequiredWithoutSurgerySStaffsNestedInput
  }

  export type SurgerySStaffUncheckedUpdateWithoutSurgeryInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type SurgerySStaffUncheckedUpdateManyWithoutSurgeryInput = {
    staffId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
  }

  export type LabResultCreateManyServiceOrderInput = {
    id?: string
    testName: string
    resultValue: string
    referenceRange?: string | null
    unit?: string | null
    technicianId?: string | null
    verifiedByDoctorId?: string | null
    resultDate?: Date | string
  }

  export type InvoiceItemCreateManyServiceOrderInput = {
    id?: string
    invoiceId: string
    serviceId: string
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type LabResultUpdateWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
    technician?: UserUpdateOneWithoutLabResultsNestedInput
    verifiedBy?: StaffProfileUpdateOneWithoutVerifiedResultsNestedInput
  }

  export type LabResultUncheckedUpdateWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabResultUncheckedUpdateManyWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    testName?: StringFieldUpdateOperationsInput | string
    resultValue?: StringFieldUpdateOperationsInput | string
    referenceRange?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    technicianId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedByDoctorId?: NullableStringFieldUpdateOperationsInput | string | null
    resultDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceItemUpdateWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    invoice?: InvoiceUpdateOneRequiredWithoutItemsNestedInput
    service?: ServiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutServiceOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PrescriptionItemCreateManyPrescriptionInput = {
    id?: string
    medicineId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type PharmacySaleCreateManyPrescriptionInput = {
    id?: string
    patientId: string
    saleDate?: Date | string
    totalAmount: Decimal | DecimalJsLike | number | string
  }

  export type PrescriptionItemUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    medicine?: MedicineUpdateOneRequiredWithoutPrescriptionItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PharmacySaleUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    patient?: PatientUpdateOneRequiredWithoutPharmacySalesNestedInput
    items?: SaleItemUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleUncheckedUpdateWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    items?: SaleItemUncheckedUpdateManyWithoutPharmacySaleNestedInput
  }

  export type PharmacySaleUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type PrescriptionItemCreateManyMedicineInput = {
    id?: string
    prescriptionId: string
    dosage: string
    frequency: string
    duration: string
    instruction?: string | null
  }

  export type SaleItemCreateManyMedicineInput = {
    id?: string
    pharmacySaleId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type PrescriptionItemUpdateWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
    prescription?: PrescriptionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PrescriptionItemUncheckedUpdateWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrescriptionItemUncheckedUpdateManyWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    prescriptionId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    instruction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SaleItemUpdateWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pharmacySale?: PharmacySaleUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    pharmacySaleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyWithoutMedicineInput = {
    id?: StringFieldUpdateOperationsInput | string
    pharmacySaleId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemCreateManyPharmacySaleInput = {
    id?: string
    medicineId: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    totalPrice: Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUpdateWithoutPharmacySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    medicine?: MedicineUpdateOneRequiredWithoutSaleItemsNestedInput
  }

  export type SaleItemUncheckedUpdateWithoutPharmacySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type SaleItemUncheckedUpdateManyWithoutPharmacySaleInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemCreateManyInvoiceInput = {
    id?: string
    serviceId: string
    serviceOrderId?: string | null
    itemName: string
    quantity: number
    unitPrice: Decimal | DecimalJsLike | number | string
    total: Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    service?: ServiceUpdateOneRequiredWithoutInvoiceItemsNestedInput
    serviceOrder?: ServiceOrderUpdateOneWithoutInvoiceItemsNestedInput
  }

  export type InvoiceItemUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type InvoiceItemUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    serviceOrderId?: NullableStringFieldUpdateOperationsInput | string | null
    itemName?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}